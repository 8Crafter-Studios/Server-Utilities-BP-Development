import { Vector3Utils, VECTOR3_ONE, VECTOR3_FORWARD, VECTOR3_DOWN, VECTOR3_UP, VECTOR3_SOUTH, VECTOR3_NORTH, VECTOR3_EAST, VECTOR3_WEST } from "@minecraft/math";
import { Player, ChatSendBeforeEvent, world, EntityInventoryComponent, BlockInventoryComponent, system, ItemStack, EntityEquippableComponent, PlayerCursorInventoryComponent, EquipmentSlot, ItemLockMode, EnchantmentTypes, ContainerSlot, DimensionTypes, StructureSaveMode, StructureAnimationMode, StructureMirrorAxis, StructureRotation, BlockPermutation, BlockVolume, type Vector3, BlockTypes, Entity, Block, CompoundBlockVolume, ItemTypes, Dimension, EntityComponentTypes } from "@minecraft/server";
import { uiManager } from "@minecraft/server-ui";
import { listoftransformrecipes } from "Assets/constants/transformrecipes";
import { rgbToHsl, rgbToHSLuv, rgbToHsv, rgbToHsi, rgbToHPLuv, Color } from "color-core";
import { PlayerShopManager, PlayerShop } from "ExtraFeatures/player_shop";
import { LinkedServerShopCommands, ServerShopManager, ServerShop } from "ExtraFeatures/server_shop";
import { mainShopSystemSettings } from "ExtraFeatures/shop_main";
import { PlayerNotifications } from "init/classes/PlayerNotifications";
import { Vector } from "init/classes/Vector";
import { HSLToRGB } from "legacyModuleAliases/utilities";
import { srun, config, dimensionTypeDisplayFormattingF, getTopSolidBlock, dimensionTypeDisplayFormatting, clearAllContainerBlocks, scanForContainerBlocks, fillBlocksH, fillBlocksHW, fillBlocksHH, fillBlocksHO, fillBlocksHP, fillBlocksHSGG, fillBlocksHISGG, fillBlocksHHOG, fillBlocksHOG, fillBlocksHHSG, fillBlocksHDG, fillBlocksHSG, fillBlocksHSSG, fillBlocksHC, fillBlocksHT, fillBlocksHFG, fillBlocksHWG, fillBlocksHHG, fillBlocksHOTG, fillBlocksCG, fillBlocksC, fillBlocksB, fillBlocksHFGBM, fillBlocksHFGB, fillBlocksHFFGB, fillBlocksHDFGB, fillBlocksHWFGB, fillBlocksHSGB, fillBlocksHHSGB, fillBlocksHCGB, dimensionsb, dimensions, dimensionTypeDisplayFormattingD, fillBlocksHB, overworld } from "Main";
import type { command } from "modules/commands/classes/command";
import { disconnectingPlayers } from "modules/commands/constants/disconnectingPlayers";
import { AreaBackups } from "modules/coordinates/classes/AreaBackups";
import { blockClipboard } from "modules/coordinates/classes/blockClipboard";
import { undoClipboard } from "modules/coordinates/classes/undoClipboard";
import { WorldPosition } from "modules/coordinates/classes/WorldPosition";
import { caretNotationC } from "modules/coordinates/functions/caretNotationC";
import { chunkIndexToBoundingBox } from "modules/coordinates/functions/chunkIndexToBoundingBox";
import { chunkIndexToBoundingBoxB } from "modules/coordinates/functions/chunkIndexToBoundingBoxB";
import { coordinatesB } from "modules/coordinates/functions/coordinatesB";
import { diroffsetmapb } from "modules/coordinates/functions/diroffsetmapb";
import { evaluateCoordinates } from "modules/coordinates/functions/evaluateCoordinates";
import { evaluateRotationCoordinates } from "modules/coordinates/functions/evaluateRotationCoordinates";
import { generateMathExpression } from "modules/coordinates/functions/generateMathExpression";
import { generateTickingAreaFillCoordinatesC } from "modules/coordinates/functions/generateTickingAreaFillCoordinatesC";
import { getChunkIndex } from "modules/coordinates/functions/getChunkIndex";
import { parseExpression } from "modules/coordinates/functions/parseExpression";
import { parseExpressionB } from "modules/coordinates/functions/parseExpressionB";
import { parseExpressionBKE } from "modules/coordinates/functions/parseExpressionBKE";
import { parseExpressionBR } from "modules/coordinates/functions/parseExpressionBR";
import { parseExpressionKE } from "modules/coordinates/functions/parseExpressionKE";
import { parseExpressionR } from "modules/coordinates/functions/parseExpressionR";
import { removeAirFromStructure } from "modules/coordinates/functions/removeAirFromStructure";
import { roundVector3ToMiddleOfBlock } from "modules/coordinates/functions/roundVector3ToMiddleOfBlock";
import { roundVector3ToMiddleOfBlockFloorY } from "modules/coordinates/functions/roundVector3ToMiddleOfBlockFloorY";
import { VSTR } from "modules/coordinates/functions/VSTR";
import { savedPlayer } from "modules/player_save/classes/savedPlayer";
import { spawnProtectionTypeList } from "modules/spawn_protection/functions/spawnProtectionTypeList";
import { chatCommandRunner } from "modules/ui/functions/chatCommandRunner";
import { chatMessageNoCensor } from "modules/ui/functions/chatMessageNoCensor";
import { chatSendNoCensor } from "modules/ui/functions/chatSendNoCensor";
import { editorStick } from "modules/ui/functions/editorStick";
import { editorStickMenuB } from "modules/ui/functions/editorStickMenuB";
import { editorStickMenuC } from "modules/ui/functions/editorStickMenuC";
import { extraFeaturesSettings } from "modules/ui/functions/extraFeaturesSettings";
import { mainMenu } from "modules/ui/functions/mainMenu";
import { manageCommands } from "modules/ui/functions/manageCommands";
import { managePlayers } from "modules/ui/functions/managePlayers";
import { notificationsSettings } from "modules/ui/functions/notificationsSettings";
import { settings } from "modules/ui/functions/settings";
import { terminal } from "modules/ui/functions/terminal";
import { worldBorderSettings } from "modules/ui/functions/worldBorderSettings";
import { arrayModifier } from "modules/utilities/functions/arrayModifier";
import { extractJSONStrings } from "modules/utilities/functions/extractJSONStrings";
import { mcRGBAToColorCoreRGB } from "modules/utilities/functions/mcRGBAToColorCoreRGB";
import { shuffle } from "modules/utilities/functions/shuffle";
import { ban } from "../../../Main/ban";
import { requestConditionalChatInput } from "../../../Main/chat";
import { itemJSONPropertiesEval, containerToItemStackArray, targetSelectorB, targetSelectorAllListB, targetSelectorAllListC, targetSelectorAllListE, getPlayerselectedSlotIndex, itemJSONPropertiesEvalCT, getSlotFromParsedSlot, parseSlot, fillmodetypeenum, containerToContainerSlotArray, inventorySwap, inventorySwapB, equippableToItemStackArray, equippableToContainerSlotArray, inventorySwapC, clearContainer, rangeToIntArray, JunkItemTypes, OpItemTypes, IllegalItemTypes, entityToContainerSlotArray, fillContainer, getPlayerHeldItemSlot } from "../../../Main/command_utilities";
import { evaluateParameters } from "modules/commands/functions/evaluateParameters";
import { evaluateParametersOld } from "modules/commands/functions/evaluateParametersOld";
import { vTV3 } from "Main/vTV3";
import { executeCommandPlayerW } from "modules/commands/classes/executeCommandPlayerW";
import { HomeSystem } from "modules/commands/classes/HomeSystem";
import { Home } from "modules/commands/classes/Home";
import { BlockPattern } from "modules/commands/classes/BlockPattern";
import { testBlockForMatch } from "modules/commands/functions/testBlockForMatch";
import { vTStr } from "modules/commands/functions/vTStr";
import { despawnEntities } from "./despawnEntities";
import { getCommandHelpPage, getCommandHelpPageExtra, getCommandHelpPageDebug, getCommandHelpPageDebugPlus, getCommandHelpPageCustomDebug, helpCommandChatCommandsList } from "../../../Main/commands_documentation";
import { commands } from "../../../Main/commands_list";

export function chatCommands(params: {
    returnBeforeChatSend: boolean | undefined;
    player: Player | executeCommandPlayerW | undefined;
    eventData: ChatSendBeforeEvent;
    event: ChatSendBeforeEvent | undefined;
    newMessage: string | undefined;
    fromExecute?: boolean;
    silentCMD?: boolean;
    isBultIn?: boolean;
    isCustom?: boolean;
}) {
    let returnBeforeChatSend = params.returnBeforeChatSend ?? false;
    let playerab = params.player ?? params.eventData?.sender ?? params.event?.sender;
    let playera = playerab instanceof executeCommandPlayerW
        ? playerab
        : new executeCommandPlayerW(playerab);
    Object.defineProperties(playera, {
        id: {
            value: playera.player.id,
            writable: false,
            enumerable: true,
            configurable: true,
        },
        typeId: {
            value: playera.player.typeId,
            writable: false,
            enumerable: true,
            configurable: true,
        },
        name: {
            value: playera.player.name,
            writable: false,
            enumerable: true,
            configurable: true,
        },
    });
    let player = playera as executeCommandPlayerW & {
        readonly id: string;
        readonly typeId: string;
        readonly name: string;
    };
    //let player = Object.assign(((playera instanceof executeCommandPlayer)?playera:(playera instanceof executeCommandPlayerW)?playera:new executeCommandPlayer(playera)).player, (playera instanceof executeCommandPlayer)?Object.setPrototypeOf(playera, executeCommandPlayerW.prototype) as executeCommandPlayerW:(playera instanceof executeCommandPlayerW)?playera:new executeCommandPlayerW(playera));
    let eventData = !!params.eventData
        ? {
            get sender() {
                return player;
            },
            get cancel() {
                return params.eventData.cancel;
            },
            set cancel(cancel: boolean) {
                params.eventData.cancel = cancel;
            },
            get targets() {
                return params.eventData.targets;
            },
            get message() {
                return params.eventData.message;
            },
        }
        : {
            get sender() {
                return player;
            },
            get cancel() {
                return params.event.cancel;
            },
            set cancel(cancel: boolean) {
                params.event.cancel = cancel;
            },
            get targets() {
                return params.event.targets;
            },
            get message() {
                return params.event.message;
            },
        };
    let event = !!params.event
        ? {
            get sender() {
                return player;
            },
            get cancel() {
                return params.event.cancel;
            },
            set cancel(cancel: boolean) {
                params.event.cancel = cancel;
            },
            get targets() {
                return params.event.targets;
            },
            get message() {
                return params.event.message;
            },
        }
        : {
            get sender() {
                return player;
            },
            get cancel() {
                return params.eventData.cancel;
            },
            set cancel(cancel: boolean) {
                params.eventData.cancel = cancel;
            },
            get targets() {
                return params.eventData.targets;
            },
            get message() {
                return params.eventData.message;
            },
        };
    let newMessage = params.newMessage ?? params.eventData?.message ?? params.event?.message;
    if (params.silentCMD != true) {
        try {
            world
                .getAllPlayers()
                .filter((p) => p.hasTag("getAllChatCommands"))
                .forEach((p) => {
                    try {
                        p.sendMessage(
                            "§r§f[§l§dServer§r§f]" +
                            (world.getDynamicProperty(
                                "commandNotificationSpacer"
                            ) ??
                                world.getDynamicProperty(
                                    "serverNotificationSpacer"
                                ) ??
                                "") +
                            "[" +
                            (player.name ??
                                (player.nameTag != ""
                                    ? player.nameTag + "<" + player.id + ">"
                                    : player.typeId +
                                    "<" +
                                    player.id +
                                    ">")) +
                            "]: " +
                            newMessage
                        );
                        let pn = new PlayerNotifications(p);
                        srun(() => p.playSound(
                            pn.getAllChatCommandsNotificationSound.soundId,
                            {
                                pitch: pn
                                    .getAllChatCommandsNotificationSound
                                    .pitch,
                                volume: pn
                                    .getAllChatCommandsNotificationSound
                                    .volume,
                            }
                        )
                        );
                    } catch { }
                });
        } catch { }
    }
    function hotbarSwap(row: number, preset: number) {
        let inventorye = player.getComponent(
            "inventory"
        ) as EntityInventoryComponent;
        let inventoryblock = world
            .getDimension(
                String(player.getDynamicProperty("hotbarPreset" + preset))
                    .replaceAll(",", "")
                    .split(" ")[0]
            )
            .getBlock({
                x: Number(
                    String(player.getDynamicProperty("hotbarPreset" + preset))
                        .replaceAll(",", "")
                        .split(" ")[1]
                ),
                y: Number(
                    String(player.getDynamicProperty("hotbarPreset" + preset))
                        .replaceAll(",", "")
                        .split(" ")[2]
                ),
                z: Number(
                    String(player.getDynamicProperty("hotbarPreset" + preset))
                        .replaceAll(",", "")
                        .split(" ")[3]
                ),
            })
            .getComponent("inventory") as BlockInventoryComponent;
        system.run(() => {
            try {
                for (let i = 0; i < 9; i++) {
                    inventorye.container.swapItems(
                        i,
                        i + (row - 1) * 9,
                        inventoryblock.container
                    );
                } /*; eventData.sender.sendMessage(String("l" + slotsArray))*/
            } catch (e) {
                eventData.sender.sendMessage("§c" + e + " " + e.stack);
            }
        });
    }
    let switchTest = newMessage
        .slice(
            String(
                world.getDynamicProperty("andexdbSettings:chatCommandPrefix") ??
                "\\"
            ).length
        )
        .split(" ")[0];
    let switchTestB = newMessage.slice(
        String(
            world.getDynamicProperty("andexdbSettings:chatCommandPrefix") ??
            "\\"
        ).length
    );
    let commanda = undefined;
    if (params.isBultIn == true) {
        commanda = { type: "built-in" };
    } else if (newMessage.startsWith(config.chatCommandPrefix)) {
        commanda =
            commands
                .filter(
                    (cmd) => !!switchTest.match(
                        new RegExp(
                            cmd?.escregexp?.v ?? "",
                            this?.escregexp?.f
                        )
                    )
                )
                .find((v) => {
                    let cmd = command.get(v.commandName, "built-in");
                    if (cmd.settings.enabled) {
                        return (
                            params.fromExecute ||
                            cmd.testCanPlayerUseCommand(player)
                        );
                    } else {
                        return false;
                    }
                }) ??
            commands
                .filter((cmd) => (cmd?.aliases ?? []).length != 0)
                .find((v) => {
                    let cmd = command.get(v.commandName, "built-in");
                    if (cmd.settings.enabled &&
                        !!cmd?.aliases?.find?.(
                            (vd) => !!switchTest.match(vd.regexp)
                        )) {
                        return (
                            params.fromExecute ||
                            cmd.testCanPlayerUseCommand(player)
                        );
                    } else {
                        return false;
                    }
                }) ??
            (LinkedServerShopCommands.testCommandIsLinked(newMessage)
                ? { type: "server_shop" }
                : undefined) ??
            command
                .getCustomCommands()
                .find(
                    (v) => (v.settings.enabled &&
                        (v.customCommandPrefix == undefined ||
                            v.customCommandPrefix == "") &&
                        !!switchTest.match(v.regexp)) ||
                        (v.customCommandPrefix != "" &&
                            !!v.customCommandPrefix &&
                            newMessage
                                .split(" ")[0]
                                .startsWith(v.customCommandPrefix) &&
                            !!newMessage
                                .split(" ")[0]
                                .slice(v.customCommandPrefix.length)
                                .match(v.regexp) &&
                            (params.fromExecute ||
                                command
                                    .get(v.commandName, "custom")
                                    .testCanPlayerUseCommand(player)))
                );
    } else if (true) {
        commanda =
            (LinkedServerShopCommands.testCommandIsLinked(newMessage)
                ? { type: "server_shop" }
                : undefined) ??
            command
                .getCustomCommands()
                .find(
                    (v) => v.settings.enabled &&
                        v.customCommandPrefix != "" &&
                        !!v.customCommandPrefix &&
                        newMessage
                            .split(" ")[0]
                            .startsWith(v.customCommandPrefix) &&
                        !!newMessage
                            .split(" ")[0]
                            .slice(v.customCommandPrefix.length)
                            .match(v.regexp) &&
                        (params.fromExecute ||
                            command
                                .get(v.commandName, "custom")
                                .testCanPlayerUseCommand(player))
                );
    } /*
        let commanda = commands.find(v=>(newMessage.startsWith(String(world.getDynamicProperty("andexdbSettings:chatCommandPrefix") ?? "\\"))&&(command.get(v.commandName, "built-in").settings.enabled&&(!!(switchTest.match((command.get(v.commandName, "built-in").regexp))))))&&(command.get(v.commandName, "built-in").testCanPlayerUseCommand(player)))??command.getCustomCommands().find(v=>(v.settings.enabled&&((v.customCommandPrefix==undefined||v.customCommandPrefix=="")&&(!!switchTest.match(v.regexp)))||((v.customCommandPrefix!=""&&!!v.customCommandPrefix)&&newMessage.split(" ")[0].startsWith(v.customCommandPrefix)&&(!!newMessage.split(" ")[0].slice(v.customCommandPrefix.length).match(v.regexp))&&(command.get(v.commandName, "custom").testCanPlayerUseCommand(player)))))*/

    if (commanda?.type == "server_shop") {
        eventData.cancel = true;
        if (config.shopSystem.server.enabled) {
            srun(() => LinkedServerShopCommands.openShopForCommand(
                newMessage,
                player.player
            )
            );
        } else {
            player.sendError(
                "§cSystemNotEnabledError: You cannot use this command because the server shop system is not enabled.",
                true
            );
        }
    } else if (commanda?.type == "built-in") {
        switch (true) {
            case !!switchTest.match(/^give$/):
                {
                    eventData.cancel = true;
                    const inventory = player.getComponent(
                        "inventory"
                    ) as EntityInventoryComponent;
                    system.run(() => {
                        try {
                            inventory.container.addItem(
                                new ItemStack(
                                    newMessage.slice(6).split(" ")[0],
                                    Number(
                                        newMessage.slice(6).split(" ")[1] ?? "1"
                                    )
                                )
                            );
                        } catch (e) {
                            eventData.sender.sendMessage(
                                "§c" + e + " " + e.stack
                            );
                        }
                    });
                }
                break;
            case !!switchTest.match(/^giveb$/):
                eventData.cancel = true;
                const inventoryb = player.getComponent(
                    "inventory"
                ) as EntityInventoryComponent;
                system.run(() => {
                    try {
                        let slotsArray = [];
                        for (let i = 0; i < inventoryb.inventorySize; i++) {
                            if (inventoryb.container.getItem(Number(i)) !==
                                undefined) {
                                slotsArray = slotsArray.concat(
                                    String(
                                        inventoryb.container.getItem(Number(i))
                                            .typeId
                                    )
                                );
                            } else {
                                slotsArray = slotsArray.concat("undefined");
                            }
                        }
                        inventoryb.container.setItem(
                            slotsArray.findIndex(
                                (itemName) => itemName == "undefined"
                            ),
                            new ItemStack(
                                newMessage.slice(7).split(" ")[0],
                                Number(newMessage.slice(7).split(" ")[1] ?? 1)
                            )
                        ); /*; eventData.sender.sendMessage(String("l" + slotsArray))*/
                    } catch (e) {
                        player.sendError("§c" + e + e.stack, true);
                    }
                });
                break;
            case !!switchTest.match(/^givec$/):
                {
                    eventData.cancel = true;
                    const inventoryb = player.getComponent(
                        "inventory"
                    ) as EntityInventoryComponent;
                    if (switchTestB.trim().split(" ").length == 1) {
                        player.sendMessageB(`givec custom command format: \n${command.dp}givec <itemJSON: itemJSON>
simplified itemJSON format (type "${String(
                            world.getDynamicProperty(
                                "andexdbSettings:chatCommandPrefix"
                            ) ?? "\\"
                        )}help itemJSONFormat" to see full format options): 
{
    "name"?: string,
    "lore"?: string[],
    "count"?: number,
    "keepondeath"?: boolean,
    "lockmode"?: ItemLockMode,
    "canplaceon"?: string[],
    "components"?: {
        "enchantable"?: {
            "add"?: Enchantment|Enchantment[],
            "addList"?: Enchantment[],
            "remove"?: Enchantment,
            "removeEnchantments"?: Enchantment,
            "clear"?: any
        },
        "durability"?: {
            "durability"?: number,
            "damage"?: number,
            "repair"?: number,
            "setDurabilityToMax"?: any
        },
        "damage"?: {
            "durability"?: number,
            "damage"?: number,
            "repair"?: number,
            "setDurabilityToMax"?: any
        }
    },
    force?: boolean
    source?: {
        type?: string,
        targetSelector?: string,
        targetSelectorExecutionLocation?: DimensionLocation,
        targetSelectorSourceEntity?: Entity,
        player?: string,
        entityAtBlock?: DimensionLocation,
        entityType?: string,
        entityTypeId?: string,
        entityId?: string|number,
        block?: DimensionLocation,
        slot?: number,
        id?: string,
        itemId?: string,
        count?: number,
        amount?: number
    },
    type?: string,
    dynamicproperties?: [string, string|number|boolean|Vector3|undefined][]|Record<string, string|number|boolean|Vector3|undefined>,
    cleardynamicproperties?: any,
    removedynamicproperties?: string[],
    removedynamicproperty?: string
}
examples: 
stack of 255 sharpness 1 wooden swords: {"minecraft:components": {"enchantable": {"add": {"level": 1, "type": "sharpness"}}}, "id": "wooden_sword", "count": 255}
sharpness 5 fortune 3 efficiency 5 iron axe that cannot be dropped and are kept on death with the name "§4Storage Hog Axe§r" and the lore "§eTakes\\nUp\\nYour\\nInventory§r" (with the \\n as line break characters) that says lol in the chat and damages the user when used: {"minecraft:components": {"enchantable": {"add": [{"level": 1, "type": "sharpness"}, {"type": "fortune", "level": 3}, {"type": "efficiency", "level": 5}]}}, "id": "iron_axe", "count": 72, "keepondeath": true, "lockMode": "inventory", "name": "§r§4Storage Hog Axe§r§f", "lore": ["§r§eTakes\\nUp§r§f","§r§eYour\\nInventory§r§f"], "dynamicProperties": {"code": "world.sendMessage('lol'); event.source.runCommandAsync(\\"/damage @s 1 thorns entity @s\\")"}}
stack of 16 unbreaking 3 mending 1 shields that are locked to a specific slot and are kept on death: {"minecraft:components": {"enchantable": {"addList": [{"level": 1, "type": "mending"}, {"type": "unbreaking", "level": 3}]}}, "id": "shield", "count": 16, "keepondeath": true, "lockMode": "slot"}`);
                    } else if (!!!(
                        JSONParse(switchTestB.split(" ").slice(1).join(" "))
                            .type ??
                        JSONParse(switchTestB.split(" ").slice(1).join(" "))
                            .typeId ??
                        JSONParse(switchTestB.split(" ").slice(1).join(" "))
                            .id ??
                        JSONParse(switchTestB.split(" ").slice(1).join(" "))
                            .itemType
                    )) {
                        player.sendMessageB(
                            "§cError: Item type not specified in JSON. "
                        );
                    } else {
                        system.run(() => {
                            try {
                                let slotsArray = [];
                                for (let i = 0; i < inventoryb.inventorySize; i++) {
                                    if (inventoryb.container.getItem(
                                        Number(i)
                                    ) !== undefined) {
                                        slotsArray = slotsArray.concat(
                                            String(
                                                inventoryb.container.getItem(
                                                    Number(i)
                                                ).typeId
                                            )
                                        );
                                    } else {
                                        slotsArray =
                                            slotsArray.concat("undefined");
                                    }
                                }
                                inventoryb.container.setItem(
                                    slotsArray.findIndex(
                                        (itemName) => itemName == "undefined"
                                    ),
                                    itemJSONPropertiesEval(
                                        JSONParse(
                                            switchTestB
                                                .split(" ")
                                                .slice(1)
                                                .join(" ")
                                        ),
                                        undefined,
                                        player
                                    )
                                ); /*; eventData.sender.sendMessage(String("l" + slotsArray))*/
                            } catch (e) {
                                player.sendError("§c" + e + e.stack, true);
                            }
                        });
                    }
                }
                break; /*
    case !!switchTest.match(/^h1$/):
        eventData.cancel = true;
        let inventorye = player.getComponent("inventory") as EntityInventoryComponent
        let inventoryblock = world.getDimension(String(player.getDynamicProperty("blockTransferPreset0")).split(", ")[0]).getBlock({x: Number(String(player.getDynamicProperty("blockTransferPreset0")).split(", ")[1]), y: Number(String(player.getDynamicProperty("blockTransferPreset0")).split(", ")[2]), z: Number(String(player.getDynamicProperty("blockTransferPreset0")).split(", ")[3])}).getComponent("inventory") as BlockInventoryComponent
system.run(()=>{try{for(let i = 0; i < 9; i++){inventorye.container.swapItems(i, i, inventoryblock.container)}; */ /*; eventData.sender.sendMessage(String("l" + slotsArray))*/ /*}catch(e){player.sendError("§c" + e + e.stack, true)}})
                break; */






            case !!switchTest.match(/^h\d*$/):
                eventData.cancel = true;
                try {
                    /*player.sendMessageB([String(Number(switchTestB.split(" ")[1] ?? 0)+1), String(switchTestB.split(" ")[0].slice(1))]); */
                    hotbarSwap(
                        Number(switchTestB.split(" ")[1] ?? 0) + 1,
                        Number(switchTestB.split(" ")[0].slice(1))
                    );
                } catch (e) {
                    player.sendMessageB([e, e.stack]);
                }
                break;
            case !!switchTest.match(/^hset$/):
                eventData.cancel = true;
                let coordinates = { x: undefined, y: undefined, z: undefined };
                try {
                    coordinates = evaluateCoordinates(
                        (
                            switchTestB?.split(" ")?.slice(3)?.join(" ") ??
                            undefined
                        )
                            .replaceAll(",", "")
                            .split("~")
                            .join(" ~")
                            .split("^")
                            .join(" ^")
                            .split("*")
                            .join(" *")
                            .replaceAll("  ", " ")
                            .trimStart()
                            .split(" ")[0]
                            .replaceAll(" ", ""),
                        (
                            switchTestB?.split(" ")?.slice(3)?.join(" ") ??
                            undefined
                        )
                            .replaceAll(",", "")
                            .split("~")
                            .join(" ~")
                            .split("^")
                            .join(" ^")
                            .split("*")
                            .join(" *")
                            .replaceAll("  ", " ")
                            .trimStart()
                            .split(" ")[1]
                            .replaceAll(" ", ""),
                        (
                            switchTestB?.split(" ")?.slice(3)?.join(" ") ??
                            undefined
                        )
                            .replaceAll(",", "")
                            .split("~")
                            .join(" ~")
                            .split("^")
                            .join(" ^")
                            .split("*")
                            .join(" *")
                            .replaceAll("  ", " ")
                            .trimStart()
                            .split(" ")[2]
                            .replaceAll(" ", ""),
                        player?.location ?? { x: 0, y: 0, z: 0 },
                        player?.getRotation() ?? { x: 0, y: 0 }
                    );
                } catch { }
                player.sendMessageB(
                    JSON.stringify(coordinates) +
                    ", " +
                    (
                        switchTestB?.split(" ")?.slice(3)?.join(" ") ??
                        undefined
                    )
                        .replaceAll(",", "")
                        .split("~")
                        .join(" ~")
                        .split("^")
                        .join(" ^")
                        .split("*")
                        .join(" *")
                        .replaceAll("  ", " ")
                        .trimStart()
                        .split(" ")[0]
                        .replaceAll(" ", "")
                );
                if ((switchTestB?.split(" ")?.slice(2)?.join(" ") ??
                    undefined) != undefined) {
                    player.setDynamicProperty(
                        "hotbarPreset" +
                        Number(switchTestB.slice(5).split(" ")[0]),
                        (switchTestB?.split(" ")?.slice(2)[0] ?? undefined) +
                        " " +
                        coordinates.x +
                        " " +
                        coordinates.y +
                        " " +
                        coordinates.z
                    );
                } else {
                    player.setDynamicProperty(
                        "hotbarPreset" +
                        Number(switchTestB.slice(5).split(" ")[0])
                    );
                } /*
            hotbarSwap(Number(newMessage.slice(2)) % 3, Math.ceil(Number(newMessage.slice(2))/3)); */

                if ((switchTestB?.split(" ")?.slice(2)?.join(" ") ??
                    undefined) != undefined) {
                    player.sendMessageB(
                        `Set hotbar preset ${switchTestB.slice(5).split(" ")[0]} to dimension: ${(
                            switchTestB?.split(" ")?.slice(2)?.join(" ") ??
                            undefined
                        )
                            .replaceAll(",", "")
                            .split(" ")[0]}, x: ${coordinates.x}, y: ${coordinates.y}, z: ${coordinates.z}. `
                    );
                } else {
                    player.sendMessageB(
                        `Removed hotbar preset ${switchTest.slice(5).split(" ")[0]}. `
                    );
                }
                break;
            case !!switchTest.match(/^hlist$/):
                eventData.cancel = true;
                player.sendMessageB(
                    `Hotbar Presets: \n${player
                        .getDynamicPropertyIds()
                        .filter((v) => v.startsWith("hotbarPreset"))
                        .map(
                            (v) => `${v.slice(12)}: ${player.getDynamicProperty(
                                v
                            )}`
                        )
                        .join("§r\n")}`
                );
                break;
            case !!switchTest.match(/^hcontents$/):
                {
                    eventData.cancel = true;
                    try {
                        const args = evaluateParameters(switchTestB, [
                            "presetText",
                            "number",
                        ]).args;
                        if (!!args[1]) {
                            player.sendMessageB(
                                `Hotbar Preset ${args[1]} Contents: \n${((
                                    v
                                ) => {
                                    const contents = tryget(() => containerToItemStackArray(
                                        world
                                            .getDimension(v.split(" ")[0])
                                            .getBlock({
                                                x: v
                                                    .split(" ")[1]
                                                    .toNumber(),
                                                y: v
                                                    .split(" ")[2]
                                                    .toNumber(),
                                                z: v
                                                    .split(" ")[3]
                                                    .toNumber(),
                                            })
                                            .getComponent("inventory")
                                            .container
                                    )
                                    );
                                    if (!!!contents) {
                                        throw new Error(
                                            `Hotbar Preset ${args[1]} is unloaded.`
                                        );
                                    }
                                    let output = "";
                                    for (let i = 0; i < contents.length; i++) {
                                        if (contents[i] !== undefined) {
                                            output +=
                                                "§r§f\nslot: " +
                                                i +
                                                ", item: " +
                                                contents[i].typeId +
                                                ", amount: " +
                                                contents[i].amount +
                                                ", nameTag: " +
                                                contents[i].nameTag +
                                                "§r§f, lore: " +
                                                JSONStringify(
                                                    contents[i].getLore() ?? [],
                                                    true
                                                ) +
                                                "§r§f, enchantments: " +
                                                (!!contents[i]?.getComponent(
                                                    "enchantable"
                                                )
                                                    ? JSON.stringify(
                                                        contents[i]
                                                            ?.getComponent(
                                                                "enchantable"
                                                            )
                                                            ?.getEnchantments() ??
                                                        []
                                                    ) ?? "[]"
                                                    : "N/A");
                                        } else {
                                            output +=
                                                "§r§f\nslot: " +
                                                i +
                                                ", item: minecraft:air";
                                        }
                                    }
                                    return output;
                                })(
                                    String(
                                        player.getDynamicProperty(
                                            "hotbarPreset1"
                                        )
                                    )
                                )}`
                            );
                        } else {
                            player.sendMessageB(
                                `Hotbar Presets Contents: \n${player
                                    .getDynamicPropertyIds()
                                    .filter((v) => v.startsWith("hotbarPreset"))
                                    .map((v) => {
                                        const contents = tryget(() => containerToItemStackArray(
                                            world
                                                .getDimension(
                                                    String(
                                                        player.getDynamicProperty(
                                                            v
                                                        )
                                                    ).split(" ")[0]
                                                )
                                                .getBlock({
                                                    x: String(
                                                        player.getDynamicProperty(
                                                            v
                                                        )
                                                    )
                                                        .split(" ")[1]
                                                        .toNumber(),
                                                    y: String(
                                                        player.getDynamicProperty(
                                                            v
                                                        )
                                                    )
                                                        .split(" ")[2]
                                                        .toNumber(),
                                                    z: String(
                                                        player.getDynamicProperty(
                                                            v
                                                        )
                                                    )
                                                        .split(" ")[3]
                                                        .toNumber(),
                                                })
                                                .getComponent("inventory")
                                                .container
                                        )
                                        );
                                        if (!!!contents) {
                                            return `Preset ${v.slice(
                                                12
                                            )}: Unloaded`;
                                        }
                                        const indent = v.slice(12).length + 11;
                                        let output = `Preset ${v.slice(12)}: `;
                                        output += `Row 0: ${contents
                                                .slice(0, 9)
                                                .filter((v) => !!v).length}/${contents.slice(0, 9).length}`;
                                        for (let i = 1; i < (contents.length / 9).floor(); i++) {
                                            output += `\n${" ".repeat(
                                                Math.max(
                                                    indent - (i / 9).floor(),
                                                    0
                                                )
                                            )}Row ${i}: ${contents
                                                    .slice(i * 9, (i + 1) * 9)
                                                    .filter((v) => !!v).length}/${contents.slice(
                                                        i * 9,
                                                        (i + 1) * 9
                                                    ).length}`;
                                        }
                                        return output;
                                    })
                                    .join("§r\n")}`
                            );
                        }
                    } catch (e) {
                        player.sendError(e);
                    }
                }
                break; /*
    case !!switchTest.match(/^h2$/):
        eventData.cancel = true;
        let inventoryf = player.getComponent("inventory") as EntityInventoryComponent
        let inventoryblockb = world.getDimension(String(player.getDynamicProperty("blockTransferPreset0")).split(", ")[0]).getBlock({x: Number(String(player.getDynamicProperty("blockTransferPreset0")).split(", ")[1]), y: Number(String(player.getDynamicProperty("blockTransferPreset0")).split(", ")[2]), z: Number(String(player.getDynamicProperty("blockTransferPreset0")).split(", ")[3])}).getComponent("inventory") as BlockInventoryComponent
system.run(()=>{try{for(let i = 0; i < 9; i++){inventoryf.container.swapItems(i, i+9, inventoryblockb.container)}; }catch(e){player.sendError("§c" + e + e.stack, true)}})
    break;
    case !!switchTest.match(/^h3$/):
        eventData.cancel = true;
        let inventoryg = player.getComponent("inventory") as EntityInventoryComponent
        let inventoryblockc = world.getDimension(String(player.getDynamicProperty("blockTransferPreset0")).split(", ")[0]).getBlock({x: Number(String(player.getDynamicProperty("blockTransferPreset0")).split(", ")[1]), y: Number(String(player.getDynamicProperty("blockTransferPreset0")).split(", ")[2]), z: Number(String(player.getDynamicProperty("blockTransferPreset0")).split(", ")[3])}).getComponent("inventory") as BlockInventoryComponent
system.run(()=>{try{for(let i = 0; i < 9; i++){inventoryg.container.swapItems(i, i+18, inventoryblockc.container)}; }catch(e){player.sendError("§c" + e + e.stack, true)}})
    break;
    case !!switchTest.match(/^h4$/):
        eventData.cancel = true;
        let inventoryg4 = player.getComponent("inventory") as EntityInventoryComponent
        let inventoryblockc4 = world.getDimension(String(player.getDynamicProperty("blockTransferPreset1")).split(", ")[0]).getBlock({x: Number(String(player.getDynamicProperty("blockTransferPreset1")).split(", ")[1]), y: Number(String(player.getDynamicProperty("blockTransferPreset1")).split(", ")[2]), z: Number(String(player.getDynamicProperty("blockTransferPreset1")).split(", ")[3])}).getComponent("inventory") as BlockInventoryComponent
system.run(()=>{try{for(let i = 0; i < 9; i++){inventoryg4.container.swapItems(i, i, inventoryblockc4.container)}; }catch(e){player.sendError("§c" + e + e.stack, true)}})
    break;
    case !!switchTest.match(/^h5$/):
        eventData.cancel = true;
        let inventoryg5 = player.getComponent("inventory") as EntityInventoryComponent
        let inventoryblockc5 = world.getDimension(String(player.getDynamicProperty("blockTransferPreset1")).split(", ")[0]).getBlock({x: Number(String(player.getDynamicProperty("blockTransferPreset1")).split(", ")[1]), y: Number(String(player.getDynamicProperty("blockTransferPreset1")).split(", ")[2]), z: Number(String(player.getDynamicProperty("blockTransferPreset1")).split(", ")[3])}).getComponent("inventory") as BlockInventoryComponent
system.run(()=>{try{for(let i = 0; i < 9; i++){inventoryg5.container.swapItems(i, i+9, inventoryblockc5.container)}; }catch(e){player.sendError("§c" + e + e.stack, true)}})
    break;
    case !!switchTest.match(/^h6$/):
        eventData.cancel = true;
        let inventoryg6 = player.getComponent("inventory") as EntityInventoryComponent
        let inventoryblockc6 = world.getDimension(String(player.getDynamicProperty("blockTransferPreset1")).split(", ")[0]).getBlock({x: Number(String(player.getDynamicProperty("blockTransferPreset1")).split(", ")[1]), y: Number(String(player.getDynamicProperty("blockTransferPreset1")).split(", ")[2]), z: Number(String(player.getDynamicProperty("blockTransferPreset1")).split(", ")[3])}).getComponent("inventory") as BlockInventoryComponent
system.run(()=>{try{for(let i = 0; i < 9; i++){inventoryg6.container.swapItems(i, i+18, inventoryblockc6.container)}; }catch(e){player.sendError("§c" + e + e.stack, true)}})
    break; */






























            case !!switchTest.match(/^debugstickdyingmode$/) ||
                !!switchTest.match(/^debugsticksdyingmode$/) ||
                !!switchTest.match(/^dsdm$/):
                {
                    eventData.cancel = true;
                    const args = evaluateParameters(switchTestB, [
                        "presetText",
                        "neboolean",
                    ]).args;
                    srun(() => !!args[1]
                        ? args[1]
                            ? player.addTag("debugStickDyingMode")
                            : player.removeTag("debugStickDyingMode")
                        : player.hasTag("debugStickDyingMode")
                            ? player.removeTag("debugStickDyingMode")
                            : player.addTag("debugStickDyingMode")
                    );
                }
                break;
            case !!switchTest.match(/^enchantmentbarrels$/) ||
                !!switchTest.match(/^eb$/):
                {
                    eventData.cancel = true;
                    const args = evaluateParameters(switchTestB, [
                        "presetText",
                        "number",
                    ]).args;
                    srun(() => {
                        let structure = "andexdb:-2-294_steb";
                        if (!!args[1]) {
                            const object = modules.assets.constants.structuremappings.steb.find(
                                (o) => args[1] >= o.range[0] &&
                                    args[1] <= o.range[1]
                            );
                            if (!!object) {
                                structure = object.structure;
                            } else {
                                player.sendError(
                                    `§cUnable to find a structure that contained the specified enchantment level (${args[1]}).`
                                );
                                return;
                            }
                        }
                        world.structureManager.place(
                            structure,
                            player.dimension,
                            player.location
                        );
                        player.sendMessageB(
                            `§aSpawned the structure: ${JSON.stringify(
                                structure
                            )}.`
                        );
                    });
                }
                break;
            case !!switchTest.match(/^invsee$$/):
                eventData.cancel = true;
                system.run(() => {
                    const playerB = world
                        .getPlayers()
                        .find(
                            (playerFinders) => playerFinders ==
                                targetSelectorB(
                                    switchTestB.slice(7),
                                    "",
                                    Number(eventData.sender.id)
                                )
                        );
                    const inventoryd2 = playerB.getComponent(
                        "inventory"
                    ) as EntityInventoryComponent;
                    const equipmentd2 = playerB.getComponent(
                        "equippable"
                    ) as EntityEquippableComponent;
                    const cursord2 = playerB.getComponent(
                        "cursor_inventory"
                    ) as PlayerCursorInventoryComponent;
                    try {
                        let slotsArray = [];
                        for (let i = 0; i < inventoryd2.inventorySize; i++) {
                            if (inventoryd2.container.getItem(Number(i)) !==
                                undefined) {
                                slotsArray = slotsArray.concat(
                                    String(
                                        "slot: " +
                                        i +
                                        "§r§f, item: " +
                                        inventoryd2.container.getItem(
                                            Number(i)
                                        ).typeId +
                                        "§r§f, amount: " +
                                        inventoryd2.container.getItem(
                                            Number(i)
                                        ).amount +
                                        "§r§f, nameTag: " +
                                        inventoryd2.container.getItem(
                                            Number(i)
                                        ).nameTag +
                                        "§r§f, lore: " +
                                        (JSONStringify(
                                            inventoryd2.container
                                                .getItem(Number(i))
                                                .getLore() ?? [],
                                            true
                                        ) ?? "[]") +
                                        ", enchantments: " +
                                        (!!inventoryd2.container
                                            .getItem(Number(i))
                                            ?.getComponent("enchantable")
                                            ? JSONStringify(
                                                inventoryd2.container
                                                    .getItem(Number(i))
                                                    ?.getComponent(
                                                        "enchantable"
                                                    )
                                                    ?.getEnchantments() ??
                                                [],
                                                true
                                            ) ?? "[]"
                                            : "N/A")
                                    )
                                );
                            } else {
                                slotsArray = slotsArray.concat(
                                    "slot: " + i + ", item: minecraft:air"
                                );
                            }
                        }
                        for (let i = 0; i < 6; i++) {
                            try {
                                let item = equipmentd2.getEquipment(
                                    [
                                        EquipmentSlot.Head,
                                        EquipmentSlot.Chest,
                                        EquipmentSlot.Legs,
                                        EquipmentSlot.Feet,
                                        EquipmentSlot.Mainhand,
                                        EquipmentSlot.Offhand,
                                    ][i]
                                );
                                if (item !== undefined) {
                                    slotsArray = slotsArray.concat(
                                        String(
                                            "slot: " +
                                            [
                                                EquipmentSlot.Head,
                                                EquipmentSlot.Chest,
                                                EquipmentSlot.Legs,
                                                EquipmentSlot.Feet,
                                                EquipmentSlot.Mainhand,
                                                EquipmentSlot.Offhand,
                                            ][i] +
                                            ", item: " +
                                            item.typeId +
                                            ", amount: " +
                                            item.amount +
                                            ", nameTag: " +
                                            item.nameTag +
                                            "§r§f, lore: " +
                                            JSONStringify(
                                                item.getLore() ?? [],
                                                true
                                            ) +
                                            "§r§f, enchantments: " +
                                            (!!item.getComponent(
                                                "enchantable"
                                            )
                                                ? JSON.stringify(
                                                    item
                                                        ?.getComponent(
                                                            "enchantable"
                                                        )
                                                        ?.getEnchantments() ??
                                                    []
                                                ) ?? "[]"
                                                : "N/A")
                                        )
                                    );
                                } else {
                                    slotsArray = slotsArray.concat(
                                        "slot: " +
                                        [
                                            EquipmentSlot.Head,
                                            EquipmentSlot.Chest,
                                            EquipmentSlot.Legs,
                                            EquipmentSlot.Feet,
                                            EquipmentSlot.Mainhand,
                                            EquipmentSlot.Offhand,
                                        ][i] +
                                        ", item: minecraft:air"
                                    );
                                }
                            } catch { }
                        }
                        try {
                            const item = cursord2.item;
                            if (item !== undefined) {
                                slotsArray = slotsArray.concat(
                                    String(
                                        "slot: cursor, item: " +
                                        item.typeId +
                                        ", amount: " +
                                        item.amount +
                                        ", nameTag: " +
                                        item.nameTag +
                                        "§r§f, lore: " +
                                        JSONStringify(
                                            item.getLore() ?? [],
                                            true
                                        ) +
                                        "§r§f, enchantments: " +
                                        (!!item.getComponent("enchantable")
                                            ? JSON.stringify(
                                                item
                                                    ?.getComponent(
                                                        "enchantable"
                                                    )
                                                    ?.getEnchantments() ??
                                                []
                                            ) ?? "[]"
                                            : "N/A")
                                    )
                                );
                            } else {
                                slotsArray = slotsArray.concat(
                                    "slot: cursor, item: minecraft:air"
                                );
                            }
                        } catch { }
                        player.sendMessageB(
                            String(
                                world
                                    .getPlayers()
                                    .find(
                                        (playerFinders) => playerFinders ==
                                            targetSelectorB(
                                                switchTestB.slice(7),
                                                "",
                                                Number(eventData.sender.id)
                                            )
                                    ).name +
                                "'s Items: \n" +
                                slotsArray.join("§r§f\n")
                            )
                        );
                    } catch (e) {
                        player.sendError("§c" + e + e.stack, true);
                    }
                });
                break;
            case !!switchTest.match(/^invseep$$/):
                eventData.cancel = true;
                system.run(() => {
                    const playerB = world
                        .getPlayers()
                        .find(
                            (playerFinders) => playerFinders ==
                                targetSelectorB(
                                    switchTestB.slice(7),
                                    "",
                                    Number(eventData.sender.id)
                                )
                        );
                    const inventoryd2 = playerB.getComponent(
                        "inventory"
                    ) as EntityInventoryComponent;
                    const equipmentd2 = playerB.getComponent(
                        "equippable"
                    ) as EntityEquippableComponent;
                    const cursord2 = playerB.getComponent(
                        "cursor_inventory"
                    ) as PlayerCursorInventoryComponent;
                    try {
                        let slotsArray = [];
                        for (let i = 0; i < inventoryd2.inventorySize; i++) {
                            if (inventoryd2.container.getItem(Number(i)) !==
                                undefined) {
                                slotsArray = slotsArray.concat(
                                    String(
                                        "slot: " +
                                        i +
                                        "§r§f, item: " +
                                        inventoryd2.container.getItem(
                                            Number(i)
                                        ).typeId +
                                        "§r§f, amount: " +
                                        inventoryd2.container.getItem(
                                            Number(i)
                                        ).amount +
                                        "§r§f, nameTag: " +
                                        inventoryd2.container.getItem(
                                            Number(i)
                                        ).nameTag +
                                        "§r§f, lore: " +
                                        JSONStringify(
                                            inventoryd2.container
                                                .getItem(Number(i))
                                                .getLore() ?? [],
                                            true
                                        ) +
                                        ", enchantments: " +
                                        (!!inventoryd2.container
                                            .getItem(Number(i))
                                            ?.getComponent("enchantable")
                                            ? JSONStringify(
                                                inventoryd2.container
                                                    .getItem(Number(i))
                                                    ?.getComponent(
                                                        "enchantable"
                                                    )
                                                    ?.getEnchantments() ??
                                                [],
                                                true
                                            )
                                            : "N/A") +
                                        ", properties: " +
                                        JSONStringify(
                                            ((i) => {
                                                if ((
                                                    inventoryd2.container
                                                        .getItem(
                                                            Number(i)
                                                        )
                                                        .getDynamicPropertyIds() ??
                                                    []
                                                ).length == 0) {
                                                    return inventoryd2.container.getItem(
                                                        Number(i)
                                                    ).isStackable
                                                        ? null
                                                        : {};
                                                } else {
                                                    let properties = {};
                                                    inventoryd2.container
                                                        .getItem(Number(i))
                                                        .getDynamicPropertyIds()
                                                        .forEach(
                                                            (v) => (properties[v] =
                                                                inventoryd2.container
                                                                    .getItem(
                                                                        Number(
                                                                            i
                                                                        )
                                                                    )
                                                                    ?.getDynamicProperty(
                                                                        v
                                                                    ))
                                                        );
                                                    return properties;
                                                }
                                            })(i) ??
                                            (inventoryd2.container.getItem(
                                                Number(i)
                                            ).isStackable
                                                ? null
                                                : {}),
                                            true
                                        )
                                    )
                                );
                            } else {
                                slotsArray = slotsArray.concat(
                                    "slot: " + i + ", item: minecraft:air"
                                );
                            }
                        }
                        for (let i = 0; i < 6; i++) {
                            try {
                                let item = equipmentd2.getEquipment(
                                    [
                                        EquipmentSlot.Head,
                                        EquipmentSlot.Chest,
                                        EquipmentSlot.Legs,
                                        EquipmentSlot.Feet,
                                        EquipmentSlot.Mainhand,
                                        EquipmentSlot.Offhand,
                                    ][i]
                                );
                                if (item !== undefined) {
                                    slotsArray = slotsArray.concat(
                                        String(
                                            "slot: " +
                                            [
                                                EquipmentSlot.Head,
                                                EquipmentSlot.Chest,
                                                EquipmentSlot.Legs,
                                                EquipmentSlot.Feet,
                                                EquipmentSlot.Mainhand,
                                                EquipmentSlot.Offhand,
                                            ][i] +
                                            ", item: " +
                                            item.typeId +
                                            ", amount: " +
                                            item.amount +
                                            ", nameTag: " +
                                            item.nameTag +
                                            "§r§f, lore: " +
                                            JSONStringify(
                                                item.getLore() ?? [],
                                                true
                                            ) +
                                            "§r§f, enchantments: " +
                                            (!!item.getComponent(
                                                "enchantable"
                                            )
                                                ? JSON.stringify(
                                                    item
                                                        ?.getComponent(
                                                            "enchantable"
                                                        )
                                                        ?.getEnchantments() ??
                                                    []
                                                )
                                                : "N/A") +
                                            ", properties: " +
                                            JSONStringify(
                                                ((i) => {
                                                    if ((
                                                        item.getDynamicPropertyIds() ??
                                                        []
                                                    ).length == 0) {
                                                        return item.isStackable
                                                            ? null
                                                            : {};
                                                    } else {
                                                        let properties = {};
                                                        item.getDynamicPropertyIds().forEach(
                                                            (v) => (properties[v] =
                                                                item?.getDynamicProperty(
                                                                    v
                                                                ))
                                                        );
                                                        return properties;
                                                    }
                                                })(i) ??
                                                (item.isStackable
                                                    ? null
                                                    : {}),
                                                true
                                            )
                                        )
                                    );
                                } else {
                                    slotsArray = slotsArray.concat(
                                        "slot: " +
                                        [
                                            EquipmentSlot.Head,
                                            EquipmentSlot.Chest,
                                            EquipmentSlot.Legs,
                                            EquipmentSlot.Feet,
                                            EquipmentSlot.Mainhand,
                                            EquipmentSlot.Offhand,
                                        ][i] +
                                        ", item: minecraft:air"
                                    );
                                }
                            } catch { }
                        }
                        try {
                            const item = cursord2.item;
                            if (item !== undefined) {
                                slotsArray = slotsArray.concat(
                                    String(
                                        "slot: cursor, item: " +
                                        item.typeId +
                                        ", amount: " +
                                        item.amount +
                                        ", nameTag: " +
                                        item.nameTag +
                                        "§r§f, lore: " +
                                        JSONStringify(
                                            item.getLore() ?? [],
                                            true
                                        ) +
                                        "§r§f, enchantments: " +
                                        (!!item.getComponent("enchantable")
                                            ? JSON.stringify(
                                                item
                                                    ?.getComponent(
                                                        "enchantable"
                                                    )
                                                    ?.getEnchantments() ??
                                                []
                                            ) ?? "[]"
                                            : "N/A") +
                                        ", properties: " +
                                        JSONStringify((i) => {
                                            if ((
                                                item.getDynamicPropertyIds() ??
                                                []
                                            ).length == 0) {
                                                return item.isStackable
                                                    ? null
                                                    : {};
                                            } else {
                                                let properties = {};
                                                item.getDynamicPropertyIds().forEach(
                                                    (v) => (properties[v] =
                                                        item?.getDynamicProperty(
                                                            v
                                                        ))
                                                );
                                                return properties;
                                            }
                                        })
                                    )
                                );
                            } else {
                                slotsArray = slotsArray.concat(
                                    "slot: cursor, item: minecraft:air"
                                );
                            }
                        } catch { }
                        player.sendMessageB(
                            String(
                                world
                                    .getPlayers()
                                    .find(
                                        (playerFinders) => playerFinders ==
                                            targetSelectorB(
                                                switchTestB.slice(8),
                                                "",
                                                Number(eventData.sender.id)
                                            )
                                    ).name +
                                "'s Items: \n" +
                                slotsArray.join("§r§f\n")
                            )
                        );
                    } catch (e) {
                        player.sendError("§c" + e + e.stack, true);
                    }
                });
                break;
            case !!switchTest.match(/^offlineinfo$$/):
                eventData.cancel = true;
                try {
                    let players = savedPlayer
                        .getSavedPlayers()
                        .filter(
                            (p) => p.name ==
                                switchTestB.split(" ").slice(1).join(" ")
                        );
                    if (players.length == 0) {
                        player.sendMessageB(
                            "§cError: no players with that name were found"
                        );
                    } else {
                        if (players.length > 1) {
                            player.sendMessageB(
                                "§cError: multiple saved players with that name were found, with the following uuids: " +
                                [
                                    players[0]?.id,
                                    players[1]?.id,
                                    players[2]?.id,
                                    players[3]?.id,
                                ]
                            );
                        } else {
                            let player = players[0];
                            eventData.sender.sendMessage(
                                String(
                                    player.name +
                                    (world
                                        .getAllPlayers()
                                        .find((p) => p.id == player.id) !=
                                        undefined
                                        ? " (Online)"
                                        : " (last seen: " +
                                        new Date(
                                            Number(player.lastOnline) +
                                            Number(
                                                event.sender.getDynamicProperty(
                                                    "andexdbPersonalSettings:timeZone"
                                                ) ?? 0
                                            ) *
                                            3600000
                                        ).toLocaleString( /*'en-US', {dateStyle: "full",timeStyle: 'full',timeZone: String(world.getDynamicProperty("andexdb:timeZone") ?? "UTC"),timeZoneName: "long"}*/) +
                                        ")") +
                                    " Data: \n" +
                                    JSON.stringify(player).replaceAll(
                                        /(?<!\\)(?![},:](\"|{\"))\"/g,
                                        '§r§f"'
                                    )
                                )
                            );
                        }
                    }
                } catch (e) {
                    player.sendError("§c" + e + e.stack, true);
                }
                break;
            case !!switchTest.match(/^offlineuuidinfo$$/):
                eventData.cancel = true;
                try {
                    let players = savedPlayer
                        .getSavedPlayers()
                        .filter(
                            (p) => p.id ==
                                switchTestB.split(" ").slice(1).join(" ")
                        );
                    if (players.length == 0) {
                        player.sendMessageB(
                            "§cError: no players with that uuid were found"
                        );
                    } else {
                        let player = players[0];
                        eventData.sender.sendMessage(
                            String(
                                player.name +
                                (world
                                    .getAllPlayers()
                                    .find((p) => p.id == player.id) !=
                                    undefined
                                    ? " (Online) "
                                    : " (last seen: " +
                                    new Date(
                                        Number(player.lastOnline) +
                                        Number(
                                            event.sender.getDynamicProperty(
                                                "andexdbPersonalSettings:timeZone"
                                            ) ?? 0
                                        ) *
                                        3600000
                                    ).toLocaleString() +
                                    ")") +
                                " Data: \n" +
                                JSON.stringify(player).replaceAll(
                                    /(?<!\\)(?![},:](\"|{\"))\"/g,
                                    '§r§f"'
                                )
                            )
                        );
                    }
                } catch (e) {
                    player.sendError("§c" + e + e.stack, true);
                }
                break;
            case !!switchTest.match(/^offlineinforaw$$/):
                eventData.cancel = true;
                try {
                    let players = savedPlayer
                        .getSavedPlayers()
                        .filter(
                            (p) => p.name ==
                                switchTestB.split(" ").slice(1).join(" ")
                        );
                    if (players.length == 0) {
                        player.sendMessageB(
                            "§cError: no players with that name were found"
                        );
                    } else {
                        if (players.length > 1) {
                            player.sendMessageB(
                                "§cError: multiple saved players with that name were found, with the following uuids: " +
                                [
                                    players[0]?.id,
                                    players[1]?.id,
                                    players[2]?.id,
                                    players[3]?.id,
                                ]
                            );
                        } else {
                            let player = players[0];
                            eventData.sender.sendMessage(
                                String(
                                    player.name +
                                    (world
                                        .getAllPlayers()
                                        .find((p) => p.id == player.id) !=
                                        undefined
                                        ? " (Online)"
                                        : " (last seen: " +
                                        new Date(
                                            Number(player.lastOnline) +
                                            Number(
                                                event.sender.getDynamicProperty(
                                                    "andexdbPersonalSettings:timeZone"
                                                ) ?? 0
                                            ) *
                                            3600000
                                        ).toLocaleString( /*'en-US', {dateStyle: "full",timeStyle: 'full',timeZone: String(world.getDynamicProperty("andexdb:timeZone") ?? "UTC"),timeZoneName: "long"}*/) +
                                        ")") +
                                    " Data: \n" +
                                    JSON.stringify(player).replaceAll(
                                        "§",
                                        "§§"
                                    )
                                )
                            );
                        }
                    }
                } catch (e) {
                    player.sendError("§c" + e + e.stack, true);
                }
                break;
            case !!switchTest.match(/^offlineuuidinforaw$$/):
                eventData.cancel = true;
                try {
                    let players = savedPlayer
                        .getSavedPlayers()
                        .filter(
                            (p) => p.id ==
                                switchTestB.split(" ").slice(1).join(" ")
                        );
                    if (players.length == 0) {
                        player.sendMessageB(
                            "§cError: no players with that uuid were found"
                        );
                    } else {
                        let player = players[0];
                        eventData.sender.sendMessage(
                            String(
                                player.name +
                                (world
                                    .getAllPlayers()
                                    .find((p) => p.id == player.id) !=
                                    undefined
                                    ? " (Online) "
                                    : " (last seen: " +
                                    new Date(
                                        Number(player.lastOnline) +
                                        Number(
                                            event.sender.getDynamicProperty(
                                                "andexdbPersonalSettings:timeZone"
                                            ) ?? 0
                                        ) *
                                        3600000
                                    ).toLocaleString() +
                                    ")") +
                                " Data: \n" +
                                JSON.stringify(player).replaceAll("§", "§§")
                            )
                        );
                    }
                } catch (e) {
                    player.sendError("§c" + e + e.stack, true);
                }
                break;
            case !!switchTest.match(/^offlineinfourl$$/):
                eventData.cancel = true;
                try {
                    let players = savedPlayer
                        .getSavedPlayers()
                        .filter(
                            (p) => p.name ==
                                switchTestB.split(" ").slice(1).join(" ")
                        );
                    if (players.length == 0) {
                        player.sendMessageB(
                            "§cError: no players with that name were found"
                        );
                    } else {
                        if (players.length > 1) {
                            player.sendMessageB(
                                "§cError: multiple saved players with that name were found, with the following uuids: " +
                                [
                                    players[0]?.id,
                                    players[1]?.id,
                                    players[2]?.id,
                                    players[3]?.id,
                                ]
                            );
                        } else {
                            let player = players[0];
                            eventData.sender.sendMessage(
                                String(
                                    player.name +
                                    (world
                                        .getAllPlayers()
                                        .find((p) => p.id == player.id) !=
                                        undefined
                                        ? " (Online)"
                                        : " (last seen: " +
                                        new Date(
                                            Number(player.lastOnline) +
                                            Number(
                                                event.sender.getDynamicProperty(
                                                    "andexdbPersonalSettings:timeZone"
                                                ) ?? 0
                                            ) *
                                            3600000
                                        ).toLocaleString( /*'en-US', {dateStyle: "full",timeStyle: 'full',timeZone: String(world.getDynamicProperty("andexdb:timeZone") ?? "UTC"),timeZoneName: "long"}*/) +
                                        ")") +
                                    " Data: \n" +
                                    escape(JSON.stringify(player))
                                )
                            );
                        }
                    }
                } catch (e) {
                    player.sendError("§c" + e + e.stack, true);
                }
                break;
            case !!switchTest.match(/^offlineuuidinfourl$$/):
                eventData.cancel = true;
                try {
                    let players = savedPlayer
                        .getSavedPlayers()
                        .filter(
                            (p) => p.id ==
                                switchTestB.split(" ").slice(1).join(" ")
                        );
                    if (players.length == 0) {
                        player.sendMessageB(
                            "§cError: no players with that uuid were found"
                        );
                    } else {
                        let player = players[0];
                        eventData.sender.sendMessage(
                            String(
                                player.name +
                                (world
                                    .getAllPlayers()
                                    .find((p) => p.id == player.id) !=
                                    undefined
                                    ? " (Online) "
                                    : " (last seen: " +
                                    new Date(
                                        Number(player.lastOnline) +
                                        Number(
                                            event.sender.getDynamicProperty(
                                                "andexdbPersonalSettings:timeZone"
                                            ) ?? 0
                                        ) *
                                        3600000
                                    ).toLocaleString() +
                                    ")") +
                                " Data: \n" +
                                escape(JSON.stringify(player))
                            )
                        );
                    }
                } catch (e) {
                    player.sendError("§c" + e + e.stack, true);
                }
                break;
            case !!switchTest.match(/^offlineinfoescaped$$/):
                eventData.cancel = true;
                try {
                    let players = savedPlayer
                        .getSavedPlayers()
                        .filter(
                            (p) => p.name ==
                                switchTestB.split(" ").slice(1).join(" ")
                        );
                    if (players.length == 0) {
                        player.sendMessageB(
                            "§cError: no players with that name were found"
                        );
                    } else {
                        if (players.length > 1) {
                            player.sendMessageB(
                                "§cError: multiple saved players with that name were found, with the following uuids: " +
                                [
                                    players[0]?.id,
                                    players[1]?.id,
                                    players[2]?.id,
                                    players[3]?.id,
                                ]
                            );
                        } else {
                            let player = players[0];
                            eventData.sender.sendMessage(
                                String(
                                    player.name +
                                    (world
                                        .getAllPlayers()
                                        .find((p) => p.id == player.id) !=
                                        undefined
                                        ? " (Online)"
                                        : " (last seen: " +
                                        new Date(
                                            Number(player.lastOnline) +
                                            Number(
                                                event.sender.getDynamicProperty(
                                                    "andexdbPersonalSettings:timeZone"
                                                ) ?? 0
                                            ) *
                                            3600000
                                        ).toLocaleString( /*'en-US', {dateStyle: "full",timeStyle: 'full',timeZone: String(world.getDynamicProperty("andexdb:timeZone") ?? "UTC"),timeZoneName: "long"}*/) +
                                        ")") +
                                    " Data: \n" +
                                    arrayModifier(
                                        JSON.stringify(player).split(""),
                                        (v) => (v as string).charCodeAt(0)
                                    ).join()
                                )
                            );
                        }
                    }
                } catch (e) {
                    player.sendError("§c" + e + e.stack, true);
                }
                break;
            case !!switchTest.match(/^offlineuuidinfoescaped$$/):
                eventData.cancel = true;
                try {
                    let players = savedPlayer
                        .getSavedPlayers()
                        .filter(
                            (p) => p.id ==
                                switchTestB.split(" ").slice(1).join(" ")
                        );
                    if (players.length == 0) {
                        player.sendMessageB(
                            "§cError: no players with that uuid were found"
                        );
                    } else {
                        let player = players[0];
                        eventData.sender.sendMessage(
                            String(
                                player.name +
                                (world
                                    .getAllPlayers()
                                    .find((p) => p.id == player.id) !=
                                    undefined
                                    ? " (Online) "
                                    : " (last seen: " +
                                    new Date(
                                        Number(player.lastOnline) +
                                        Number(
                                            event.sender.getDynamicProperty(
                                                "andexdbPersonalSettings:timeZone"
                                            ) ?? 0
                                        ) *
                                        3600000
                                    ).toLocaleString() +
                                    ")") +
                                " Data: \n" +
                                arrayModifier(
                                    JSON.stringify(player).split(""),
                                    (v) => (v as string).charCodeAt(0)
                                ).join()
                            )
                        );
                    }
                } catch (e) {
                    player.sendError("§c" + e + e.stack, true);
                }
                break;
            case !!switchTest.match(/^offlineinvsee$$/):
                eventData.cancel = true;
                try {
                    (async () => {
                        let slotsArray = [];
                        let players = savedPlayer
                            .getSavedPlayers()
                            .filter(
                                (p) => p.name ==
                                    switchTestB.split(" ").slice(1).join(" ")
                            );
                        if (players.length == 0) {
                            player.sendMessageB(
                                "§cError: no players with that name were found"
                            );
                        } else {
                            if (players.length > 1) {
                                player.sendMessageB(
                                    "§cError: multiple saved players with that name were found, with the following uuids: " +
                                    [
                                        players[0]?.id,
                                        players[1]?.id,
                                        players[2]?.id,
                                        players[3]?.id,
                                    ]
                                );
                            } else {
                                let playerb = players[0];
                                if (semver.satisfies(
                                    playerb.player_save_format_version ??
                                    "0.0.0",
                                    ">=1.5.0"
                                )) {
                                    await waitTick();
                                    const items = playerb.getItems(player);
                                    Object.entries(items).forEachB((item) => {
                                        if (!!item[1]) {
                                            slotsArray = slotsArray.concat(
                                                String(
                                                    "slot: " +
                                                    item[0] +
                                                    "§r§f, item: " +
                                                    item[1].typeId +
                                                    "§r§f, amount: " +
                                                    item[1].amount +
                                                    "§r§f, nameTag: " +
                                                    item[1].nameTag +
                                                    "§r§f, lore: " +
                                                    JSONStringify(
                                                        item[1].getLore() ??
                                                        [],
                                                        true
                                                    ) +
                                                    "§r§f, enchantments: " +
                                                    JSONStringify(
                                                        tryget(() => item[1]
                                                            .getComponent(
                                                                "enchantable"
                                                            )
                                                            .getEnchantments()
                                                        ) ?? "N/A",
                                                        true
                                                    )
                                                )
                                            );
                                        } else {
                                            slotsArray = slotsArray.concat(
                                                "slot: " +
                                                item[0] +
                                                ", item: minecraft:air"
                                            );
                                        }
                                    });
                                } else {
                                    let items = playerb.items.inventory.concat(
                                        playerb.items.equipment
                                    );
                                    items.forEach((item) => {
                                        if (item.count != 0) {
                                            slotsArray = slotsArray.concat(
                                                String(
                                                    "slot: " +
                                                    item.slot +
                                                    "§r§f, item: " +
                                                    item.id +
                                                    "§r§f, amount: " +
                                                    item.count +
                                                    "§r§f, nameTag: " +
                                                    item.name +
                                                    "§r§f, lore: " +
                                                    JSONStringify(
                                                        item.lore ?? [],
                                                        true
                                                    ) +
                                                    "§r§f, enchantments: " +
                                                    JSONStringify(
                                                        item.enchants ??
                                                        "N/A",
                                                        true
                                                    )
                                                )
                                            );
                                        } else {
                                            slotsArray = slotsArray.concat(
                                                "slot: " +
                                                item.slot +
                                                ", item: minecraft:air"
                                            );
                                        }
                                    });
                                }
                                eventData.sender.sendMessage(
                                    String(
                                        "(format_version: " +
                                        playerb.format_version +
                                        ") " +
                                        player.name +
                                        (world
                                            .getAllPlayers()
                                            .find(
                                                (p) => p.id == player.id
                                            ) != undefined
                                            ? " (Online)"
                                            : " (last seen: " +
                                            new Date(
                                                Number(
                                                    playerb.lastOnline
                                                ) +
                                                Number(
                                                    (player.sendErrorsTo instanceof
                                                        Player
                                                        ? player.sendErrorsTo
                                                        : player
                                                    ).getDynamicProperty(
                                                        "andexdbPersonalSettings:timeZone"
                                                    ) ?? 0
                                                ) *
                                                3600000
                                            ).toLocaleString() +
                                            ")") +
                                        " Items: \n" +
                                        slotsArray.join("§r§f\n")
                                    )
                                );
                            }
                        }
                    })();
                } catch (e) {
                    player.sendError("§c" + e + e.stack, true);
                }
                break;
            case !!switchTest.match(/^offlineuuidinvsee$$/):
                eventData.cancel = true;
                try {
                    (async () => {
                        let slotsArray = [];
                        let players = savedPlayer
                            .getSavedPlayers()
                            .filter(
                                (p) => p.id ==
                                    switchTestB.split(" ").slice(1).join(" ")
                            );
                        if (players.length == 0) {
                            player.sendMessageB(
                                "§cError: no players with that uuid were found"
                            );
                        } else {
                            let playerb = players[0];
                            if (semver.satisfies(
                                playerb.player_save_format_version ??
                                "0.0.0",
                                ">=1.5.0"
                            )) {
                                await waitTick();
                                const items = playerb.getItems(player);
                                Object.entries(items).forEachB((item) => {
                                    if (!!item[1]) {
                                        slotsArray = slotsArray.concat(
                                            String(
                                                "slot: " +
                                                item[0] +
                                                "§r§f, item: " +
                                                item[1].typeId +
                                                "§r§f, amount: " +
                                                item[1].amount +
                                                "§r§f, nameTag: " +
                                                item[1].nameTag +
                                                "§r§f, lore: " +
                                                JSONStringify(
                                                    item[1].getLore() ?? [],
                                                    true
                                                ) +
                                                "§r§f, enchantments: " +
                                                JSONStringify(
                                                    tryget(() => item[1]
                                                        .getComponent(
                                                            "enchantable"
                                                        )
                                                        .getEnchantments()
                                                    ) ?? "N/A",
                                                    true
                                                )
                                            )
                                        );
                                    } else {
                                        slotsArray = slotsArray.concat(
                                            "slot: " +
                                            item[0] +
                                            ", item: minecraft:air"
                                        );
                                    }
                                });
                            } else {
                                let items = playerb.items.inventory.concat(
                                    playerb.items.equipment
                                );
                                items.forEach((item) => {
                                    if (item.count != 0) {
                                        slotsArray = slotsArray.concat(
                                            String(
                                                "slot: " +
                                                item.slot +
                                                "§r§f, item: " +
                                                item.id +
                                                "§r§f, amount: " +
                                                item.count +
                                                "§r§f, nameTag: " +
                                                item.name +
                                                "§r§f, lore: " +
                                                JSONStringify(
                                                    item.lore ?? [],
                                                    true
                                                ) +
                                                "§r§f, enchantments: " +
                                                JSON.stringify(
                                                    item.enchants ?? "N/A"
                                                )
                                            )
                                        );
                                    } else {
                                        slotsArray = slotsArray.concat(
                                            "slot: " +
                                            item.slot +
                                            ", item: minecraft:air"
                                        );
                                    }
                                });
                            }
                            eventData.sender.sendMessage(
                                String(
                                    "(format_version: " +
                                    playerb.format_version +
                                    ") " +
                                    playerb.name +
                                    (world
                                        .getAllPlayers()
                                        .find((p) => p.id == playerb.id) !=
                                        undefined
                                        ? " (Online) "
                                        : " (last seen: " +
                                        new Date(
                                            Number(playerb.lastOnline) +
                                            Number(
                                                (player.sendErrorsTo instanceof
                                                    Player
                                                    ? player.sendErrorsTo
                                                    : player
                                                ).getDynamicProperty(
                                                    "andexdbPersonalSettings:timeZone"
                                                ) ?? 0
                                            ) *
                                            3600000
                                        ).toLocaleString() +
                                        ")") +
                                    " Items: \n" +
                                    slotsArray.join("§r§f\n")
                                )
                            );
                        }
                    })();
                } catch (e) {
                    player.sendError("§c" + e + e.stack, true);
                }
                break;
            case !!switchTest.match(/^binvsee$$/):
                eventData.cancel = true;
                system.run(() => {
                    /*
                console.warn(switchTestB.split(" ")[1].trim(), switchTestB.split(" ").slice(2).join(" ").trim(), player.location, player.getViewDirection())
                console.warn(JSONStringify(coordinatesB(switchTestB.split(" ").slice(2).join(" ").trim(), player.location, player.getViewDirection())))
                console.warn(JSONStringify(world.getDimension(switchTestB.split(" ")[1].trim())))*/
                    let block = world
                        .getDimension(
                            switchTestB
                                .split(" ")[1]
                                .trim()
                                .replace("~", player.dimension.id + "\0")
                        )
                        .getBlock(
                            coordinatesB(
                                switchTestB
                                    .split(" ")[1]
                                    .trim()
                                    .startsWith("~") &&
                                    switchTestB.split(" ")[1].trim().length != 1
                                    ? switchTestB
                                        .split(" ")
                                        .slice(1)
                                        .join(" ")
                                        .trim()
                                        .slice(1)
                                    : switchTestB
                                        .split(" ")
                                        .slice(2)
                                        .join(" ")
                                        .trim(),
                                player.location,
                                player.getViewDirection()
                            )
                        ); /*
            console.warn(block)*/

                    const inventoryd2 = block.getComponent("inventory");
                    try {
                        let slotsArray = [];
                        for (let i = 0; i < inventoryd2.container.size; i++) {
                            if (inventoryd2.container.getItem(Number(i)) !==
                                undefined) {
                                slotsArray = slotsArray.concat(
                                    String(
                                        "slot: " +
                                        i +
                                        ", item: " +
                                        inventoryd2.container.getItem(
                                            Number(i)
                                        ).typeId +
                                        ", amount: " +
                                        inventoryd2.container.getItem(
                                            Number(i)
                                        ).amount +
                                        ", nameTag: " +
                                        inventoryd2.container.getItem(
                                            Number(i)
                                        ).nameTag +
                                        "§r§f, lore: " +
                                        JSONStringify(
                                            inventoryd2.container
                                                .getItem(Number(i))
                                                .getLore() ?? [],
                                            true
                                        ) +
                                        "§r§f, enchantments: " +
                                        (!!inventoryd2.container
                                            .getItem(Number(i))
                                            ?.getComponent("enchantable")
                                            ? JSON.stringify(
                                                inventoryd2.container
                                                    .getItem(Number(i))
                                                    ?.getComponent(
                                                        "enchantable"
                                                    )
                                                    ?.getEnchantments() ??
                                                []
                                            ) ?? "[]"
                                            : "N/A")
                                    )
                                );
                            } else {
                                slotsArray = slotsArray.concat(
                                    "slot: " + i + ", item: minecraft:air"
                                );
                            }
                        }
                        eventData.sender.sendMessage(
                            String(
                                "Block At " +
                                JSON.stringify({
                                    dimension: block.dimension.id,
                                    x: block.x,
                                    y: block.y,
                                    z: block.z,
                                }) +
                                " Items: \n" +
                                slotsArray.join("§r§f\n")
                            )
                        );
                    } catch (e) {
                        player.sendError("§c" + e + e.stack, true);
                    }
                });
                break;
            case !!switchTest.match(/^einvseeb$$/):
                eventData.cancel = true;
                system.run(() => {
                    const inventoryd2 = world
                        .getDimension("overworld")
                        .getEntities()
                        .concat(world.getDimension("nether").getEntities())
                        .concat(world.getDimension("the_end").getEntities())
                        .find(
                            (playerFinders) => playerFinders ==
                                targetSelectorB(
                                    switchTestB.slice(9),
                                    "",
                                    Number(eventData.sender.id)
                                )
                        )
                        .getComponent("inventory");
                    try {
                        let slotsArray = [];
                        for (let i = 0; i < inventoryd2.inventorySize; i++) {
                            if (inventoryd2.container.getItem(Number(i)) !==
                                undefined) {
                                slotsArray = slotsArray.concat(
                                    String(
                                        "slot: " +
                                        i +
                                        ", item: " +
                                        inventoryd2.container.getItem(
                                            Number(i)
                                        ).typeId +
                                        ", amount: " +
                                        inventoryd2.container.getItem(
                                            Number(i)
                                        ).amount +
                                        ", nameTag: " +
                                        inventoryd2.container.getItem(
                                            Number(i)
                                        ).nameTag +
                                        "§r§f, lore: " +
                                        JSONStringify(
                                            inventoryd2.container
                                                .getItem(Number(i))
                                                .getLore() ?? [],
                                            true
                                        ) +
                                        "§r§f, enchantments: " +
                                        (!!inventoryd2.container
                                            .getItem(Number(i))
                                            ?.getComponent("enchantable")
                                            ? JSON.stringify(
                                                inventoryd2.container
                                                    .getItem(Number(i))
                                                    ?.getComponent(
                                                        "enchantable"
                                                    )
                                                    ?.getEnchantments() ??
                                                []
                                            ) ?? "[]"
                                            : "N/A")
                                    )
                                );
                            } else {
                                slotsArray = slotsArray.concat(
                                    "slot: " + i + ", item: minecraft:air"
                                );
                            }
                        }
                        eventData.sender.sendMessage(
                            String(
                                world
                                    .getDimension("overworld")
                                    .getEntities()
                                    .concat(
                                        world
                                            .getDimension("nether")
                                            .getEntities()
                                    )
                                    .concat(
                                        world
                                            .getDimension("the_end")
                                            .getEntities()
                                    )
                                    .find(
                                        (playerFinders) => playerFinders ==
                                            targetSelectorB(
                                                switchTestB.slice(9),
                                                "",
                                                Number(eventData.sender.id)
                                            )
                                    ).nameTag +
                                "'s Items: \n" +
                                slotsArray.join("§r§f\n")
                            )
                        );
                    } catch (e) {
                        player.sendError("§c" + e + e.stack, true);
                    }
                });
                break;
            case !!switchTest.match(/^einvsee$$/):
                eventData.cancel = true;
                system.run(() => {
                    const inventoryd2 = world
                        .getDimension("overworld")
                        .getEntities()
                        .concat(world.getDimension("nether").getEntities())
                        .concat(world.getDimension("the_end").getEntities())
                        .find(
                            (playerFinders) => playerFinders ==
                                targetSelectorB(
                                    switchTestB.slice(7),
                                    "",
                                    Number(eventData.sender.id)
                                )
                        )
                        .getComponent("inventory");
                    const equipmentd2 = world
                        .getDimension("overworld")
                        .getEntities()
                        .concat(world.getDimension("nether").getEntities())
                        .concat(world.getDimension("the_end").getEntities())
                        .find(
                            (playerFinders) => playerFinders ==
                                targetSelectorB(
                                    switchTestB.slice(7),
                                    "",
                                    Number(eventData.sender.id)
                                )
                        )
                        .getComponent("equippable");
                    try {
                        let slotsArray = [];
                        if (!!inventoryd2) {
                            try {
                                for (let i = 0; i < inventoryd2.inventorySize; i++) {
                                    if (inventoryd2.container.getItem(
                                        Number(i)
                                    ) !== undefined) {
                                        slotsArray = slotsArray.concat(
                                            String(
                                                "slot: " +
                                                i +
                                                ", item: " +
                                                inventoryd2.container.getItem(
                                                    Number(i)
                                                ).typeId +
                                                ", amount: " +
                                                inventoryd2.container.getItem(
                                                    Number(i)
                                                ).amount +
                                                ", nameTag: " +
                                                inventoryd2.container.getItem(
                                                    Number(i)
                                                ).nameTag +
                                                "§r§f, lore: " +
                                                JSONStringify(
                                                    inventoryd2.container
                                                        .getItem(Number(i))
                                                        .getLore() ?? [],
                                                    true
                                                ) +
                                                "§r§f, enchantments: " +
                                                (!!inventoryd2.container
                                                    .getItem(Number(i))
                                                    ?.getComponent(
                                                        "enchantable"
                                                    )
                                                    ? JSON.stringify(
                                                        inventoryd2.container
                                                            .getItem(
                                                                Number(i)
                                                            )
                                                            ?.getComponent(
                                                                "enchantable"
                                                            )
                                                            ?.getEnchantments() ??
                                                        []
                                                    ) ?? "[]"
                                                    : "N/A")
                                            )
                                        );
                                    } else {
                                        slotsArray = slotsArray.concat(
                                            "slot: " +
                                            i +
                                            ", item: minecraft:air"
                                        );
                                    }
                                }
                            } catch { }
                        }
                        if (!!equipmentd2) {
                            for (let i = 0; i < 6; i++) {
                                try {
                                    let item = equipmentd2.getEquipment(
                                        [
                                            EquipmentSlot.Head,
                                            EquipmentSlot.Chest,
                                            EquipmentSlot.Legs,
                                            EquipmentSlot.Feet,
                                            EquipmentSlot.Mainhand,
                                            EquipmentSlot.Offhand,
                                        ][i]
                                    );
                                    if (item !== undefined) {
                                        slotsArray = slotsArray.concat(
                                            String(
                                                "slot: " +
                                                [
                                                    EquipmentSlot.Head,
                                                    EquipmentSlot.Chest,
                                                    EquipmentSlot.Legs,
                                                    EquipmentSlot.Feet,
                                                    EquipmentSlot.Mainhand,
                                                    EquipmentSlot.Offhand,
                                                ][i] +
                                                ", item: " +
                                                item.typeId +
                                                ", amount: " +
                                                item.amount +
                                                ", nameTag: " +
                                                item.nameTag +
                                                "§r§f, lore: " +
                                                JSONStringify(
                                                    item.getLore() ?? [],
                                                    true
                                                ) +
                                                "§r§f, enchantments: " +
                                                (!!item.getComponent(
                                                    "enchantable"
                                                )
                                                    ? JSON.stringify(
                                                        item
                                                            ?.getComponent(
                                                                "enchantable"
                                                            )
                                                            ?.getEnchantments() ??
                                                        []
                                                    ) ?? "[]"
                                                    : "N/A")
                                            )
                                        );
                                    } else {
                                        slotsArray = slotsArray.concat(
                                            "slot: " +
                                            [
                                                EquipmentSlot.Head,
                                                EquipmentSlot.Chest,
                                                EquipmentSlot.Legs,
                                                EquipmentSlot.Feet,
                                                EquipmentSlot.Mainhand,
                                                EquipmentSlot.Offhand,
                                            ][i] +
                                            ", item: minecraft:air"
                                        );
                                    }
                                } catch { }
                            }
                        }
                        eventData.sender.sendMessage(
                            String(
                                world
                                    .getDimension("overworld")
                                    .getEntities()
                                    .concat(
                                        world
                                            .getDimension("nether")
                                            .getEntities()
                                    )
                                    .concat(
                                        world
                                            .getDimension("the_end")
                                            .getEntities()
                                    )
                                    .find(
                                        (playerFinders) => playerFinders ==
                                            targetSelectorB(
                                                switchTestB.slice(7),
                                                "",
                                                Number(eventData.sender.id)
                                            )
                                    ).nameTag +
                                "'s Items: \n" +
                                slotsArray.join("§r§f\n")
                            )
                        );
                    } catch (e) {
                        player.sendError("§c" + e + e.stack, true);
                    }
                });
                break;
            case !!switchTest.match(/^invseeuuidmode$/):
                eventData.cancel = true;
                const inventoryd = world
                    .getDimension("overworld")
                    .getEntities()
                    .concat(world.getDimension("nether").getEntities())
                    .concat(world.getDimension("the_end").getEntities())
                    .find(
                        (playerFinders) => playerFinders.id ==
                            switchTestB.slice(7).split(" ")[0]
                    )
                    .getComponent("inventory");
                const equipmentd2 = world
                    .getDimension("overworld")
                    .getEntities()
                    .concat(world.getDimension("nether").getEntities())
                    .concat(world.getDimension("the_end").getEntities())
                    .find(
                        (playerFinders) => playerFinders.id ==
                            switchTestB.slice(7).split(" ")[0]
                    )
                    .getComponent("equippable");
                system.run(() => {
                    try {
                        let slotsArray = [];
                        if (!!inventoryd) {
                            try {
                                for (let i = 0; i < inventoryd.inventorySize; i++) {
                                    if (inventoryd.container.getItem(
                                        Number(i)
                                    ) !== undefined) {
                                        slotsArray = slotsArray.concat(
                                            String(
                                                "slot: " +
                                                i +
                                                ", item: " +
                                                inventoryd.container.getItem(
                                                    Number(i)
                                                ).typeId +
                                                ", amount: " +
                                                inventoryd.container.getItem(
                                                    Number(i)
                                                ).amount +
                                                ", nameTag: " +
                                                inventoryd.container.getItem(
                                                    Number(i)
                                                ).nameTag +
                                                "§r§f, lore: " +
                                                JSONStringify(
                                                    inventoryd.container
                                                        .getItem(Number(i))
                                                        .getLore() ?? [],
                                                    true
                                                ) +
                                                "§r§f, enchantments: " +
                                                (!!inventoryd.container
                                                    .getItem(Number(i))
                                                    ?.getComponent(
                                                        "enchantable"
                                                    )
                                                    ? JSON.stringify(
                                                        inventoryd.container
                                                            .getItem(
                                                                Number(i)
                                                            )
                                                            ?.getComponent(
                                                                "enchantable"
                                                            )
                                                            ?.getEnchantments() ??
                                                        []
                                                    ) ?? "[]"
                                                    : "N/A")
                                            )
                                        );
                                    } else {
                                        slotsArray = slotsArray.concat(
                                            "slot: " +
                                            i +
                                            ", item: minecraft:air"
                                        );
                                    }
                                }
                            } catch { }
                        }
                        if (!!equipmentd2) {
                            for (let i = 0; i < 6; i++) {
                                try {
                                    let item = equipmentd2.getEquipment(
                                        [
                                            EquipmentSlot.Head,
                                            EquipmentSlot.Chest,
                                            EquipmentSlot.Legs,
                                            EquipmentSlot.Feet,
                                            EquipmentSlot.Mainhand,
                                            EquipmentSlot.Offhand,
                                        ][i]
                                    );
                                    if (item !== undefined) {
                                        slotsArray = slotsArray.concat(
                                            String(
                                                "slot: " +
                                                [
                                                    EquipmentSlot.Head,
                                                    EquipmentSlot.Chest,
                                                    EquipmentSlot.Legs,
                                                    EquipmentSlot.Feet,
                                                    EquipmentSlot.Mainhand,
                                                    EquipmentSlot.Offhand,
                                                ][i] +
                                                ", item: " +
                                                item.typeId +
                                                ", amount: " +
                                                item.amount +
                                                ", nameTag: " +
                                                item.nameTag +
                                                "§r§f, lore: " +
                                                JSONStringify(
                                                    item.getLore() ?? [],
                                                    true
                                                ) +
                                                "§r§f, enchantments: " +
                                                (!!item?.getComponent(
                                                    "enchantable"
                                                )
                                                    ? JSON.stringify(
                                                        item
                                                            ?.getComponent(
                                                                "enchantable"
                                                            )
                                                            ?.getEnchantments() ??
                                                        []
                                                    ) ?? "[]"
                                                    : "N/A")
                                            )
                                        );
                                    } else {
                                        slotsArray = slotsArray.concat(
                                            "slot: " +
                                            [
                                                EquipmentSlot.Head,
                                                EquipmentSlot.Chest,
                                                EquipmentSlot.Legs,
                                                EquipmentSlot.Feet,
                                                EquipmentSlot.Mainhand,
                                                EquipmentSlot.Offhand,
                                            ][i] +
                                            ", item: minecraft:air"
                                        );
                                    }
                                } catch { }
                            }
                        }
                        eventData.sender.sendMessage(
                            String(
                                world
                                    .getDimension("overworld")
                                    .getEntities()
                                    .concat(
                                        world
                                            .getDimension("nether")
                                            .getEntities()
                                    )
                                    .concat(
                                        world
                                            .getDimension("the_end")
                                            .getEntities()
                                    )
                                    .find(
                                        (playerFinders) => playerFinders.id ==
                                            switchTestB.slice(7).split(" ")[0]
                                    ).nameTag +
                                "'s Items: \n" +
                                slotsArray.join("§r§f\n")
                            )
                        );
                    } catch (e) {
                        player.sendError("§c" + e + e.stack, true);
                    }
                });
                break;
            case !!switchTest.match(/^setitem$/):
                eventData.cancel = true;
                switch (true) {
                    case newMessage.split(" ").length >= 5:
                        {
                            let playerTotalVictimsList: String[];
                            (
                                targetSelectorAllListB(
                                    newMessage.split(" ").slice(4).join(" "),
                                    "",
                                    Number(player.id)
                                ) as Player[]
                            ).forEach((player2) => {
                                playerTotalVictimsList.push(player2.name);
                                const inventoryc = player2.getComponent(
                                    "inventory"
                                ) as EntityInventoryComponent;
                                system.run(() => {
                                    try {
                                        inventoryc.container.setItem(
                                            Number(
                                                newMessage
                                                    .slice(9)
                                                    .split(" ")[2]
                                            ),
                                            new ItemStack(
                                                newMessage
                                                    .slice(9)
                                                    .split(" ")[0],
                                                Number(
                                                    newMessage
                                                        .slice(9)
                                                        .split(" ")[1]
                                                )
                                            )
                                        );
                                        eventData.sender.sendMessage(
                                            String(
                                                "Set Slot " +
                                                newMessage
                                                    .slice(9)
                                                    .split(" ")[2] +
                                                " of " +
                                                player2.name +
                                                "'s inventory to " +
                                                newMessage
                                                    .slice(9)
                                                    .split(" ")[0] +
                                                " * " +
                                                newMessage
                                                    .slice(9)
                                                    .split(" ")[1]
                                            )
                                        );
                                    } catch (e) {
                                        player.sendError(
                                            "§c" + e + e.stack,
                                            true
                                        );
                                    }
                                });
                            });
                            system.run(() => {
                                targetSelectorAllListC(
                                    "@a [tag=canSeeCustomChatCommandFeedbackFromMods]",
                                    "",
                                    "~~~",
                                    player
                                ).forEach((entity) => {
                                    (entity as Player).sendMessage(
                                        String(
                                            "{§l§dCMDFEED§r§f}[" +
                                            player.name +
                                            "§r§f]: Set Slot §c" +
                                            newMessage
                                                .slice(9)
                                                .split(" ")[2] +
                                            "§r§f of §n[§f" +
                                            playerTotalVictimsList +
                                            "§r§u]§f inventories to §u" +
                                            newMessage
                                                .slice(9)
                                                .split(" ")[0] +
                                            "§r§f * §c" +
                                            newMessage
                                                .slice(9)
                                                .split(" ")[1]
                                        )
                                    );
                                });
                            });
                        }
                        break;

                    case newMessage.split(" ").length <= 4:
                        {
                            const inventoryc = player.getComponent(
                                "inventory"
                            ) as EntityInventoryComponent;
                            system.run(() => {
                                try {
                                    inventoryc.container.setItem(
                                        Number(
                                            newMessage.slice(9).split(" ")[2]
                                        ),
                                        new ItemStack(
                                            newMessage.slice(9).split(" ")[0],
                                            Number(
                                                newMessage
                                                    .slice(9)
                                                    .split(" ")[1]
                                            )
                                        )
                                    );
                                    eventData.sender.sendMessage(
                                        String(
                                            "Set Slot " +
                                            newMessage
                                                .slice(9)
                                                .split(" ")[2] +
                                            " of " +
                                            player.name +
                                            "'s inventory to " +
                                            newMessage
                                                .slice(9)
                                                .split(" ")[0] +
                                            " * " +
                                            newMessage
                                                .slice(9)
                                                .split(" ")[1]
                                        )
                                    );
                                    system.run(() => {
                                        targetSelectorAllListE(
                                            "@a [tag=canSeeCustomChatCommandFeedbackFromMods]",
                                            player.location.x +
                                            " " +
                                            player.location.y +
                                            " " +
                                            player.location.z
                                        ).forEach((entity) => {
                                            (entity as Player).sendMessage(
                                                String(
                                                    "{§l§dCMDFEED§r§f}[" +
                                                    player.name +
                                                    "§r§f]: Set Slot " +
                                                    newMessage
                                                        .slice(9)
                                                        .split(" ")[2] +
                                                    " of " +
                                                    player.name +
                                                    "'s inventory to " +
                                                    newMessage
                                                        .slice(9)
                                                        .split(" ")[0] +
                                                    " * " +
                                                    newMessage
                                                        .slice(9)
                                                        .split(" ")[1]
                                                )
                                            );
                                        });
                                    });
                                } catch (e) {
                                    player.sendError("§c" + e + e.stack, true);
                                }
                            });
                        }
                        break;
                }
                break;
            case !!switchTest.match(/^setitemb$/):
                eventData.cancel = true;
                if (switchTestB.trim().split(" ").length == 1) {
                    player.sendMessageB(`setitemb custom command format: ${command.dp}setitemb <itemJSON: itemJSON> <slot: int>
simplified itemJSON format (type "${String(
                        world.getDynamicProperty(
                            "andexdbSettings:chatCommandPrefix"
                        ) ?? "\\"
                    )}help itemJSONFormat" to see full format options): 
{
    "name"?: string,
    "lore"?: string[],
    "count"?: number,
    "keepondeath"?: boolean,
    "lockmode"?: ItemLockMode,
    "canplaceon"?: string[],
    "components"?: {
        "enchantable"?: {
            "add"?: Enchantment|Enchantment[],
            "addList"?: Enchantment[],
            "remove"?: Enchantment,
            "removeEnchantments"?: Enchantment,
            "clear"?: any
        },
        "durability"?: {
            "durability"?: number,
            "damage"?: number,
            "repair"?: number,
            "setDurabilityToMax"?: any
        },
        "damage"?: {
            "durability"?: number,
            "damage"?: number,
            "repair"?: number,
            "setDurabilityToMax"?: any
        }
    },
    force?: boolean
    source?: {
        type?: string,
        targetSelector?: string,
        targetSelectorExecutionLocation?: DimensionLocation,
        targetSelectorSourceEntity?: Entity,
        player?: string,
        entityAtBlock?: DimensionLocation,
        entityType?: string,
        entityTypeId?: string,
        entityId?: string|number,
        block?: DimensionLocation,
        slot?: number,
        id?: string,
        itemId?: string,
        count?: number,
        amount?: number
    },
    type?: string,
    dynamicproperties?: [string, string|number|boolean|Vector3|undefined][]|Record<string, string|number|boolean|Vector3|undefined>,
    cleardynamicproperties?: any,
    removedynamicproperties?: string[],
    removedynamicproperty?: string
}
examples: 
stack of 255 sharpness 1 wooden swords: {"minecraft:components": {"enchantable": {"add": {"level": 1, "type": "sharpness"}}}, "id": "wooden_sword", "count": 255}
sharpness 5 fortune 3 efficiency 5 iron axe that cannot be dropped and are kept on death with the name "§4Storage Hog Axe§r" and the lore "§eTakes\\nUp\\nYour\\nInventory§r" (with the \\n as line break characters) that says lol in the chat and damages the user when used: {"minecraft:components": {"enchantable": {"add": [{"level": 1, "type": "sharpness"}, {"type": "fortune", "level": 3}, {"type": "efficiency", "level": 5}]}}, "id": "iron_axe", "count": 72, "keepondeath": true, "lockMode": "inventory", "name": "§r§4Storage Hog Axe§r§f", "lore": ["§r§eTakes\\nUp§r§f","§r§eYour\\nInventory§r§f"], "dynamicProperties": {"code": "world.sendMessage('lol'); event.source.runCommandAsync(\\"/damage @s 1 thorns entity @s\\")"}}
stack of 16 unbreaking 3 mending 1 shields that are locked to a specific slot and are kept on death: {"minecraft:components": {"enchantable": {"addList": [{"level": 1, "type": "mending"}, {"type": "unbreaking", "level": 3}]}}, "id": "shield", "count": 16, "keepondeath": true, "lockMode": "slot"}`);
                } else {
                    let argsa = evaluateParameters(switchTestB, [
                        "presetText",
                        "json",
                        "presetText",
                    ]);
                    let args = argsa.args;
                    //if((args[3]??"").trim()=="~"){args[3] = player.name}
                    if (!!!(
                        args[1].type ??
                        args[1].typeId ??
                        args[1].id ??
                        args[1].itemType
                    )) {
                        player.sendMessageB(
                            "§cError: Item type not specified in JSON. "
                        );
                    } else {
                        try {
                            let item = itemJSONPropertiesEval(args[1]);
                            switch (true) {
                                case argsa.extra.trim() != "":
                                    {
                                        let playerTotalVictimsList: String[];
                                        (
                                            targetSelectorAllListB(
                                                argsa.extra,
                                                "",
                                                Number(player.id)
                                            ) as Player[]
                                        ).forEach((player2) => {
                                            playerTotalVictimsList.push(
                                                player2.name
                                            );
                                            const inventoryc = player2.getComponent(
                                                "inventory"
                                            ) as EntityInventoryComponent;
                                            system.run(() => {
                                                try {
                                                    inventoryc.container.setItem(
                                                        (
                                                            args[2] ?? ""
                                                        ).trim() == "~" ||
                                                            (
                                                                args[2] ?? ""
                                                            ).trim() == ""
                                                            ? player.selectedSlotIndex
                                                            : Number(args[2]),
                                                        item
                                                    );
                                                    eventData.sender.sendMessage(
                                                        String(
                                                            "Set Slot " +
                                                                ((
                                                                    args[2] ??
                                                                    ""
                                                                ).trim() ==
                                                                    "~" ||
                                                                    (
                                                                        args[2] ??
                                                                        ""
                                                                    ).trim() ==
                                                                    "")
                                                                ? player.selectedSlotIndex
                                                                : args[2] +
                                                                " of " +
                                                                player2.name +
                                                                "'s inventory to " +
                                                                item.typeId +
                                                                " * " +
                                                                item.amount
                                                        )
                                                    );
                                                } catch (e) {
                                                    player.sendError(
                                                        "§c" + e + e.stack,
                                                        true
                                                    );
                                                }
                                            });
                                        });
                                        system.run(() => {
                                            targetSelectorAllListC(
                                                "@a [tag=canSeeCustomChatCommandFeedbackFromMods]",
                                                "",
                                                "~~~",
                                                player
                                            ).forEach((entity) => {
                                                (entity as Player).sendMessage(
                                                    String(
                                                        "{§l§dCMDFEED§r§f}[" +
                                                        player.name +
                                                        "§r§f]: Set Slot §c" +
                                                        args[2] +
                                                        "§r§f of §n[§f" +
                                                        playerTotalVictimsList +
                                                        "§r§u]§f inventories to §u" +
                                                        item.typeId +
                                                        "§r§f * §c" +
                                                        item.amount
                                                    )
                                                );
                                            });
                                        });
                                    }
                                    break;

                                case argsa.extra.trim() == "":
                                    {
                                        const inventoryc = player.getComponent(
                                            "inventory"
                                        ) as EntityInventoryComponent;
                                        system.run(() => {
                                            try {
                                                inventoryc.container.setItem(
                                                    (args[2] ?? "").trim() ==
                                                        "~" ||
                                                        (
                                                            args[2] ?? ""
                                                        ).trim() == ""
                                                        ? player.selectedSlotIndex
                                                        : Number(args[2]),
                                                    item
                                                );
                                                eventData.sender.sendMessage(
                                                    String(
                                                        "Set Slot " +
                                                        args[2] +
                                                        " of " +
                                                        player.name +
                                                        "'s inventory to " +
                                                        item.typeId +
                                                        " * " +
                                                        item.amount
                                                    )
                                                );
                                                world
                                                    .getAllPlayers()
                                                    .filter((v) => v.hasTag(
                                                        "canSeeCustomChatCommandFeedbackFromMods"
                                                    )
                                                    )
                                                    .forEach((playerb) => {
                                                        playerb.sendMessage(
                                                            String(
                                                                "{§l§dCMDFEED§r§f}[" +
                                                                player.name +
                                                                "§r§f]: Set Slot " +
                                                                args[2] +
                                                                " of " +
                                                                player.name +
                                                                "'s inventory to " +
                                                                item.typeId +
                                                                " * " +
                                                                item.amount
                                                            )
                                                        );
                                                    });
                                            } catch (e) {
                                                player.sendError(
                                                    "§c" + e + e.stack,
                                                    true
                                                );
                                            }
                                        });
                                    }
                                    break;
                            }
                        } catch (e) {
                            player.sendError("§c" + e + e.stack, true);
                        }
                    }
                }
                break;
            case !!switchTest.match(/^item$/):
                {
                    try {
                        eventData.cancel = true;
                        if (switchTestB.trim().split(" ").length == 1) {
                            player.sendMessageB(`item command format: 
${command.dp}item
${command.dp}item <mode: {lore}|{lorene}> <lore: JSONArray>
${command.dp}item <mode: {canplaceon}|{candestroy}> <blockTypes: JSONString[]>
${command.dp}item keepondeath <keepOnDeath: bool>
${command.dp}item lockmode <lockMode: {none}|{inventory}|{slot}>
${command.dp}item name <name: text>
${command.dp}item count <count: int(1-255)>
${command.dp}item remove
${command.dp}item gettags
${command.dp}item debug
${command.dp}item <mode: {json}|{jsonb}> <itemJSON: ItemJSON>
${command.dp}item property removelist <propertyIdList: string[]>
${command.dp}item property setlist <propertyList: JSON>
${command.dp}item property <mode: {remove}|{get}> <propertyId: string>
${command.dp}item property setnumber <propertyId: string> <propertyValue: number>
${command.dp}item property setstring <propertyId: string> <propertyValue: string>
${command.dp}item property setboolean <propertyId: string> <propertyValue: boolean>
${command.dp}item property setvector3 <propertyId: string> <propertyValue: Vector3>
${command.dp}item property <mode: {list}|{listdetails}|{clear}>
${command.dp}item enchantment add <enchantment: {"level": number, "type": string}>
${command.dp}item enchantment addlist <enchantment: {"level": number, "type": string}[]>
${command.dp}item enchantment <mode: {remove}|{get}|{testfor}> <enchantmentId: string>
${command.dp}item enchantment <mode: {list}|{clear}>
${command.dp}item slot <slot: int> <mode: {lore}|{lorene}> <lore: JSONArray>
${command.dp}item slot <slot: int> <mode: {canplaceon}|{candestroy}> <blockTypes: JSONString[]>
${command.dp}item slot <slot: int> keepondeath <keepOnDeath: bool>
${command.dp}item slot <slot: int> lockmode <lockMode: {none}|{inventory}|{slot}>
${command.dp}item slot <slot: int> name <name: text>
${command.dp}item slot <slot: int> count <count: int(1-255)>
${command.dp}item slot <slot: int> remove
${command.dp}item slot <slot: int> gettags
${command.dp}item slot <slot: int> debug
${command.dp}item slot <slot: int> <mode: {json}|{jsonb}> <itemJSON: ItemJSON>
${command.dp}item slot <slot: int> property removelist <propertyIdList: JSONString[]>
${command.dp}item slot <slot: int> property setlist <propertyList: JSON>
${command.dp}item slot <slot: int> property <mode: {remove}|{get}> <propertyId: string>
${command.dp}item slot <slot: int> property setnumber <propertyId: string> <propertyValue: number>
${command.dp}item slot <slot: int> property setstring <propertyId: string> <propertyValue: string>
${command.dp}item slot <slot: int> property setboolean <propertyId: string> <propertyValue: boolean>
${command.dp}item slot <slot: int> property setvector3 <propertyId: string> <propertyValue: Vector3>
${command.dp}item slot <slot: int> property <mode: {list}|{listdetails}|{clear}>
${command.dp}item slot <slot: int> enchantment add <enchantment: {"level": number, "type": string}>
${command.dp}item slot <slot: int> enchantment addlist <enchantment: {"level": number, "type": string}[]>
${command.dp}item slot <slot: int> enchantment <mode: {remove}|{get}|{testfor}> <enchantmentId: string>
${command.dp}item slot <slot: int> enchantment <mode: {list}|{clear}>`);
                        } else {
                            let argsa = evaluateParameters(switchTestB, [
                                "presetText",
                                "presetText",
                            ]);
                            try {
                                let command = newMessage.slice(
                                    String(
                                        world.getDynamicProperty(
                                            "andexdbSettings:chatCommandPrefix"
                                        ) ?? "\\"
                                    ).length
                                );
                                switch (command.split(" ").slice(0, 2).join(" ")) {
                                    case "item lore":
                                        let lore = JSON.parse(
                                            command
                                                .split(" ")
                                                .slice(2)
                                                .join(" ")
                                        ) as string[];
                                        let errs: Error[];
                                        errs = [];
                                        lore.forEach((l, i) => {
                                            let calc = l.escapeCharactersB(true);
                                            lore[i] = calc.v;
                                            errs.concat(calc.e);
                                        });
                                        if (errs != undefined) {
                                            errs.forEach((e) => {
                                                player.sendMessageB(
                                                    String("§c" + e + e.stack)
                                                );
                                            });
                                        }
                                        system.run(() => {
                                            try {
                                                player
                                                    .getComponent("inventory")
                                                    .container.getSlot(
                                                        player.selectedSlotIndex
                                                    )
                                                    .setLore(lore);
                                            } catch (e) {
                                                console.error(e, e.stack);
                                                player.sendMessageB(
                                                    "§c" + e + e.stack
                                                );
                                            }
                                        });
                                        break;
                                    case "item lorene":
                                        let lorene = JSON.parse(
                                            command
                                                .split(" ")
                                                .slice(2)
                                                .join(" ")
                                        );
                                        system.run(() => {
                                            try {
                                                player
                                                    .getComponent("inventory")
                                                    .container.getSlot(
                                                        player.selectedSlotIndex
                                                    )
                                                    .setLore(lorene);
                                            } catch (e) {
                                                console.error(e, e.stack);
                                                player.sendMessageB(
                                                    "§c" + e + e.stack
                                                );
                                            }
                                        });
                                        break;
                                    case "item canpalceon":
                                        let canpalceon = JSONParse(
                                            command
                                                .split(" ")
                                                .slice(2)
                                                .join(" ")
                                        ) as string[];
                                        system.run(() => {
                                            try {
                                                player
                                                    .getComponent("inventory")
                                                    .container.getSlot(
                                                        player.selectedSlotIndex
                                                    )
                                                    .setCanPlaceOn(canpalceon);
                                            } catch (e) {
                                                console.error(e, e.stack);
                                                player.sendMessageB(
                                                    "§c" + e + e.stack
                                                );
                                            }
                                        });
                                        break;
                                    case "item candestroy":
                                        let candestroy = JSONParse(
                                            command
                                                .split(" ")
                                                .slice(2)
                                                .join(" ")
                                        ) as string[];
                                        system.run(() => {
                                            try {
                                                player
                                                    .getComponent("inventory")
                                                    .container.getSlot(
                                                        player.selectedSlotIndex
                                                    )
                                                    .setCanDestroy(candestroy);
                                            } catch (e) {
                                                console.error(e, e.stack);
                                                player.sendMessageB(
                                                    "§c" + e + e.stack
                                                );
                                            }
                                        });
                                        break;
                                    case "item keepondeath":
                                        let keepondeath = argsa.extra
                                            .trim()
                                            .toLowerCase();
                                        system.run(() => {
                                            try {
                                                player
                                                    .getComponent("inventory")
                                                    .container.getSlot(
                                                        player.selectedSlotIndex
                                                    ).keepOnDeath = Boolean(
                                                        JSON.parse(keepondeath)
                                                    );
                                            } catch (e) {
                                                console.error(e, e.stack);
                                                player.sendMessageB(
                                                    "§c" + e + e.stack
                                                );
                                            }
                                        });
                                        break;
                                    case "item lockmode":
                                        let lockmode = argsa.extra
                                            .trim()
                                            .toLowerCase();
                                        system.run(() => {
                                            try {
                                                player
                                                    .getComponent("inventory")
                                                    .container.getSlot(
                                                        player.selectedSlotIndex
                                                    ).lockMode =
                                                    lockmode as ItemLockMode;
                                            } catch (e) {
                                                console.error(e, e.stack);
                                                player.sendMessageB(
                                                    "§c" + e + e.stack
                                                );
                                            }
                                        });
                                        break;
                                    case "item name":
                                        let name = argsa.extra.escapeCharactersB(true);
                                        if (name.e != undefined) {
                                            name.e.forEach((e) => {
                                                player.sendMessageB(
                                                    String("§c" + e + e.stack)
                                                );
                                            });
                                        }
                                        system.run(() => {
                                            try {
                                                player
                                                    .getComponent("inventory")
                                                    .container.getSlot(
                                                        player.selectedSlotIndex
                                                    ).nameTag = name.v;
                                            } catch (e) {
                                                console.error(e, e.stack);
                                                player.sendMessageB(
                                                    "§c" + e + e.stack
                                                );
                                            }
                                        });
                                        break;
                                    case "item remove":
                                        system.run(() => {
                                            try {
                                                player
                                                    .getComponent("inventory")
                                                    .container.setItem(
                                                        player.selectedSlotIndex
                                                    );
                                            } catch (e) {
                                                console.error(e, e.stack);
                                                player.sendMessageB(
                                                    "§c" + e + e.stack
                                                );
                                            }
                                        });
                                        break;
                                    case "item new":
                                        system.run(() => {
                                            let argsc = evaluateParameters(
                                                argsa.extra.trim(),
                                                ["string", "number"]
                                            ).args;
                                            try {
                                                player
                                                    .getComponent("inventory")
                                                    .container.setItem(
                                                        player.selectedSlotIndex,
                                                        new ItemStack(
                                                            String(
                                                                (argsc[0] ??
                                                                    "") == ""
                                                                    ? "air"
                                                                    : argsc[0]
                                                            ),
                                                            Number(
                                                                (argsc[1] ??
                                                                    "") == ""
                                                                    ? 1
                                                                    : argsc[1]
                                                            )
                                                        )
                                                    );
                                            } catch (e) {
                                                console.error(e, e.stack);
                                                player.sendMessageB(
                                                    "§c" + e + e.stack
                                                );
                                            }
                                        });
                                        break;
                                    case "item json":
                                        let json = evaluateParameters(
                                            argsa.extra.trim(),
                                            ["json"]
                                        ).args[0];
                                        system.run(() => {
                                            try {
                                                getPlayerselectedSlotIndex(
                                                    player
                                                ).setItem(
                                                    itemJSONPropertiesEval(
                                                        json,
                                                        player
                                                            .getComponent(
                                                                "inventory"
                                                            )
                                                            .container.getItem(
                                                                player.selectedSlotIndex
                                                            ),
                                                        player
                                                    )
                                                );
                                            } catch (e) {
                                                console.error(e, e.stack);
                                                player.sendMessageB(
                                                    "§c" + e + e.stack
                                                );
                                            }
                                        });
                                        break;
                                    case "item jsonb":
                                        let jsonb = evaluateParameters(
                                            argsa.extra.trim(),
                                            ["json"]
                                        ).args[0];
                                        system.run(() => {
                                            try {
                                                itemJSONPropertiesEvalCT(
                                                    jsonb,
                                                    getPlayerselectedSlotIndex(
                                                        player
                                                    ),
                                                    player
                                                );
                                            } catch (e) {
                                                console.error(e, e.stack);
                                                player.sendMessageB(
                                                    "§c" + e + e.stack
                                                );
                                            }
                                        });
                                        break;
                                    case "item listtags":
                                        player.sendMessageB(
                                            '"' +
                                            player
                                                .getComponent("inventory")
                                                .container.getSlot(
                                                    player.selectedSlotIndex
                                                )
                                                .getTags()
                                                .join("§r,") +
                                            '"'
                                        );
                                        break;
                                    case "item gettags":
                                        player.sendMessageB(
                                            '"' +
                                            player
                                                .getComponent("inventory")
                                                .container.getSlot(
                                                    player.selectedSlotIndex
                                                )
                                                .getTags()
                                                .join("§r,") +
                                            '"'
                                        );
                                        break;
                                    case "item debug":
                                        {
                                            const item = player
                                                .getComponent("inventory")
                                                .container.getItem(
                                                    player.selectedSlotIndex
                                                );
                                            srun(() => player.sendMessageB(
                                                `§rtypeId: ${item.typeId}
§ramount: ${item.amount}
§risStackable: ${item.isStackable.toFormattedString()}
§rmaxAmount: ${item.maxAmount}
§rtags: ${JSONB.stringify(item.getTags())}
§rcomponents: ${JSONB.stringify(item.getComponents().map((c) => c.typeId))}
§rnameTag: ${item.nameTag}
§rlore: ${JSONB.stringify(item.getLore())}
§rkeepOnDeath: ${item.keepOnDeath.toFormattedString()}
§rlockMode: ${item.lockMode}
§rcanDestroy: ${JSONB.stringify(item.getCanDestroy())}
§rcanPlaceOn: ${JSONB.stringify(item.getCanPlaceOn())}
§rdynamicPropertyTotalByteCount: ${item.getDynamicPropertyTotalByteCount()}
§rdynamicPropertyIds: ${JSONB.stringify(item.getDynamicPropertyIds())}${item.hasComponent(
                                                    "durability"
                                                )
                                                    ? ((d) => `
§rdurability: ${d.maxDurability - d.damage}/${d.maxDurability}
§rdamageChance: {
§r    Unbreaking 0: ${d.getDamageChance(0)},
§r    Unbreaking 1: ${d.getDamageChance(1)},
§r    Unbreaking 2: ${d.getDamageChance(2)},
§r    Unbreaking 3: ${d.getDamageChance(3)}
§r}
§rdamageChanceRange: ${JSONB.stringify(d.getDamageChanceRange())}`)(
                                                        item.getComponent(
                                                            "durability"
                                                        )
                                                    )
                                                    : ""}${item.hasComponent(
                                                        "enchantable"
                                                    )
                                                    ? ((d) => `
§renchantmentSlots: ${JSONB.stringify(d.slots)}
§renchantments: ${JSONB.stringify(d.getEnchantments())}`)(
                                                        item.getComponent(
                                                            "enchantable"
                                                        )
                                                    )
                                                    : ""}${item.hasComponent(
                                                        "cooldown"
                                                    )
                                                    ? ((d) => `
§rcooldownCategory: ${d.cooldownCategory}
§rcooldownTicks: ${d.cooldownTicks}
§rcooldownTicksRemaining: ${d.getCooldownTicksRemaining(player)}`)(
                                                        item.getComponent(
                                                            "cooldown"
                                                        )
                                                    )
                                                    : ""}${item.hasComponent(
                                                        "food"
                                                    )
                                                    ? ((d) => `
§rcanAlwaysEat: ${d.canAlwaysEat.toFormattedString()}
§rnutrition: ${d.nutrition}
§rsaturationModifier: ${d.saturationModifier}
§rusingConvertsTo: ${d.usingConvertsTo}`)(item.getComponent("food"))
                                                    : ""}${item.hasComponent(
                                                        "potion"
                                                    )
                                                    ? ((d) => `
potionEffectType: ${d.potionEffectType.id}
potionLiquidType: ${d.potionLiquidType.id}
potionModifierType: ${d.potionModifierType.id}`)(item.getComponent("potion"))
                                                    : ""}`
                                            )
                                            );
                                        }
                                        break;
                                    case "item property":
                                        switch (command.split(" ")[2]) {
                                            case "removelist":
                                                (
                                                    evaluateParameters(
                                                        command
                                                            .split(" ")
                                                            .slice(3)
                                                            .join(" "),
                                                        ["json"]
                                                    ).args[0] as string[]
                                                ).forEach((v) => player
                                                    .getComponent(
                                                        "inventory"
                                                    )
                                                    .container.getSlot(
                                                        player.selectedSlotIndex
                                                    )
                                                    .setDynamicProperty(v)
                                                );
                                                break;
                                            case "setlist":
                                                Object.entries(
                                                    evaluateParameters(
                                                        command
                                                            .split(" ")
                                                            .slice(3)
                                                            .join(" "),
                                                        ["json"]
                                                    ).args[0] as Object
                                                ).forEach((v) => player
                                                    .getComponent(
                                                        "inventory"
                                                    )
                                                    .container.getSlot(
                                                        player.selectedSlotIndex
                                                    )
                                                    .setDynamicProperty(
                                                        v[0],
                                                        v[1]
                                                    )
                                                );
                                                break;
                                            case "remove":
                                                player
                                                    .getComponent("inventory")
                                                    .container.getSlot(
                                                        player.selectedSlotIndex
                                                    )
                                                    .setDynamicProperty(
                                                        evaluateParametersOld(
                                                            ["string"],
                                                            command
                                                                .split(" ")
                                                                .slice(3)
                                                                .join(" ")
                                                        ).args[0]
                                                    );
                                                break;
                                            case "setnumber":
                                                player
                                                    .getComponent("inventory")
                                                    .container.getSlot(
                                                        player.selectedSlotIndex
                                                    )
                                                    .setDynamicProperty(
                                                        evaluateParametersOld(
                                                            [
                                                                "string",
                                                                "number",
                                                            ],
                                                            command
                                                                .split(" ")
                                                                .slice(3)
                                                                .join(" ")
                                                        ).args[0],
                                                        evaluateParameters(
                                                            command
                                                                .split(" ")
                                                                .slice(3)
                                                                .join(" "),
                                                            ["string", "number"]
                                                        ).args[1]
                                                    );
                                                break;
                                            case "setstring":
                                                player
                                                    .getComponent("inventory")
                                                    .container.getSlot(
                                                        player.selectedSlotIndex
                                                    )
                                                    .setDynamicProperty(
                                                        evaluateParametersOld(
                                                            [
                                                                "string",
                                                                "string",
                                                            ],
                                                            command
                                                                .split(" ")
                                                                .slice(3)
                                                                .join(" ")
                                                        ).args[0],
                                                        evaluateParameters(
                                                            command
                                                                .split(" ")
                                                                .slice(3)
                                                                .join(" "),
                                                            ["string", "string"]
                                                        ).args[1]
                                                    );
                                                break;
                                            case "setboolean":
                                                player
                                                    .getComponent("inventory")
                                                    .container.getSlot(
                                                        player.selectedSlotIndex
                                                    )
                                                    .setDynamicProperty(
                                                        evaluateParametersOld(
                                                            [
                                                                "string",
                                                                "boolean",
                                                            ],
                                                            command
                                                                .split(" ")
                                                                .slice(3)
                                                                .join(" ")
                                                        ).args[0],
                                                        evaluateParameters(
                                                            command
                                                                .split(" ")
                                                                .slice(3)
                                                                .join(" "),
                                                            [
                                                                "string",
                                                                "boolean",
                                                            ]
                                                        ).args[1]
                                                    );
                                                break;
                                            case "setvector3":
                                                player
                                                    .getComponent("inventory")
                                                    .container.getSlot(
                                                        player.selectedSlotIndex
                                                    )
                                                    .setDynamicProperty(
                                                        evaluateParametersOld(
                                                            ["string", "json"],
                                                            command
                                                                .split(" ")
                                                                .slice(3)
                                                                .join(" ")
                                                        ).args[0],
                                                        evaluateParameters(
                                                            command
                                                                .split(" ")
                                                                .slice(3)
                                                                .join(" "),
                                                            ["string", "json"]
                                                        ).args[1]
                                                    );
                                                break;
                                            case "list":
                                                eventData.sender.sendMessage(
                                                    player
                                                        .getComponent(
                                                            "inventory"
                                                        )
                                                        .container.getSlot(
                                                            player.selectedSlotIndex
                                                        )
                                                        .getDynamicPropertyIds()
                                                        .join("§r§f\n")
                                                );
                                                break;
                                            case "listdetails":
                                                eventData.sender.sendMessage(
                                                    "Total Byte Count: " +
                                                    player
                                                        .getComponent(
                                                            "inventory"
                                                        )
                                                        .container.getSlot(
                                                            player.selectedSlotIndex
                                                        )
                                                        .getDynamicPropertyTotalByteCount() +
                                                    "\n" +
                                                    player
                                                        .getComponent(
                                                            "inventory"
                                                        )
                                                        .container.getSlot(
                                                            player.selectedSlotIndex
                                                        )
                                                        .getDynamicPropertyIds()
                                                        .map(
                                                            (v) => v +
                                                                ": " +
                                                                JSON.stringify(
                                                                    player
                                                                        .getComponent(
                                                                            "inventory"
                                                                        )
                                                                        .container.getSlot(
                                                                            player.selectedSlotIndex
                                                                        )
                                                                        .getDynamicProperty(
                                                                            v
                                                                        )
                                                                )
                                                        )
                                                        .join("§r§f\n")
                                                );
                                                break;
                                            case "get":
                                                eventData.sender.sendMessage(
                                                    JSON.stringify(
                                                        player
                                                            .getComponent(
                                                                "inventory"
                                                            )
                                                            .container.getSlot(
                                                                player.selectedSlotIndex
                                                            )
                                                            .getDynamicProperty(
                                                                evaluateParameters(
                                                                    command
                                                                        .split(
                                                                            " "
                                                                        )
                                                                        .slice(
                                                                            3
                                                                        )
                                                                        .join(
                                                                            " "
                                                                        ),
                                                                    ["string"]
                                                                ).args[0]
                                                            )
                                                    )
                                                );
                                                break;
                                            case "clear":
                                                player
                                                    .getComponent("inventory")
                                                    .container.getSlot(
                                                        player.selectedSlotIndex
                                                    )
                                                    .clearDynamicProperties();
                                                break;
                                            default:
                                                eventData.sender.sendMessage(
                                                    '§cSyntax error: Unexpected "' +
                                                    command
                                                        .split(" ")
                                                        .slice(2)
                                                        .join(" ") +
                                                    '": at "\\item ' +
                                                    command
                                                        .split(" ")
                                                        .slice(1, 2)
                                                        .join(" ") +
                                                    " >>" +
                                                    command
                                                        .split(" ")
                                                        .slice(2)
                                                        .join(" ") +
                                                    '<<"'
                                                );
                                        }
                                        break;
                                    case "item enchantment":
                                        switch (command.split(" ")[2]) {
                                            case "add":
                                                let enchantment = JSON.parse(
                                                    command
                                                        .split(" ")
                                                        .slice(3)
                                                        .join(" ")
                                                );
                                                let itemd = player
                                                    .getComponent("inventory")
                                                    .container.getItem(
                                                        player.selectedSlotIndex
                                                    )
                                                    .clone();
                                                system.run(() => {
                                                    try {
                                                        itemd
                                                            .getComponent(
                                                                "enchantable"
                                                            )
                                                            .addEnchantment({
                                                                level: enchantment.level,
                                                                type: EnchantmentTypes.get(
                                                                    enchantment.type
                                                                ),
                                                            });
                                                        player
                                                            .getComponent(
                                                                "inventory"
                                                            )
                                                            .container.setItem(
                                                                player.selectedSlotIndex,
                                                                itemd
                                                            );
                                                    } catch (e) {
                                                        console.error(
                                                            e,
                                                            e.stack
                                                        );
                                                        player.sendMessageB(
                                                            "§c" + e + e.stack
                                                        );
                                                    }
                                                });
                                                break;
                                            case "addlist":
                                                let enchantmentlist = JSON.parse(
                                                    command
                                                        .split(" ")
                                                        .slice(3)
                                                        .join(" ")
                                                );
                                                let itema = player
                                                    .getComponent("inventory")
                                                    .container.getItem(
                                                        player.selectedSlotIndex
                                                    )
                                                    .clone();
                                                system.run(() => {
                                                    try {
                                                        itema
                                                            .getComponent(
                                                                "enchantable"
                                                            )
                                                            .addEnchantments(
                                                                enchantmentlist.map(
                                                                    (v) => ({
                                                                        level: v.level,
                                                                        type: EnchantmentTypes.get(
                                                                            v.type
                                                                        ),
                                                                    })
                                                                )
                                                            );
                                                        player
                                                            .getComponent(
                                                                "inventory"
                                                            )
                                                            .container.setItem(
                                                                player.selectedSlotIndex,
                                                                itema
                                                            );
                                                    } catch (e) {
                                                        console.error(
                                                            e,
                                                            e.stack
                                                        );
                                                        player.sendMessageB(
                                                            "§c" + e + e.stack
                                                        );
                                                    }
                                                });
                                                break;
                                            case "remove":
                                                let itemb = player
                                                    .getComponent("inventory")
                                                    .container.getItem(
                                                        player.selectedSlotIndex
                                                    )
                                                    .clone();
                                                system.run(() => {
                                                    try {
                                                        itemb
                                                            .getComponent(
                                                                "enchantable"
                                                            )
                                                            .removeEnchantment(
                                                                command.split(
                                                                    " "
                                                                )[3]
                                                            );
                                                        player
                                                            .getComponent(
                                                                "inventory"
                                                            )
                                                            .container.setItem(
                                                                player.selectedSlotIndex,
                                                                itemb
                                                            );
                                                    } catch (e) {
                                                        console.error(
                                                            e,
                                                            e.stack
                                                        );
                                                        player.sendMessageB(
                                                            "§c" + e + e.stack
                                                        );
                                                    }
                                                });
                                                break;
                                            case "set":
                                                eventData.sender.sendMessage(
                                                    "§l§cComing Soon!§r§f"
                                                );
                                                break;
                                            case "list":
                                                eventData.sender.sendMessage(
                                                    JSON.stringify(
                                                        player
                                                            .getComponent(
                                                                "inventory"
                                                            )
                                                            .container.getItem(
                                                                player.selectedSlotIndex
                                                            )
                                                            .getComponent(
                                                                "enchantable"
                                                            )
                                                            .getEnchantments()
                                                    )
                                                );
                                                break;
                                            case "get":
                                                eventData.sender.sendMessage(
                                                    JSON.stringify(
                                                        player
                                                            .getComponent(
                                                                "inventory"
                                                            )
                                                            .container.getItem(
                                                                player.selectedSlotIndex
                                                            )
                                                            .getComponent(
                                                                "enchantable"
                                                            )
                                                            .getEnchantment(
                                                                command.split(
                                                                    " "
                                                                )[3]
                                                            )
                                                    )
                                                );
                                                break;
                                            case "clear":
                                                const itemc = player
                                                    .getComponent("inventory")
                                                    .container.getItem(
                                                        player.selectedSlotIndex
                                                    )
                                                    .clone();
                                                system.run(() => {
                                                    try {
                                                        itemc
                                                            .getComponent(
                                                                "enchantable"
                                                            )
                                                            .removeAllEnchantments();
                                                        player
                                                            .getComponent(
                                                                "inventory"
                                                            )
                                                            .container.setItem(
                                                                player.selectedSlotIndex,
                                                                itemc
                                                            );
                                                    } catch (e) {
                                                        console.error(
                                                            e,
                                                            e.stack
                                                        );
                                                        player.sendMessageB(
                                                            "§c" + e + e.stack
                                                        );
                                                    }
                                                });
                                                break;
                                            case "testfor":
                                                eventData.sender.sendMessage(
                                                    JSON.stringify(
                                                        player
                                                            .getComponent(
                                                                "inventory"
                                                            )
                                                            .container.getItem(
                                                                player.selectedSlotIndex
                                                            )
                                                            .getComponent(
                                                                "enchantable"
                                                            )
                                                            .hasEnchantment(
                                                                command.split(
                                                                    " "
                                                                )[3]
                                                            )
                                                    )
                                                );
                                                break;
                                            default:
                                                eventData.sender.sendMessage(
                                                    '§cSyntax error: Unexpected "' +
                                                    command
                                                        .split(" ")
                                                        .slice(2)
                                                        .join(" ") +
                                                    '": at "\\item ' +
                                                    command
                                                        .split(" ")
                                                        .slice(1, 2)
                                                        .join(" ") +
                                                    " >>" +
                                                    command
                                                        .split(" ")
                                                        .slice(2)
                                                        .join(" ") +
                                                    '<<"'
                                                );
                                                break;
                                        }
                                        break;
                                    case "item slot":
                                        let argsb = evaluateParameters(
                                            argsa.extra.trim(),
                                            ["presetText", "presetText"]
                                        );
                                        let slota = getSlotFromParsedSlot(
                                            parseSlot(
                                                String(
                                                    (argsb.args[0] ?? "") ==
                                                        "" ||
                                                        (argsb.args[0] ?? "") ==
                                                        "~"
                                                        ? String(
                                                            player.selectedSlotIndex
                                                        )
                                                        : String(
                                                            argsb.args[0] ??
                                                            ""
                                                        )
                                                ),
                                                player.selectedSlotIndex
                                            ),
                                            {
                                                container: player?.getComponent(
                                                    "inventory"
                                                )?.container,
                                                equipment: player?.getComponent(
                                                    "equippable"
                                                ),
                                                selectedSlotIndex: player?.selectedSlotIndex,
                                            }
                                        );
                                        let slot = slota instanceof
                                            PlayerCursorInventoryComponent
                                            ? slota.item
                                            : slota;
                                        switch (argsb.args[1] ?? "") {
                                            case "lore":
                                                if (slota instanceof
                                                    PlayerCursorInventoryComponent ||
                                                    slot instanceof ItemStack) {
                                                    throw new Error(
                                                        "You cannot modify the item inside of a player's cursor inventory slot."
                                                    );
                                                }
                                                let lore = JSON.parse(
                                                    command
                                                        .split(" ")
                                                        .slice(4)
                                                        .join(" ")
                                                ) as string[];
                                                let errs: Error[];
                                                errs = [];
                                                lore.forEach((l, i) => {
                                                    let calc = l.escapeCharactersB(
                                                        true
                                                    );
                                                    lore[i] = calc.v;
                                                    errs.concat(calc.e);
                                                });
                                                if (errs != undefined) {
                                                    errs.forEach((e) => {
                                                        player.sendMessageB(
                                                            String(
                                                                "§c" +
                                                                e +
                                                                e.stack
                                                            )
                                                        );
                                                    });
                                                }
                                                srun(() => {
                                                    try {
                                                        slot.setLore(lore);
                                                    } catch (e) {
                                                        console.error(
                                                            e,
                                                            e.stack
                                                        );
                                                        player.sendMessageB(
                                                            "§c" + e + e.stack
                                                        );
                                                    }
                                                });
                                                //system.run(()=>{try{player.getComponent("inventory").container.getSlot(Number(command.split(" ")[2])).setLore(lore)}catch(e){console.error(e, e.stack); player.sendMessageB("§c" + e + e.stack)}})
                                                break;
                                            case "lorene":
                                                if (slota instanceof
                                                    PlayerCursorInventoryComponent ||
                                                    slot instanceof ItemStack) {
                                                    throw new Error(
                                                        "You cannot modify the item inside of a player's cursor inventory slot."
                                                    );
                                                }
                                                let lorene = JSON.parse(
                                                    command
                                                        .split(" ")
                                                        .slice(4)
                                                        .join(" ")
                                                );
                                                system.run(() => {
                                                    try {
                                                        slot.setLore(lorene);
                                                    } catch (e) {
                                                        console.error(
                                                            e,
                                                            e.stack
                                                        );
                                                        player.sendMessageB(
                                                            "§c" + e + e.stack
                                                        );
                                                    }
                                                });
                                                break;
                                            case "canpalceon":
                                                if (slota instanceof
                                                    PlayerCursorInventoryComponent ||
                                                    slot instanceof ItemStack) {
                                                    throw new Error(
                                                        "You cannot modify the item inside of a player's cursor inventory slot."
                                                    );
                                                }
                                                let canpalceon = JSONParse(
                                                    command
                                                        .split(" ")
                                                        .slice(4)
                                                        .join(" ")
                                                ) as string[];
                                                system.run(() => {
                                                    try {
                                                        slot.setCanPlaceOn(
                                                            canpalceon
                                                        );
                                                    } catch (e) {
                                                        console.error(
                                                            e,
                                                            e.stack
                                                        );
                                                        player.sendMessageB(
                                                            "§c" + e + e.stack
                                                        );
                                                    }
                                                });
                                                break;
                                            case "candestroy":
                                                if (slota instanceof
                                                    PlayerCursorInventoryComponent ||
                                                    slot instanceof ItemStack) {
                                                    throw new Error(
                                                        "You cannot modify the item inside of a player's cursor inventory slot."
                                                    );
                                                }
                                                let candestroy = JSONParse(
                                                    command
                                                        .split(" ")
                                                        .slice(4)
                                                        .join(" ")
                                                ) as string[];
                                                system.run(() => {
                                                    try {
                                                        slot.setCanDestroy(
                                                            candestroy
                                                        );
                                                    } catch (e) {
                                                        console.error(
                                                            e,
                                                            e.stack
                                                        );
                                                        player.sendMessageB(
                                                            "§c" + e + e.stack
                                                        );
                                                    }
                                                });
                                                break;
                                            case "keepondeath":
                                                if (slota instanceof
                                                    PlayerCursorInventoryComponent ||
                                                    slot instanceof ItemStack) {
                                                    throw new Error(
                                                        "You cannot modify the item inside of a player's cursor inventory slot."
                                                    );
                                                }
                                                let keepondeath = argsb.extra
                                                    .trim()
                                                    .toLowerCase();
                                                system.run(() => {
                                                    try {
                                                        slot.keepOnDeath =
                                                            Boolean(
                                                                JSON.parse(
                                                                    keepondeath
                                                                )
                                                            );
                                                    } catch (e) {
                                                        console.error(
                                                            e,
                                                            e.stack
                                                        );
                                                        player.sendError(e);
                                                    }
                                                });
                                                break;
                                            case "lockmode":
                                                if (slota instanceof
                                                    PlayerCursorInventoryComponent ||
                                                    slot instanceof ItemStack) {
                                                    throw new Error(
                                                        "You cannot modify the item inside of a player's cursor inventory slot."
                                                    );
                                                }
                                                let lockmode = argsb.extra
                                                    .trim()
                                                    .toLowerCase();
                                                system.run(() => {
                                                    try {
                                                        slot.lockMode =
                                                            lockmode as ItemLockMode;
                                                    } catch (e) {
                                                        console.error(
                                                            e,
                                                            e.stack
                                                        );
                                                        player.sendError(e);
                                                    }
                                                });
                                                break;
                                            case "name":
                                                if (slota instanceof
                                                    PlayerCursorInventoryComponent ||
                                                    slot instanceof ItemStack) {
                                                    throw new Error(
                                                        "You cannot modify the item inside of a player's cursor inventory slot."
                                                    );
                                                }
                                                let name = command
                                                    .split(" ")
                                                    .slice(4)
                                                    .join(" ")
                                                    .escapeCharactersB(true);
                                                if (name.e != undefined) {
                                                    name.e.forEach((e) => {
                                                        player.sendMessageB(
                                                            String(
                                                                "§c" +
                                                                e +
                                                                e.stack
                                                            )
                                                        );
                                                    });
                                                }
                                                system.run(() => {
                                                    try {
                                                        slot.nameTag = name.v;
                                                    } catch (e) {
                                                        console.error(
                                                            e,
                                                            e.stack
                                                        );
                                                        player.sendMessageB(
                                                            "§c" + e + e.stack
                                                        );
                                                    }
                                                });
                                                break;
                                            case "remove":
                                                system.run(() => {
                                                    try {
                                                        slota instanceof
                                                            PlayerCursorInventoryComponent
                                                            ? slota.clear()
                                                            : (
                                                                slot as ContainerSlot
                                                            ).setItem();
                                                    } catch (e) {
                                                        console.error(
                                                            e,
                                                            e.stack
                                                        );
                                                        player.sendMessageB(
                                                            "§c" + e + e.stack
                                                        );
                                                    }
                                                });
                                                break;
                                            case "new":
                                                if (slota instanceof
                                                    PlayerCursorInventoryComponent ||
                                                    slot instanceof ItemStack) {
                                                    throw new Error(
                                                        "You cannot modify the item inside of a player's cursor inventory slot."
                                                    );
                                                }
                                                system.run(() => {
                                                    let argsc = evaluateParameters(
                                                        argsb.extra.trim(),
                                                        ["string", "number"]
                                                    ).args;
                                                    try {
                                                        (
                                                            slot as ContainerSlot
                                                        ).setItem(
                                                            new ItemStack(
                                                                String(
                                                                    (argsc[0] ??
                                                                        "") ==
                                                                        ""
                                                                        ? "air"
                                                                        : argsc[0]
                                                                ),
                                                                Number(
                                                                    (argsc[1] ??
                                                                        "") ==
                                                                        ""
                                                                        ? 1
                                                                        : argsc[1]
                                                                )
                                                            )
                                                        );
                                                    } catch (e) {
                                                        console.error(
                                                            e,
                                                            e.stack
                                                        );
                                                        player.sendMessageB(
                                                            "§c" + e + e.stack
                                                        );
                                                    }
                                                });
                                                break;
                                            case "components":
                                                eventData.sender.sendMessage(
                                                    "§l§cComing Soon!§r§f"
                                                );
                                                break;
                                            case "amount":
                                                system.run(() => {
                                                    try {
                                                        slot.amount = Number(
                                                            command
                                                                .split(" ")
                                                                .slice(4)
                                                                .join(" ")
                                                        );
                                                    } catch (e) {
                                                        console.error(
                                                            e,
                                                            e.stack
                                                        );
                                                        player.sendMessageB(
                                                            "§c" + e + e.stack
                                                        );
                                                    }
                                                });
                                                break;
                                            case "count":
                                                system.run(() => {
                                                    try {
                                                        slot.amount = Number(
                                                            command
                                                                .split(" ")
                                                                .slice(4)
                                                                .join(" ")
                                                        );
                                                    } catch (e) {
                                                        console.error(
                                                            e,
                                                            e.stack
                                                        );
                                                        player.sendMessageB(
                                                            "§c" + e + e.stack
                                                        );
                                                    }
                                                });
                                                break;
                                            case "nameTag":
                                                let nameb = command
                                                    .split(" ")
                                                    .slice(4)
                                                    .join(" ")
                                                    .escapeCharactersB(true);
                                                if (nameb.e != undefined) {
                                                    nameb.e.forEach((e) => {
                                                        player.sendMessageB(
                                                            String(
                                                                "§c" +
                                                                e +
                                                                e.stack
                                                            )
                                                        );
                                                    });
                                                }
                                                system.run(() => {
                                                    try {
                                                        slot.nameTag = nameb.v;
                                                    } catch (e) {
                                                        console.error(
                                                            e,
                                                            e.stack
                                                        );
                                                        player.sendMessageB(
                                                            "§c" + e + e.stack
                                                        );
                                                    }
                                                });
                                                break;
                                            case "listtags":
                                                player.sendMessageB(
                                                    '"' +
                                                    slot
                                                        .getTags()
                                                        .join("§r,") +
                                                    '"'
                                                );
                                                break;
                                            case "gettags":
                                                player.sendMessageB(
                                                    '"' +
                                                    slot
                                                        .getTags()
                                                        .join("§r,") +
                                                    '"'
                                                );
                                                break;
                                            case "debug":
                                                {
                                                    const item = slot instanceof
                                                        ItemStack
                                                        ? slot
                                                        : slot.getItem();
                                                    srun(() => player.sendMessageB(
                                                        `§rtypeId: ${item.typeId}
§ramount: ${item.amount}
§risStackable: ${item.isStackable.toFormattedString()}
§rmaxAmount: ${item.maxAmount}
§rtags: ${JSONB.stringify(item.getTags())}
§rcomponents: ${JSONB.stringify(item.getComponents().map((c) => c.typeId))}
§rnameTag: ${item.nameTag}
§rlore: ${JSONB.stringify(item.getLore())}
§rkeepOnDeath: ${item.keepOnDeath.toFormattedString()}
§rlockMode: ${item.lockMode}
§rcanDestroy: ${JSONB.stringify(item.getCanDestroy())}
§rcanPlaceOn: ${JSONB.stringify(item.getCanPlaceOn())}
§rdynamicPropertyTotalByteCount: ${item.getDynamicPropertyTotalByteCount()}
§rdynamicPropertyIds: ${JSONB.stringify(item.getDynamicPropertyIds())}${item.hasComponent(
                                                            "durability"
                                                        )
                                                            ? ((d) => `
§rdurability: ${d.maxDurability - d.damage}/${d.maxDurability}
§rdamageChance: {
§r    Unbreaking 0: ${d.getDamageChance(0)},
§r    Unbreaking 1: ${d.getDamageChance(1)},
§r    Unbreaking 2: ${d.getDamageChance(2)},
§r    Unbreaking 3: ${d.getDamageChance(3)}
§r}
§rdamageChanceRange: ${JSONB.stringify(d.getDamageChanceRange())}`)(
                                                                item.getComponent(
                                                                    "durability"
                                                                )
                                                            )
                                                            : ""}${item.hasComponent(
                                                                "enchantable"
                                                            )
                                                            ? ((d) => `
§renchantmentSlots: ${JSONB.stringify(d.slots)}
§renchantments: ${JSONB.stringify(d.getEnchantments())}`)(
                                                                item.getComponent(
                                                                    "enchantable"
                                                                )
                                                            )
                                                            : ""}${item.hasComponent(
                                                                "cooldown"
                                                            )
                                                            ? ((d) => `
§rcooldownCategory: ${d.cooldownCategory}
§rcooldownTicks: ${d.cooldownTicks}
§rcooldownTicksRemaining: ${d.getCooldownTicksRemaining(player)}`)(
                                                                item.getComponent(
                                                                    "cooldown"
                                                                )
                                                            )
                                                            : ""}${item.hasComponent(
                                                                "food"
                                                            )
                                                            ? ((d) => `
§rcanAlwaysEat: ${d.canAlwaysEat.toFormattedString()}
§rnutrition: ${d.nutrition}
§rsaturationModifier: ${d.saturationModifier}
§rusingConvertsTo: ${d.usingConvertsTo}`)(item.getComponent("food"))
                                                            : ""}${item.hasComponent(
                                                                "potion"
                                                            )
                                                            ? ((d) => `
potionEffectType: ${d.potionEffectType.id}
potionLiquidType: ${d.potionLiquidType.id}
potionModifierType: ${d.potionModifierType.id}`)(item.getComponent("potion"))
                                                            : ""}`
                                                    )
                                                    );
                                                }
                                                break;
                                            case "enchantment":
                                                switch (command.split(" ")[4]) {
                                                    case "add":
                                                        if (slota instanceof
                                                            PlayerCursorInventoryComponent ||
                                                            slot instanceof
                                                            ItemStack) {
                                                            throw new Error(
                                                                "You cannot modify the item inside of a player's cursor inventory slot."
                                                            );
                                                        }
                                                        let enchantment = JSON.parse(
                                                            command
                                                                .split(" ")
                                                                .slice(5)
                                                                .join(" ")
                                                        );
                                                        let itemd = slot
                                                            .getItem()
                                                            .clone();
                                                        system.run(() => {
                                                            try {
                                                                itemd
                                                                    .getComponent(
                                                                        "enchantable"
                                                                    )
                                                                    .addEnchantment(
                                                                        {
                                                                            level: enchantment.level,
                                                                            type: EnchantmentTypes.get(
                                                                                enchantment.type
                                                                            ),
                                                                        }
                                                                    );
                                                                (
                                                                    slot as ContainerSlot
                                                                ).setItem(
                                                                    itemd
                                                                );
                                                            } catch (e) {
                                                                console.error(
                                                                    e,
                                                                    e.stack
                                                                );
                                                                player.sendMessageB(
                                                                    "§c" +
                                                                    e +
                                                                    e.stack
                                                                );
                                                            }
                                                        });
                                                        break;
                                                    case "addlist":
                                                        if (slota instanceof
                                                            PlayerCursorInventoryComponent ||
                                                            slot instanceof
                                                            ItemStack) {
                                                            throw new Error(
                                                                "You cannot modify the item inside of a player's cursor inventory slot."
                                                            );
                                                        }
                                                        let enchantmentlist = JSON.parse(
                                                            command
                                                                .split(" ")
                                                                .slice(5)
                                                                .join(" ")
                                                        );
                                                        let itema = slot
                                                            .getItem()
                                                            .clone();
                                                        system.run(() => {
                                                            try {
                                                                itema
                                                                    .getComponent(
                                                                        "enchantable"
                                                                    )
                                                                    .addEnchantments(
                                                                        enchantmentlist.map(
                                                                            (
                                                                                v
                                                                            ) => ({
                                                                                level: v.level,
                                                                                type: EnchantmentTypes.get(
                                                                                    v.type
                                                                                ),
                                                                            })
                                                                        )
                                                                    );
                                                                (
                                                                    slot as ContainerSlot
                                                                ).setItem(
                                                                    itema
                                                                );
                                                            } catch (e) {
                                                                console.error(
                                                                    e,
                                                                    e.stack
                                                                );
                                                                player.sendMessageB(
                                                                    "§c" +
                                                                    e +
                                                                    e.stack
                                                                );
                                                            }
                                                        });
                                                        break;
                                                    case "remove":
                                                        if (slota instanceof
                                                            PlayerCursorInventoryComponent ||
                                                            slot instanceof
                                                            ItemStack) {
                                                            throw new Error(
                                                                "You cannot modify the item inside of a player's cursor inventory slot."
                                                            );
                                                        }
                                                        let itemb = slot
                                                            .getItem()
                                                            .clone();
                                                        system.run(() => {
                                                            try {
                                                                itemb
                                                                    .getComponent(
                                                                        "enchantable"
                                                                    )
                                                                    .removeEnchantment(
                                                                        command.split(
                                                                            " "
                                                                        )[5]
                                                                    );
                                                                (
                                                                    slot as ContainerSlot
                                                                ).setItem(
                                                                    itemb
                                                                );
                                                            } catch (e) {
                                                                console.error(
                                                                    e,
                                                                    e.stack
                                                                );
                                                                player.sendMessageB(
                                                                    "§c" +
                                                                    e +
                                                                    e.stack
                                                                );
                                                            }
                                                        });
                                                        break;
                                                    case "set":
                                                        if (slota instanceof
                                                            PlayerCursorInventoryComponent ||
                                                            slot instanceof
                                                            ItemStack) {
                                                            throw new Error(
                                                                "You cannot modify the item inside of a player's cursor inventory slot."
                                                            );
                                                        }
                                                        eventData.sender.sendMessage(
                                                            "§l§cComing Soon!§r§f"
                                                        );
                                                        break;
                                                    case "list":
                                                        eventData.sender.sendMessage(
                                                            JSON.stringify(
                                                                (slot instanceof
                                                                    ItemStack
                                                                    ? slot
                                                                    : slot.getItem()
                                                                )
                                                                    .getComponent(
                                                                        "enchantable"
                                                                    )
                                                                    .getEnchantments()
                                                            )
                                                        );
                                                        break;
                                                    case "get":
                                                        eventData.sender.sendMessage(
                                                            JSON.stringify(
                                                                (slot instanceof
                                                                    ItemStack
                                                                    ? slot
                                                                    : slot.getItem()
                                                                )
                                                                    .getComponent(
                                                                        "enchantable"
                                                                    )
                                                                    .getEnchantment(
                                                                        command.split(
                                                                            " "
                                                                        )[5]
                                                                    )
                                                            )
                                                        );
                                                        break;
                                                    case "clear":
                                                        if (slota instanceof
                                                            PlayerCursorInventoryComponent ||
                                                            slot instanceof
                                                            ItemStack) {
                                                            throw new Error(
                                                                "You cannot modify the item inside of a player's cursor inventory slot."
                                                            );
                                                        }
                                                        const itemc = slot
                                                            .getItem()
                                                            .clone();
                                                        system.run(() => {
                                                            try {
                                                                itemc
                                                                    .getComponent(
                                                                        "enchantable"
                                                                    )
                                                                    .removeAllEnchantments();
                                                                (
                                                                    slot as ContainerSlot
                                                                ).setItem(
                                                                    itemc
                                                                );
                                                            } catch (e) {
                                                                console.error(
                                                                    e,
                                                                    e.stack
                                                                );
                                                                player.sendMessageB(
                                                                    "§c" +
                                                                    e +
                                                                    e.stack
                                                                );
                                                            }
                                                        });
                                                        break;
                                                    case "test":
                                                        eventData.sender.sendMessage(
                                                            "§l§cComing Soon!§r§f"
                                                        );
                                                        break;
                                                    default:
                                                        eventData.sender.sendMessage(
                                                            '§cSyntax error: Unexpected "' +
                                                            command
                                                                .split(" ")
                                                                .slice(4)
                                                                .join(" ") +
                                                            '": at "\\item ' +
                                                            command
                                                                .split(" ")
                                                                .slice(1, 4)
                                                                .join(" ") +
                                                            " >>" +
                                                            command
                                                                .split(" ")
                                                                .slice(4)
                                                                .join(" ") +
                                                            '<<"'
                                                        );
                                                        break;
                                                }
                                                break;
                                            case "json":
                                                if (slota instanceof
                                                    PlayerCursorInventoryComponent ||
                                                    slot instanceof ItemStack) {
                                                    throw new Error(
                                                        "You cannot modify the item inside of a player's cursor inventory slot."
                                                    );
                                                }
                                                let json = evaluateParameters(
                                                    argsb.extra.trim(),
                                                    ["json"]
                                                ).args[0];
                                                system.run(() => {
                                                    try {
                                                        (
                                                            slot as ContainerSlot
                                                        ).setItem(
                                                            itemJSONPropertiesEval(
                                                                json,
                                                                slot as ContainerSlot,
                                                                player
                                                            )
                                                        );
                                                    } catch (e) {
                                                        console.error(
                                                            e,
                                                            e.stack
                                                        );
                                                        player.sendMessageB(
                                                            "§c" + e + e.stack
                                                        );
                                                    }
                                                });
                                                break;
                                            case "jsonb":
                                                if (slota instanceof
                                                    PlayerCursorInventoryComponent ||
                                                    slot instanceof ItemStack) {
                                                    throw new Error(
                                                        "You cannot modify the item inside of a player's cursor inventory slot."
                                                    );
                                                }
                                                let jsonb = evaluateParameters(
                                                    argsb.extra.trim(),
                                                    ["json"]
                                                ).args[0];
                                                system.run(() => {
                                                    try {
                                                        itemJSONPropertiesEvalCT(
                                                            jsonb,
                                                            slot as ContainerSlot,
                                                            player
                                                        );
                                                    } catch (e) {
                                                        console.error(
                                                            e,
                                                            e.stack
                                                        );
                                                        player.sendMessageB(
                                                            "§c" + e + e.stack
                                                        );
                                                    }
                                                });
                                                break;
                                            case "property":
                                                switch (command.split(" ")[4]) {
                                                    case "removelist":
                                                        (
                                                            evaluateParametersOld(
                                                                ["json"],
                                                                command
                                                                    .split(" ")
                                                                    .slice(5)
                                                                    .join(" ")
                                                            )
                                                                .args[0] as string[]
                                                        ).forEach((v) => slot.setDynamicProperty(
                                                            v
                                                        )
                                                        );
                                                        break;
                                                    case "setlist":
                                                        Object.entries(
                                                            evaluateParametersOld(
                                                                ["json"],
                                                                command
                                                                    .split(" ")
                                                                    .slice(5)
                                                                    .join(" ")
                                                            ).args[0] as Object
                                                        ).forEach((v) => slot.setDynamicProperty(
                                                            v[0],
                                                            v[1]
                                                        )
                                                        );
                                                        break;
                                                    case "remove":
                                                        slot.setDynamicProperty(
                                                            evaluateParametersOld(
                                                                ["string"],
                                                                command
                                                                    .split(" ")
                                                                    .slice(5)
                                                                    .join(" ")
                                                            ).args[0]
                                                        );
                                                        break;
                                                    case "setnumber":
                                                        slot.setDynamicProperty(
                                                            evaluateParametersOld(
                                                                [
                                                                    "string",
                                                                    "number",
                                                                ],
                                                                command
                                                                    .split(" ")
                                                                    .slice(5)
                                                                    .join(" ")
                                                            ).args[0],
                                                            evaluateParametersOld(
                                                                [
                                                                    "string",
                                                                    "number",
                                                                ],
                                                                command
                                                                    .split(" ")
                                                                    .slice(5)
                                                                    .join(" ")
                                                            ).args[1]
                                                        );
                                                        break;
                                                    case "setstring":
                                                        slot.setDynamicProperty(
                                                            evaluateParametersOld(
                                                                [
                                                                    "string",
                                                                    "string",
                                                                ],
                                                                command
                                                                    .split(" ")
                                                                    .slice(5)
                                                                    .join(" ")
                                                            ).args[0],
                                                            evaluateParametersOld(
                                                                [
                                                                    "string",
                                                                    "string",
                                                                ],
                                                                command
                                                                    .split(" ")
                                                                    .slice(5)
                                                                    .join(" ")
                                                            ).args[1]
                                                        );
                                                        break;
                                                    case "setboolean":
                                                        slot.setDynamicProperty(
                                                            evaluateParametersOld(
                                                                [
                                                                    "string",
                                                                    "boolean",
                                                                ],
                                                                command
                                                                    .split(" ")
                                                                    .slice(5)
                                                                    .join(" ")
                                                            ).args[0],
                                                            evaluateParametersOld(
                                                                [
                                                                    "string",
                                                                    "boolean",
                                                                ],
                                                                command
                                                                    .split(" ")
                                                                    .slice(5)
                                                                    .join(" ")
                                                            ).args[1]
                                                        );
                                                        break;
                                                    case "setvector3":
                                                        slot.setDynamicProperty(
                                                            evaluateParametersOld(
                                                                [
                                                                    "string",
                                                                    "json",
                                                                ],
                                                                command
                                                                    .split(" ")
                                                                    .slice(5)
                                                                    .join(" ")
                                                            ).args[0],
                                                            evaluateParametersOld(
                                                                [
                                                                    "string",
                                                                    "json",
                                                                ],
                                                                command
                                                                    .split(" ")
                                                                    .slice(5)
                                                                    .join(" ")
                                                            ).args[1]
                                                        );
                                                        break;
                                                    case "list":
                                                        eventData.sender.sendMessage(
                                                            slot
                                                                .getDynamicPropertyIds()
                                                                .join("§r§f\n")
                                                        );
                                                        break;
                                                    case "get":
                                                        eventData.sender.sendMessage(
                                                            JSON.stringify(
                                                                slot.getDynamicProperty(
                                                                    evaluateParametersOld(
                                                                        [
                                                                            "string",
                                                                        ],
                                                                        command
                                                                            .split(
                                                                                " "
                                                                            )
                                                                            .slice(
                                                                                5
                                                                            )
                                                                            .join(
                                                                                " "
                                                                            )
                                                                    ).args[0]
                                                                )
                                                            )
                                                        );
                                                        break;
                                                    case "clear":
                                                        slot.clearDynamicProperties();
                                                        break;
                                                    default:
                                                        eventData.sender.sendMessage(
                                                            '§cSyntax error: Unexpected "' +
                                                            command
                                                                .split(" ")
                                                                .slice(2)
                                                                .join(" ") +
                                                            '": at "\\item ' +
                                                            command
                                                                .split(" ")
                                                                .slice(1, 2)
                                                                .join(" ") +
                                                            " >>" +
                                                            command
                                                                .split(" ")
                                                                .slice(2)
                                                                .join(" ") +
                                                            '<<"'
                                                        );
                                                        break;
                                                }
                                                break;
                                            default:
                                                eventData.sender.sendMessage(
                                                    '§cSyntax error: Unexpected "' +
                                                    command.split(" ")[3] +
                                                    '": at "\\item ' +
                                                    command
                                                        .split(" ")
                                                        .slice(1, 3)
                                                        .join(" ") +
                                                    " >>" +
                                                    command
                                                        .split(" ")
                                                        .slice(3)
                                                        .join(" ") +
                                                    '<<"'
                                                );
                                                break;
                                        }
                                        break;
                                    case "item components":
                                        eventData.sender.sendMessage(
                                            "§l§cComing Soon!§r§f"
                                        );
                                        break;
                                    case "item amount":
                                        system.run(() => {
                                            try {
                                                player
                                                    .getComponent("inventory")
                                                    .container.getSlot(
                                                        player.selectedSlotIndex
                                                    ).amount = Number(
                                                        command
                                                            .split(" ")
                                                            .slice(2)
                                                            .join(" ")
                                                    );
                                            } catch (e) {
                                                console.error(e, e.stack);
                                                player.sendMessageB(
                                                    "§c" + e + e.stack
                                                );
                                            }
                                        });
                                        break;
                                    case "item count":
                                        system.run(() => {
                                            try {
                                                player
                                                    .getComponent("inventory")
                                                    .container.getSlot(
                                                        player.selectedSlotIndex
                                                    ).amount = Number(
                                                        command
                                                            .split(" ")
                                                            .slice(2)
                                                            .join(" ")
                                                    );
                                            } catch (e) {
                                                console.error(e, e.stack);
                                                player.sendMessageB(
                                                    "§c" + e + e.stack
                                                );
                                            }
                                        });
                                        break;
                                    case "item nameTag":
                                        let nameb = command
                                            .split(" ")
                                            .slice(2)
                                            .join(" ")
                                            .escapeCharactersB(true);
                                        if (nameb.e != undefined) {
                                            nameb.e.forEach((e) => {
                                                player.sendMessageB(
                                                    String(e + e.stack)
                                                );
                                            });
                                        }
                                        system.run(() => {
                                            try {
                                                player
                                                    .getComponent("inventory")
                                                    .container.getSlot(
                                                        player.selectedSlotIndex
                                                    ).nameTag = nameb.v;
                                            } catch (e) {
                                                console.error(e, e.stack);
                                                player.sendMessageB(
                                                    "§c" + e + e.stack
                                                );
                                            }
                                        });
                                        break;
                                    default:
                                        eventData.sender.sendMessage(
                                            '§cSyntax error: Unexpected "' +
                                            command
                                                .split(" ")
                                                .slice(1)
                                                .join(" ") +
                                            '": at "\\item >>' +
                                            command
                                                .split(" ")
                                                .slice(1)
                                                .join(" ") +
                                            '<<"'
                                        );
                                        break;
                                }
                            } catch (e) {
                                console.error(e, e.stack);
                                player.sendMessageB(e + e.stack);
                            }
                        }
                    } catch (e) {
                        perror(player, e);
                    }
                }
                break;
            case !!switchTest.match(/^block$$/):
                eventData.cancel = true;
                if (switchTestB.trim().split(" ").length == 1) {
                    player.sendMessageB(
                        `block command format: 
${command.dp}block
${command.dp}block facing get color ...
    ... rgba hex
    ... rgba frac
    ... rgba dec
    ... rgba decr
    ... rgb hex
    ... rgb frac
    ... rgb dec
    ... rgb decr
    ... hsl
    ... hsluv
    ... (hsv|hsb)
    ... hsi
    ... hpluv
    ... AdobeRGB
    ... CIELuv
    ... CIExyY
§c    ... bin (COMING SOON!)§r
§c    ... percent (COMING SOON!)§r
§c    ... cymk (COMING SOON!)§r
${command.dp}block facing get filllevel
§c${command.dp}block facing get liquidtype (COMING SOON!)§r
§c${command.dp}block facing get waterlogged (COMING SOON!)§r
§c${command.dp}block facing get state <stateId: string> (COMING SOON!)§r
§c${command.dp}block facing get states (COMING SOON!)§r
§c${command.dp}block facing get tags (COMING SOON!)§r
§c${command.dp}block facing get component <componentId: {waterContainer}|{lavaContainer}|{snowContainer}|{potionContainer}> (COMING SOON!)§r
${command.dp}block facing set color ...
    ... rgba hex <hexRGBAColor: RRGGBBAA|RGBA>
    ... rgba frac <red: float[min=0.0,max=1.0]> <green: float[min=0.0,max=1.0]> <blue: float[min=0.0,max=1.0]> <alpha: float[min=0.0,max=1.0]>
    ... rgba dec <red: int[min=0,max=255]> <green: int[min=0,max=255]> <blue: int[min=0,max=255]> <alpha: int[min=0,max=255]>
    ... rgba decr <red: float[min=0.0,max=255.0]> <green: float[min=0.0,max=255.0]> <blue: float[min=0.0,max=255.0]> <alpha: float[min=0.0,max=255.0]>
    ... rgb hex <hexRGBAColor: RRGGBB|RGB>
    ... rgb frac <red: float[min=0.0,max=1.0]> <green: float[min=0.0,max=1.0]> <blue: float[min=0.0,max=1.0]>
    ... rgb dec <red: int[min=0,max=255]> <green: int[min=0,max=255]> <blue: int[min=0,max=255]>
    ... rgb decr <red: float[min=0.0,max=255.0]> <green: float[min=0.0,max=255.0]> <blue: float[min=0.0,max=255.0]>
    ... hsl <hue: float[min=0.0,max=360.0]> <saturation: float[min=0.0,max=100.0]> <lightness: float[min=0.0,max=100.0]>
§c    ... hsv <hue: float[min=0.0,max=360.0]> <saturation: float[min=0.0,max=100.0]> <value: float[min=0.0,max=100.0]> (COMING SOON!)
§c    ... hsb <hue: float[min=0.0,max=360.0]> <saturation: float[min=0.0,max=100.0]> <brightness: float[min=0.0,max=100.0]> (COMING SOON!)
§c    ... bin <red: binary> <green: binary> <blue: binary> (COMING SOON!)
§c    ... clear (COMING SOON!)
${command.dp}block facing set filllevel <fillLevel: int[min=0,max=6]>
§c${command.dp}block facing debug (COMING SOON!)§r`
                    );
                    return;
                }
                system.run(() => {
                    const argsa = evaluateParameters(switchTestB, [
                        "presetText",
                        "presetText",
                    ]);
                    switch (argsa.args[1]) {
                        case "~":
                        case "^":
                        case "facing":
                            {
                                const block = player.getBlockFromViewDirection();
                                if (!!!block) {
                                    player.sendError(
                                        '§cYou must be facing a block to use the "facing" sub-command.',
                                        true
                                    );
                                }
                                const argsb = evaluateParameters(argsa.extra, [
                                    "presetText",
                                    "presetText",
                                ]);
                                switch (argsb.args[0]) {
                                    case "get":
                                        switch (argsb.args[1].toLowerCase()) {
                                            case "color":
                                                {
                                                    if (!!!block.block.getComponent(
                                                        "fluidContainer"
                                                    )) {
                                                        throw new Error(
                                                            `This block does not have a waterContainer component.`
                                                        );
                                                    }
                                                    const argsc = evaluateParameters(
                                                        argsb.extra,
                                                        [
                                                            "presetText",
                                                            "presetText",
                                                        ]
                                                    );
                                                    switch (argsc.args[0].toLowerCase()) {
                                                        case "rgba":
                                                            {
                                                                switch (argsc.args[1].toLowerCase()) {
                                                                    case "x":
                                                                    case "hex":
                                                                    case "hexadecimal":
                                                                        {
                                                                            const currentColor = block?.block.getComponent(
                                                                                "fluidContainer"
                                                                            ).fluidColor;
                                                                            player.sendMessageB(
                                                                                `#${(
                                                                                        currentColor.red *
                                                                                        255
                                                                                    )
                                                                                        .toString(
                                                                                            16
                                                                                        )
                                                                                        .split(
                                                                                            "."
                                                                                        )[0]}${(
                                                                                        currentColor.green *
                                                                                        255
                                                                                    )
                                                                                        .toString(
                                                                                            16
                                                                                        )
                                                                                        .split(
                                                                                            "."
                                                                                        )[0]}${(
                                                                                        currentColor.blue *
                                                                                        255
                                                                                    )
                                                                                        .toString(
                                                                                            16
                                                                                        )
                                                                                        .split(
                                                                                            "."
                                                                                        )[0]}${(
                                                                                        currentColor.alpha *
                                                                                        255
                                                                                    )
                                                                                        .toString(
                                                                                            16
                                                                                        )
                                                                                        .split(
                                                                                            "."
                                                                                        )[0]}`.toUpperCase()
                                                                            );
                                                                        }
                                                                        break;
                                                                    case "flt":
                                                                    case "float":
                                                                    case "f":
                                                                    case "frac":
                                                                    case "fractional":
                                                                        {
                                                                            const currentColor = block?.block.getComponent(
                                                                                "fluidContainer"
                                                                            ).fluidColor;
                                                                            player.sendMessageB(
                                                                                `Red: ${currentColor.red}, Green: ${currentColor.green}, Blue: ${currentColor.blue}, Alpha: ${currentColor.alpha}`
                                                                            );
                                                                        }
                                                                        break;
                                                                    case "i":
                                                                    case "int":
                                                                    case "integer":
                                                                    case "d":
                                                                    case "dec":
                                                                    case "decimal":
                                                                        {
                                                                            const currentColor = block?.block.getComponent(
                                                                                "fluidContainer"
                                                                            ).fluidColor;
                                                                            player.sendMessageB(
                                                                                `Red: ${(
                                                                                    currentColor.red *
                                                                                    255
                                                                                ).round()}, Green: ${(
                                                                                    currentColor.green *
                                                                                    255
                                                                                ).round()}, Blue: ${(
                                                                                    currentColor.blue *
                                                                                    255
                                                                                ).round()}, Alpha: ${(
                                                                                    currentColor.alpha *
                                                                                    255
                                                                                ).round()}`
                                                                            );
                                                                        }
                                                                        break;
                                                                    case "ir":
                                                                    case "intr":
                                                                    case "integerr":
                                                                    case "dr":
                                                                    case "decr":
                                                                    case "decimalr":
                                                                        {
                                                                            const currentColor = block?.block.getComponent(
                                                                                "fluidContainer"
                                                                            ).fluidColor;
                                                                            player.sendMessageB(
                                                                                `Red: ${currentColor.red *
                                                                                255}, Green: ${currentColor.green *
                                                                                255}, Blue: ${currentColor.blue *
                                                                                255}, Alpha: ${currentColor.alpha *
                                                                                255}`
                                                                            );
                                                                        }
                                                                        break;
                                                                    default:
                                                                        if ((
                                                                            argsb
                                                                                .args[1] ??
                                                                            ""
                                                                        ).trim() ==
                                                                            "") {
                                                                            player.sendError(
                                                                                `§cSyntax error: Unexpected "": at "${switchTestB.slice(
                                                                                    -10
                                                                                )}>><<"`,
                                                                                true
                                                                            );
                                                                        } else {
                                                                            player.sendError(
                                                                                `§cSyntax error: Unexpected "${argsa
                                                                                    .args[1]}": at "${switchTestB.slice(
                                                                                        switchTestB.indexOf(
                                                                                            argsb
                                                                                                .args[1]
                                                                                        ) -
                                                                                        10,
                                                                                        switchTestB.indexOf(
                                                                                            argsb
                                                                                                .args[1]
                                                                                        )
                                                                                    )}>>${argsb
                                                                                    .args[1]}<<${switchTestB.slice(
                                                                                        switchTestB.indexOf(
                                                                                            argsb
                                                                                                .args[1]
                                                                                        ) +
                                                                                        argsb
                                                                                            .args[1]
                                                                                            .length,
                                                                                        switchTestB.indexOf(
                                                                                            argsb
                                                                                                .args[1]
                                                                                        ) +
                                                                                        argsb
                                                                                            .args[1]
                                                                                            .length +
                                                                                        10
                                                                                    )}"`,
                                                                                true
                                                                            );
                                                                        }
                                                                }
                                                            }
                                                            break;
                                                        case "rgb":
                                                            {
                                                                switch (argsc.args[1].toLowerCase()) {
                                                                    case "x":
                                                                    case "hex":
                                                                    case "hexadecimal":
                                                                        {
                                                                            const currentColor = block?.block.getComponent(
                                                                                "fluidContainer"
                                                                            ).fluidColor;
                                                                            player.sendMessageB(
                                                                                `#${(
                                                                                        currentColor.red *
                                                                                        255
                                                                                    )
                                                                                        .toString(
                                                                                            16
                                                                                        )
                                                                                        .split(
                                                                                            "."
                                                                                        )[0]}${(
                                                                                        currentColor.green *
                                                                                        255
                                                                                    )
                                                                                        .toString(
                                                                                            16
                                                                                        )
                                                                                        .split(
                                                                                            "."
                                                                                        )[0]}${(
                                                                                        currentColor.blue *
                                                                                        255
                                                                                    )
                                                                                        .toString(
                                                                                            16
                                                                                        )
                                                                                        .split(
                                                                                            "."
                                                                                        )[0]}`.toUpperCase()
                                                                            );
                                                                        }
                                                                        break;
                                                                    case "flt":
                                                                    case "float":
                                                                    case "f":
                                                                    case "frac":
                                                                    case "fractional":
                                                                        {
                                                                            const currentColor = block?.block.getComponent(
                                                                                "fluidContainer"
                                                                            ).fluidColor;
                                                                            player.sendMessageB(
                                                                                `Red: ${currentColor.red}, Green: ${currentColor.green}, Blue: ${currentColor.blue}`
                                                                            );
                                                                        }
                                                                        break;
                                                                    case "i":
                                                                    case "int":
                                                                    case "integer":
                                                                    case "d":
                                                                    case "dec":
                                                                    case "decimal":
                                                                        {
                                                                            const currentColor = block?.block.getComponent(
                                                                                "fluidContainer"
                                                                            ).fluidColor;
                                                                            player.sendMessageB(
                                                                                `Red: ${(
                                                                                    currentColor.red *
                                                                                    255
                                                                                ).round()}, Green: ${(
                                                                                    currentColor.green *
                                                                                    255
                                                                                ).round()}, Blue: ${(
                                                                                    currentColor.blue *
                                                                                    255
                                                                                ).round()}`
                                                                            );
                                                                        }
                                                                        break;
                                                                    case "ir":
                                                                    case "intr":
                                                                    case "integerr":
                                                                    case "dr":
                                                                    case "decr":
                                                                    case "decimalr":
                                                                        {
                                                                            const currentColor = block?.block.getComponent(
                                                                                "fluidContainer"
                                                                            ).fluidColor;
                                                                            player.sendMessageB(
                                                                                `Red: ${currentColor.red *
                                                                                255}, Green: ${currentColor.green *
                                                                                255}, Blue: ${currentColor.blue *
                                                                                255}`
                                                                            );
                                                                        }
                                                                        break;
                                                                    default:
                                                                        if ((
                                                                            argsc
                                                                                .args[1] ??
                                                                            ""
                                                                        ).trim() ==
                                                                            "") {
                                                                            player.sendError(
                                                                                `§cSyntax error: Unexpected "": at "${switchTestB.slice(
                                                                                    -10
                                                                                )}>><<"`,
                                                                                true
                                                                            );
                                                                        } else {
                                                                            player.sendError(
                                                                                `§cSyntax error: Unexpected "${argsc
                                                                                    .args[1]}": at "${switchTestB.slice(
                                                                                        switchTestB.indexOf(
                                                                                            argsc
                                                                                                .args[1]
                                                                                        ) -
                                                                                        10,
                                                                                        switchTestB.indexOf(
                                                                                            argsc
                                                                                                .args[1]
                                                                                        )
                                                                                    )}>>${argsc
                                                                                    .args[1]}<<${switchTestB.slice(
                                                                                        switchTestB.indexOf(
                                                                                            argsc
                                                                                                .args[1]
                                                                                        ) +
                                                                                        argsc
                                                                                            .args[1]
                                                                                            .length,
                                                                                        switchTestB.indexOf(
                                                                                            argsc
                                                                                                .args[1]
                                                                                        ) +
                                                                                        argsc
                                                                                            .args[1]
                                                                                            .length +
                                                                                        10
                                                                                    )}"`,
                                                                                true
                                                                            );
                                                                        }
                                                                }
                                                            }
                                                            break;
                                                        case "hsl":
                                                            {
                                                                const currentColor = rgbToHsl(
                                                                    mcRGBAToColorCoreRGB(
                                                                        block?.block.getComponent(
                                                                            "fluidContainer"
                                                                        )
                                                                            .fluidColor
                                                                    )
                                                                );
                                                                player.sendMessageB(
                                                                    `Hue: ${currentColor.h
                                                                        .toPrecision(
                                                                            10
                                                                        )
                                                                        .toNumber()}, Saturation: ${currentColor.s
                                                                            .toPrecision(
                                                                                10
                                                                            )
                                                                            .toNumber()}, Lightness: ${currentColor.l
                                                                                .toPrecision(
                                                                                    10
                                                                                )
                                                                                .toNumber()}, Alpha: ${currentColor.a}`
                                                                );
                                                            }
                                                            break;
                                                        case "hsluv":
                                                            {
                                                                const currentColor = rgbToHSLuv(
                                                                    mcRGBAToColorCoreRGB(
                                                                        block?.block.getComponent(
                                                                            "fluidContainer"
                                                                        )
                                                                            .fluidColor
                                                                    )
                                                                );
                                                                player.sendMessageB(
                                                                    `Hue: ${currentColor.h
                                                                        .toPrecision(
                                                                            10
                                                                        )
                                                                        .toNumber()}, Saturation: ${currentColor.s
                                                                            .toPrecision(
                                                                                10
                                                                            )
                                                                            .toNumber()}, Lightness: ${currentColor.l
                                                                                .toPrecision(
                                                                                    10
                                                                                )
                                                                                .toNumber()}`
                                                                );
                                                            }
                                                            break;
                                                        case "hsv":
                                                            {
                                                                const currentColor = rgbToHsv(
                                                                    mcRGBAToColorCoreRGB(
                                                                        block?.block.getComponent(
                                                                            "fluidContainer"
                                                                        )
                                                                            .fluidColor
                                                                    )
                                                                );
                                                                player.sendMessageB(
                                                                    `Hue: ${currentColor.h
                                                                        .toPrecision(
                                                                            10
                                                                        )
                                                                        .toNumber()}, Saturation: ${currentColor.s
                                                                            .toPrecision(
                                                                                10
                                                                            )
                                                                            .toNumber()}, Value: ${currentColor.v
                                                                                .toPrecision(
                                                                                    10
                                                                                )
                                                                                .toNumber()}, Alpha: ${currentColor.a}`
                                                                );
                                                            }
                                                            break;
                                                        case "hsb":
                                                            {
                                                                const currentColor = rgbToHsv(
                                                                    mcRGBAToColorCoreRGB(
                                                                        block?.block.getComponent(
                                                                            "fluidContainer"
                                                                        )
                                                                            .fluidColor
                                                                    )
                                                                );
                                                                player.sendMessageB(
                                                                    `Hue: ${currentColor.h
                                                                        .toPrecision(
                                                                            10
                                                                        )
                                                                        .toNumber()}, Saturation: ${currentColor.s
                                                                            .toPrecision(
                                                                                10
                                                                            )
                                                                            .toNumber()}, Brightness: ${currentColor.v
                                                                                .toPrecision(
                                                                                    10
                                                                                )
                                                                                .toNumber()}, Alpha: ${currentColor.a}`
                                                                );
                                                            }
                                                            break;
                                                        case "hsi":
                                                            {
                                                                const currentColor = rgbToHsi(
                                                                    mcRGBAToColorCoreRGB(
                                                                        block?.block.getComponent(
                                                                            "fluidContainer"
                                                                        )
                                                                            .fluidColor
                                                                    )
                                                                );
                                                                player.sendMessageB(
                                                                    `Hue: ${currentColor.h
                                                                        .toPrecision(
                                                                            10
                                                                        )
                                                                        .toNumber()}, Saturation: ${currentColor.s
                                                                            .toPrecision(
                                                                                10
                                                                            )
                                                                            .toNumber()}, Intensity: ${currentColor.i
                                                                                .toPrecision(
                                                                                    10
                                                                                )
                                                                                .toNumber()}`
                                                                );
                                                            }
                                                            break;
                                                        case "hpluv":
                                                            {
                                                                const currentColor = rgbToHPLuv(
                                                                    mcRGBAToColorCoreRGB(
                                                                        block?.block.getComponent(
                                                                            "fluidContainer"
                                                                        )
                                                                            .fluidColor
                                                                    )
                                                                );
                                                                player.sendMessageB(
                                                                    `Hue: ${currentColor.h
                                                                        .toPrecision(
                                                                            10
                                                                        )
                                                                        .toNumber()}, Perceived Saturation: ${currentColor.p
                                                                            .toPrecision(
                                                                                10
                                                                            )
                                                                            .toNumber()}, Lightness: ${currentColor.l
                                                                                .toPrecision(
                                                                                    10
                                                                                )
                                                                                .toNumber()}`
                                                                );
                                                            }
                                                            break;
                                                        case "adobergb":
                                                            {
                                                                const currentColor = new Color(
                                                                    mcRGBAToColorCoreRGB(
                                                                        block?.block.getComponent(
                                                                            "fluidContainer"
                                                                        )
                                                                            .fluidColor
                                                                    )
                                                                ).toAdobeRGB();
                                                                player.sendMessageB(
                                                                    `Red: ${currentColor.ar}, Green: ${currentColor.ag}, Blue: ${currentColor.ab}`
                                                                );
                                                            }
                                                            break;
                                                        case "cieluv":
                                                            {
                                                                const currentColor = new Color(
                                                                    mcRGBAToColorCoreRGB(
                                                                        block?.block.getComponent(
                                                                            "fluidContainer"
                                                                        )
                                                                            .fluidColor
                                                                    )
                                                                ).toCIELuv();
                                                                player.sendMessageB(
                                                                    `Lightness: ${currentColor.L}, Chromaticity u: ${currentColor.u}, Chromaticity v: ${currentColor.v}`
                                                                );
                                                            }
                                                            break;
                                                        case "ciexyy":
                                                            {
                                                                const currentColor = new Color(
                                                                    mcRGBAToColorCoreRGB(
                                                                        block?.block.getComponent(
                                                                            "fluidContainer"
                                                                        )
                                                                            .fluidColor
                                                                    )
                                                                ).toCIExyY();
                                                                player.sendMessageB(
                                                                    `Chromaticity x: ${currentColor.x}, Chromaticity y: ${currentColor.y}, Luminance: ${currentColor.Y}`
                                                                );
                                                            }
                                                            break;
                                                        case "rawcolorcorergb":
                                                            {
                                                                const currentColor = mcRGBAToColorCoreRGB(
                                                                    block?.block.getComponent(
                                                                        "fluidContainer"
                                                                    )
                                                                        .fluidColor
                                                                );
                                                                player.sendMessageB(
                                                                    JSONB.stringify(
                                                                        currentColor
                                                                    )
                                                                );
                                                            }
                                                            break;
                                                        default:
                                                            if ((
                                                                argsc
                                                                    .args[0] ??
                                                                ""
                                                            ).trim() == "") {
                                                                player.sendError(
                                                                    `§cSyntax error: Unexpected "": at "${switchTestB.slice(
                                                                        -10
                                                                    )}>><<"`,
                                                                    true
                                                                );
                                                            } else {
                                                                player.sendError(
                                                                    `§cSyntax error: Unexpected "${argsc
                                                                        .args[0]}": at "${switchTestB.slice(
                                                                            switchTestB.indexOf(
                                                                                argsc
                                                                                    .args[0]
                                                                            ) - 10,
                                                                            switchTestB.indexOf(
                                                                                argsc
                                                                                    .args[0]
                                                                            )
                                                                        )}>>${argsc
                                                                        .args[0]}<<${switchTestB.slice(
                                                                            switchTestB.indexOf(
                                                                                argsc
                                                                                    .args[0]
                                                                            ) +
                                                                            argsc
                                                                                .args[0]
                                                                                .length,
                                                                            switchTestB.indexOf(
                                                                                argsc
                                                                                    .args[0]
                                                                            ) +
                                                                            argsc
                                                                                .args[0]
                                                                                .length +
                                                                            10
                                                                        )}"`,
                                                                    true
                                                                );
                                                            }
                                                    }
                                                }
                                                break;
                                            case "filllevel":
                                                player.sendMessageB(
                                                    `Fill Level: ${block?.block.getComponent(
                                                        "fluidContainer"
                                                    ).fillLevel}`
                                                );
                                                break;
                                            case "liquidtype":
                                                /**
                                                 * @todo
                                                 */
                                                player.sendMessageB(
                                                    `Liquid Type: `
                                                );
                                                break;
                                            default:
                                                if ((
                                                    argsb.args[1] ?? ""
                                                ).trim() == "") {
                                                    player.sendError(
                                                        `§cSyntax error: Unexpected "": at "${switchTestB.slice(
                                                            -10
                                                        )}>><<"`,
                                                        true
                                                    );
                                                } else {
                                                    player.sendError(
                                                        `§cSyntax error: Unexpected "${argsa.args[1]}": at "${switchTestB.slice(
                                                            switchTestB.indexOf(
                                                                argsb.args[1]
                                                            ) - 10,
                                                            switchTestB.indexOf(
                                                                argsb.args[1]
                                                            )
                                                        )}>>${argsb.args[1]}<<${switchTestB.slice(
                                                            switchTestB.indexOf(
                                                                argsb.args[1]
                                                            ) +
                                                            argsb.args[1]
                                                                .length,
                                                            switchTestB.indexOf(
                                                                argsb.args[1]
                                                            ) +
                                                            argsb.args[1]
                                                                .length +
                                                            10
                                                        )}"`,
                                                        true
                                                    );
                                                }
                                        }
                                        break;
                                    case "set":
                                        switch (argsb.args[1].toLowerCase()) {
                                            case "color":
                                                {
                                                    if (!!!block.block.getComponent(
                                                        "fluidContainer"
                                                    )) {
                                                        throw new Error(
                                                            `This block does not have a waterContainer component.`
                                                        );
                                                    }
                                                    const argsc = evaluateParameters(
                                                        argsb.extra,
                                                        [
                                                            "presetText",
                                                            "presetText",
                                                        ]
                                                    );
                                                    switch (argsc.args[0].toLowerCase()) {
                                                        case "rgba":
                                                            {
                                                                switch (argsc.args[1].toLowerCase()) {
                                                                    case "x":
                                                                    case "hex":
                                                                    case "hexadecimal":
                                                                        {
                                                                            const rgba = evaluateParameters(
                                                                                argsc.extra,
                                                                                [
                                                                                    "presetText",
                                                                                ]
                                                                            )
                                                                                .args[0];
                                                                            if (!!!rgba) {
                                                                                player.sendError(
                                                                                    `§cSyntax error: Unexpected "": at "${switchTestB.slice(
                                                                                        -10
                                                                                    )}>><<"`,
                                                                                    true
                                                                                );
                                                                                return;
                                                                            }
                                                                            if (![
                                                                                4,
                                                                                8,
                                                                            ].includes(
                                                                                rgba.length
                                                                            )) {
                                                                                player.sendError(
                                                                                    `§cSyntax error: ${rgba} is not a valid RGBA hex code. ${rgba.length ==
                                                                                        3 ||
                                                                                        rgba.length ==
                                                                                        6
                                                                                        ? `If you do not want to specify the alpha channel use RGB mode instead, replace "${switchTestB.slice(
                                                                                            switchTestB
                                                                                                .toLowerCase()
                                                                                                .indexOf(
                                                                                                    "rgba"
                                                                                                ),
                                                                                            switchTestB
                                                                                                .toLowerCase()
                                                                                                .indexOf(
                                                                                                    "rgba"
                                                                                                ) +
                                                                                            4
                                                                                        )}" at "${switchTestB.slice(
                                                                                            switchTestB
                                                                                                .toLowerCase()
                                                                                                .indexOf(
                                                                                                    "rgba"
                                                                                                ) -
                                                                                            10,
                                                                                            switchTestB
                                                                                                .toLowerCase()
                                                                                                .indexOf(
                                                                                                    "rgba"
                                                                                                )
                                                                                        )}>>${switchTestB.slice(
                                                                                            switchTestB
                                                                                                .toLowerCase()
                                                                                                .indexOf(
                                                                                                    "rgba"
                                                                                                ),
                                                                                            switchTestB
                                                                                                .toLowerCase()
                                                                                                .indexOf(
                                                                                                    "rgba"
                                                                                                ) +
                                                                                            4
                                                                                        )}<<${switchTestB.slice(
                                                                                            switchTestB
                                                                                                .toLowerCase()
                                                                                                .indexOf(
                                                                                                    "rgba"
                                                                                                ) +
                                                                                            4,
                                                                                            switchTestB
                                                                                                .toLowerCase()
                                                                                                .indexOf(
                                                                                                    "rgba"
                                                                                                ) +
                                                                                            14
                                                                                        )}" with rgb. `
                                                                                        : ""}A valid RGBA hex code should be formatted either as "RGBA" or "RRGGBBAA". ex. 9AEF or 97A2EBFA.`,
                                                                                    true
                                                                                );
                                                                                return;
                                                                            }
                                                                            const denominator = rgba.length ==
                                                                                4
                                                                                ? 15
                                                                                : 255;
                                                                            const rangeScale = rgba.length ==
                                                                                4
                                                                                ? 1
                                                                                : 2;
                                                                            const currentColor = block?.block.getComponent(
                                                                                "fluidContainer"
                                                                            ).fluidColor;
                                                                            const red = rgba
                                                                                .slice(
                                                                                    0 *
                                                                                    rangeScale,
                                                                                    1 *
                                                                                    rangeScale
                                                                                )
                                                                                .includes(
                                                                                    "~"
                                                                                )
                                                                                ? currentColor.red
                                                                                : parseInt(
                                                                                    rgba.slice(
                                                                                        0 *
                                                                                        rangeScale,
                                                                                        1 *
                                                                                        rangeScale
                                                                                    ),
                                                                                    16
                                                                                ) /
                                                                                denominator;
                                                                            const green = rgba
                                                                                .slice(
                                                                                    1 *
                                                                                    rangeScale,
                                                                                    2 *
                                                                                    rangeScale
                                                                                )
                                                                                .includes(
                                                                                    "~"
                                                                                )
                                                                                ? currentColor.green
                                                                                : parseInt(
                                                                                    rgba.slice(
                                                                                        1 *
                                                                                        rangeScale,
                                                                                        2 *
                                                                                        rangeScale
                                                                                    ),
                                                                                    16
                                                                                ) /
                                                                                denominator;
                                                                            const blue = rgba
                                                                                .slice(
                                                                                    2 *
                                                                                    rangeScale,
                                                                                    3 *
                                                                                    rangeScale
                                                                                )
                                                                                .includes(
                                                                                    "~"
                                                                                )
                                                                                ? currentColor.blue
                                                                                : parseInt(
                                                                                    rgba.slice(
                                                                                        2 *
                                                                                        rangeScale,
                                                                                        3 *
                                                                                        rangeScale
                                                                                    ),
                                                                                    16
                                                                                ) /
                                                                                denominator;
                                                                            const alpha = rgba
                                                                                .slice(
                                                                                    3 *
                                                                                    rangeScale,
                                                                                    4 *
                                                                                    rangeScale
                                                                                )
                                                                                .includes(
                                                                                    "~"
                                                                                )
                                                                                ? currentColor.alpha
                                                                                : parseInt(
                                                                                    rgba.slice(
                                                                                        3 *
                                                                                        rangeScale,
                                                                                        4 *
                                                                                        rangeScale
                                                                                    ),
                                                                                    16
                                                                                ) /
                                                                                denominator;
                                                                            block.block.getComponent(
                                                                                "fluidContainer"
                                                                            ).fluidColor =
                                                                            {
                                                                                red,
                                                                                green,
                                                                                blue,
                                                                                alpha,
                                                                            };
                                                                        }
                                                                        break;
                                                                    case "flt":
                                                                    case "float":
                                                                    case "f":
                                                                    case "frac":
                                                                    case "fractional":
                                                                        {
                                                                            const rgba = evaluateParameters(
                                                                                argsc.extra,
                                                                                [
                                                                                    "presetText",
                                                                                    "presetText",
                                                                                    "presetText",
                                                                                    "presetText",
                                                                                ]
                                                                            ).args;
                                                                            if (rgba.length <
                                                                                4) {
                                                                                player.sendError(
                                                                                    `§cSyntax error: Unexpected "": at "${switchTestB.slice(
                                                                                        -10
                                                                                    )}>><<"`,
                                                                                    true
                                                                                );
                                                                                return;
                                                                            } /*
                                                        if(![4, 8].includes(rgba.length)){
                                                            player.sendError(
                                                                `§cSyntax error: ${rgba} is not a valid RGBA color code. ${(rgba.length==3)||(rgba.length==6)?`If you do not want to specify the alpha channel use RGB mode instead, replace "${
                                                                    switchTestB.slice(
                                                                        switchTestB.toLowerCase().indexOf("rgba"),
                                                                        switchTestB.toLowerCase().indexOf("rgba")+4
                                                                    )
                                                                }" at "${
                                                                    switchTestB.slice(
                                                                        switchTestB.toLowerCase().indexOf("rgba")-10,
                                                                        switchTestB.toLowerCase().indexOf("rgba")
                                                                    )
                                                                }>>${
                                                                    switchTestB.slice(
                                                                        switchTestB.toLowerCase().indexOf("rgba"),
                                                                        switchTestB.toLowerCase().indexOf("rgba")+4
                                                                    )
                                                                }<<${
                                                                    switchTestB.slice(
                                                                        switchTestB.toLowerCase().indexOf("rgba")+4,
                                                                        switchTestB.toLowerCase().indexOf("rgba")+14
                                                                    )
                                                                }" with rgb. `:""}A valid RGBA hex code should be formatted either as "RGBA" or "RRGGBBAA". ex. 9AEF or 97A2EBFA.`,
                                                                true
                                                            )
                                                        }*/


























                                                                            const currentColor = block?.block.getComponent(
                                                                                "fluidContainer"
                                                                            ).fluidColor;
                                                                            const red = (
                                                                                rgba[0].trim() ==
                                                                                    "~"
                                                                                    ? currentColor.red
                                                                                    : rgba[0]
                                                                            ).toNumber();
                                                                            const green = (
                                                                                rgba[1].trim() ==
                                                                                    "~"
                                                                                    ? currentColor.green
                                                                                    : rgba[1]
                                                                            ).toNumber();
                                                                            const blue = (
                                                                                rgba[2].trim() ==
                                                                                    "~"
                                                                                    ? currentColor.blue
                                                                                    : rgba[2]
                                                                            ).toNumber();
                                                                            const alpha = (
                                                                                rgba[3].trim() ==
                                                                                    "~"
                                                                                    ? currentColor.alpha
                                                                                    : rgba[3]
                                                                            ).toNumber();
                                                                            block.block.getComponent(
                                                                                "fluidContainer"
                                                                            ).fluidColor =
                                                                            {
                                                                                red,
                                                                                green,
                                                                                blue,
                                                                                alpha,
                                                                            };
                                                                        }
                                                                        break;
                                                                    case "i":
                                                                    case "int":
                                                                    case "integer":
                                                                    case "d":
                                                                    case "dec":
                                                                    case "decimal":
                                                                        {
                                                                            const rgba = evaluateParameters(
                                                                                argsc.extra,
                                                                                [
                                                                                    "presetText",
                                                                                    "presetText",
                                                                                    "presetText",
                                                                                    "presetText",
                                                                                ]
                                                                            ).args;
                                                                            if (rgba.length <
                                                                                4) {
                                                                                player.sendError(
                                                                                    `§cSyntax error: Unexpected "": at "${switchTestB.slice(
                                                                                        -10
                                                                                    )}>><<"`,
                                                                                    true
                                                                                );
                                                                                return;
                                                                            } /*
                                                        if(![4, 8].includes(rgba.length)){
                                                            player.sendError(
                                                                `§cSyntax error: ${rgba} is not a valid RGBA color code. ${(rgba.length==3)||(rgba.length==6)?`If you do not want to specify the alpha channel use RGB mode instead, replace "${
                                                                    switchTestB.slice(
                                                                        switchTestB.toLowerCase().indexOf("rgba"),
                                                                        switchTestB.toLowerCase().indexOf("rgba")+4
                                                                    )
                                                                }" at "${
                                                                    switchTestB.slice(
                                                                        switchTestB.toLowerCase().indexOf("rgba")-10,
                                                                        switchTestB.toLowerCase().indexOf("rgba")
                                                                    )
                                                                }>>${
                                                                    switchTestB.slice(
                                                                        switchTestB.toLowerCase().indexOf("rgba"),
                                                                        switchTestB.toLowerCase().indexOf("rgba")+4
                                                                    )
                                                                }<<${
                                                                    switchTestB.slice(
                                                                        switchTestB.toLowerCase().indexOf("rgba")+4,
                                                                        switchTestB.toLowerCase().indexOf("rgba")+14
                                                                    )
                                                                }" with rgb. `:""}A valid RGBA hex code should be formatted either as "RGBA" or "RRGGBBAA". ex. 9AEF or 97A2EBFA.`,
                                                                true
                                                            )
                                                        }*/


























                                                                            const currentColor = block?.block.getComponent(
                                                                                "fluidContainer"
                                                                            ).fluidColor;
                                                                            const red = rgba[0].trim() ==
                                                                                "~"
                                                                                ? currentColor.red
                                                                                : rgba[0]
                                                                                    .toNumber()
                                                                                    .round() /
                                                                                255;
                                                                            const green = rgba[1].trim() ==
                                                                                "~"
                                                                                ? currentColor.green
                                                                                : rgba[1]
                                                                                    .toNumber()
                                                                                    .round() /
                                                                                255;
                                                                            const blue = rgba[2].trim() ==
                                                                                "~"
                                                                                ? currentColor.blue
                                                                                : rgba[2]
                                                                                    .toNumber()
                                                                                    .round() /
                                                                                255;
                                                                            const alpha = rgba[3].trim() ==
                                                                                "~"
                                                                                ? currentColor.alpha
                                                                                : rgba[3]
                                                                                    .toNumber()
                                                                                    .round() /
                                                                                255;
                                                                            block.block.getComponent(
                                                                                "fluidContainer"
                                                                            ).fluidColor =
                                                                            {
                                                                                red,
                                                                                green,
                                                                                blue,
                                                                                alpha,
                                                                            };
                                                                        }
                                                                        break;
                                                                    case "ir":
                                                                    case "intr":
                                                                    case "integerr":
                                                                    case "dr":
                                                                    case "decr":
                                                                    case "decimalr":
                                                                        {
                                                                            const rgba = evaluateParameters(
                                                                                argsc.extra,
                                                                                [
                                                                                    "presetText",
                                                                                    "presetText",
                                                                                    "presetText",
                                                                                    "presetText",
                                                                                ]
                                                                            ).args;
                                                                            if (rgba.length <
                                                                                4) {
                                                                                player.sendError(
                                                                                    `§cSyntax error: Unexpected "": at "${switchTestB.slice(
                                                                                        -10
                                                                                    )}>><<"`,
                                                                                    true
                                                                                );
                                                                                return;
                                                                            } /*
                                                        if(![4, 8].includes(rgba.length)){
                                                            player.sendError(
                                                                `§cSyntax error: ${rgba} is not a valid RGBA color code. ${(rgba.length==3)||(rgba.length==6)?`If you do not want to specify the alpha channel use RGB mode instead, replace "${
                                                                    switchTestB.slice(
                                                                        switchTestB.toLowerCase().indexOf("rgba"),
                                                                        switchTestB.toLowerCase().indexOf("rgba")+4
                                                                    )
                                                                }" at "${
                                                                    switchTestB.slice(
                                                                        switchTestB.toLowerCase().indexOf("rgba")-10,
                                                                        switchTestB.toLowerCase().indexOf("rgba")
                                                                    )
                                                                }>>${
                                                                    switchTestB.slice(
                                                                        switchTestB.toLowerCase().indexOf("rgba"),
                                                                        switchTestB.toLowerCase().indexOf("rgba")+4
                                                                    )
                                                                }<<${
                                                                    switchTestB.slice(
                                                                        switchTestB.toLowerCase().indexOf("rgba")+4,
                                                                        switchTestB.toLowerCase().indexOf("rgba")+14
                                                                    )
                                                                }" with rgb. `:""}A valid RGBA hex code should be formatted either as "RGBA" or "RRGGBBAA". ex. 9AEF or 97A2EBFA.`,
                                                                true
                                                            )
                                                        }*/


























                                                                            const currentColor = block?.block.getComponent(
                                                                                "fluidContainer"
                                                                            ).fluidColor;
                                                                            const red = rgba[0].trim() ==
                                                                                "~"
                                                                                ? currentColor.red
                                                                                : rgba[0].toNumber() /
                                                                                255;
                                                                            const green = rgba[1].trim() ==
                                                                                "~"
                                                                                ? currentColor.green
                                                                                : rgba[1].toNumber() /
                                                                                255;
                                                                            const blue = rgba[2].trim() ==
                                                                                "~"
                                                                                ? currentColor.blue
                                                                                : rgba[2].toNumber() /
                                                                                255;
                                                                            const alpha = rgba[3].trim() ==
                                                                                "~"
                                                                                ? currentColor.alpha
                                                                                : rgba[3].toNumber() /
                                                                                255;
                                                                            block.block.getComponent(
                                                                                "fluidContainer"
                                                                            ).fluidColor =
                                                                            {
                                                                                red,
                                                                                green,
                                                                                blue,
                                                                                alpha,
                                                                            };
                                                                        }
                                                                        break;
                                                                    default:
                                                                }
                                                            }
                                                            break;
                                                        case "rgb":
                                                            {
                                                                switch (argsc.args[1].toLowerCase()) {
                                                                    case "x":
                                                                    case "hex":
                                                                    case "hexadecimal":
                                                                        {
                                                                            const rgb = evaluateParameters(
                                                                                argsc.extra,
                                                                                [
                                                                                    "presetText",
                                                                                ]
                                                                            )
                                                                                .args[0];
                                                                            if (!!!rgb) {
                                                                                player.sendError(
                                                                                    `§cSyntax error: Unexpected "": at "${switchTestB.slice(
                                                                                        -10
                                                                                    )}>><<"`,
                                                                                    true
                                                                                );
                                                                            }
                                                                            if (![
                                                                                3,
                                                                                6,
                                                                            ].includes(
                                                                                rgb.length
                                                                            )) {
                                                                                player.sendError(
                                                                                    `§cSyntax error: ${rgb} is not a valid RGBA hex code. ${rgb.length ==
                                                                                        4 ||
                                                                                        rgb.length ==
                                                                                        8
                                                                                        ? `If you want to specify the alpha channel use RGBA mode instead, replace "${switchTestB.slice(
                                                                                            switchTestB
                                                                                                .toLowerCase()
                                                                                                .indexOf(
                                                                                                    "rgb"
                                                                                                ),
                                                                                            switchTestB
                                                                                                .toLowerCase()
                                                                                                .indexOf(
                                                                                                    "rgb"
                                                                                                ) +
                                                                                            3
                                                                                        )}" at "${switchTestB.slice(
                                                                                            switchTestB
                                                                                                .toLowerCase()
                                                                                                .indexOf(
                                                                                                    "rgb"
                                                                                                ) -
                                                                                            10,
                                                                                            switchTestB
                                                                                                .toLowerCase()
                                                                                                .indexOf(
                                                                                                    "rgb"
                                                                                                )
                                                                                        )}>>${switchTestB.slice(
                                                                                            switchTestB
                                                                                                .toLowerCase()
                                                                                                .indexOf(
                                                                                                    "rgb"
                                                                                                ),
                                                                                            switchTestB
                                                                                                .toLowerCase()
                                                                                                .indexOf(
                                                                                                    "rgb"
                                                                                                ) +
                                                                                            3
                                                                                        )}<<${switchTestB.slice(
                                                                                            switchTestB
                                                                                                .toLowerCase()
                                                                                                .indexOf(
                                                                                                    "rgb"
                                                                                                ) +
                                                                                            3,
                                                                                            switchTestB
                                                                                                .toLowerCase()
                                                                                                .indexOf(
                                                                                                    "rgb"
                                                                                                ) +
                                                                                            13
                                                                                        )}" with rgba. `
                                                                                        : ""}A valid RGB hex code should be formatted either as "RGB" or "RRGGBB". ex. 9AE or 97A2EB.`,
                                                                                    true
                                                                                );
                                                                            }
                                                                            const denominator = rgb.length ==
                                                                                3
                                                                                ? 15
                                                                                : 255;
                                                                            const rangeScale = rgb.length ==
                                                                                3
                                                                                ? 1
                                                                                : 2;
                                                                            const currentColor = block?.block.getComponent(
                                                                                "fluidContainer"
                                                                            ).fluidColor;
                                                                            const red = rgb
                                                                                .slice(
                                                                                    0 *
                                                                                    rangeScale,
                                                                                    1 *
                                                                                    rangeScale
                                                                                )
                                                                                .includes(
                                                                                    "~"
                                                                                )
                                                                                ? currentColor.red
                                                                                : parseInt(
                                                                                    rgb.slice(
                                                                                        0 *
                                                                                        rangeScale,
                                                                                        1 *
                                                                                        rangeScale
                                                                                    ),
                                                                                    16
                                                                                ) /
                                                                                denominator;
                                                                            const green = rgb
                                                                                .slice(
                                                                                    1 *
                                                                                    rangeScale,
                                                                                    2 *
                                                                                    rangeScale
                                                                                )
                                                                                .includes(
                                                                                    "~"
                                                                                )
                                                                                ? currentColor.green
                                                                                : parseInt(
                                                                                    rgb.slice(
                                                                                        1 *
                                                                                        rangeScale,
                                                                                        2 *
                                                                                        rangeScale
                                                                                    ),
                                                                                    16
                                                                                ) /
                                                                                denominator;
                                                                            const blue = rgb
                                                                                .slice(
                                                                                    2 *
                                                                                    rangeScale,
                                                                                    3 *
                                                                                    rangeScale
                                                                                )
                                                                                .includes(
                                                                                    "~"
                                                                                )
                                                                                ? currentColor.blue
                                                                                : parseInt(
                                                                                    rgb.slice(
                                                                                        2 *
                                                                                        rangeScale,
                                                                                        3 *
                                                                                        rangeScale
                                                                                    ),
                                                                                    16
                                                                                ) /
                                                                                denominator;
                                                                            block.block.getComponent(
                                                                                "fluidContainer"
                                                                            ).fluidColor =
                                                                            {
                                                                                red,
                                                                                green,
                                                                                blue,
                                                                                alpha: 1,
                                                                            };
                                                                        }
                                                                        break;
                                                                    case "flt":
                                                                    case "float":
                                                                    case "f":
                                                                    case "frac":
                                                                    case "fractional":
                                                                        {
                                                                            const rgba = evaluateParameters(
                                                                                argsc.extra,
                                                                                [
                                                                                    "presetText",
                                                                                    "presetText",
                                                                                    "presetText",
                                                                                ]
                                                                            ).args;
                                                                            if (rgba.length <
                                                                                3) {
                                                                                player.sendError(
                                                                                    `§cSyntax error: Unexpected "": at "${switchTestB.slice(
                                                                                        -10
                                                                                    )}>><<"`,
                                                                                    true
                                                                                );
                                                                            } /*
                                                        if(![4, 8].includes(rgba.length)){
                                                            player.sendError(
                                                                `§cSyntax error: ${rgba} is not a valid RGBA color code. ${(rgba.length==3)||(rgba.length==6)?`If you do not want to specify the alpha channel use RGB mode instead, replace "${
                                                                    switchTestB.slice(
                                                                        switchTestB.toLowerCase().indexOf("rgba"),
                                                                        switchTestB.toLowerCase().indexOf("rgba")+4
                                                                    )
                                                                }" at "${
                                                                    switchTestB.slice(
                                                                        switchTestB.toLowerCase().indexOf("rgba")-10,
                                                                        switchTestB.toLowerCase().indexOf("rgba")
                                                                    )
                                                                }>>${
                                                                    switchTestB.slice(
                                                                        switchTestB.toLowerCase().indexOf("rgba"),
                                                                        switchTestB.toLowerCase().indexOf("rgba")+4
                                                                    )
                                                                }<<${
                                                                    switchTestB.slice(
                                                                        switchTestB.toLowerCase().indexOf("rgba")+4,
                                                                        switchTestB.toLowerCase().indexOf("rgba")+14
                                                                    )
                                                                }" with rgb. `:""}A valid RGBA hex code should be formatted either as "RGBA" or "RRGGBBAA". ex. 9AEF or 97A2EBFA.`,
                                                                true
                                                            )
                                                        }*/


























                                                                            const currentColor = block?.block.getComponent(
                                                                                "fluidContainer"
                                                                            ).fluidColor;
                                                                            const red = (
                                                                                rgba[0].trim() ==
                                                                                    "~"
                                                                                    ? currentColor.red
                                                                                    : rgba[0]
                                                                            ).toNumber();
                                                                            const green = (
                                                                                rgba[1].trim() ==
                                                                                    "~"
                                                                                    ? currentColor.green
                                                                                    : rgba[1]
                                                                            ).toNumber();
                                                                            const blue = (
                                                                                rgba[2].trim() ==
                                                                                    "~"
                                                                                    ? currentColor.blue
                                                                                    : rgba[2]
                                                                            ).toNumber();
                                                                            block.block.getComponent(
                                                                                "fluidContainer"
                                                                            ).fluidColor =
                                                                            {
                                                                                red,
                                                                                green,
                                                                                blue,
                                                                                alpha: 1,
                                                                            };
                                                                        }
                                                                        break;
                                                                    case "i":
                                                                    case "int":
                                                                    case "integer":
                                                                    case "d":
                                                                    case "dec":
                                                                    case "decimal":
                                                                        {
                                                                            const rgba = evaluateParameters(
                                                                                argsc.extra,
                                                                                [
                                                                                    "presetText",
                                                                                    "presetText",
                                                                                    "presetText",
                                                                                ]
                                                                            ).args;
                                                                            if (rgba.length <
                                                                                3) {
                                                                                player.sendError(
                                                                                    `§cSyntax error: Unexpected "": at "${switchTestB.slice(
                                                                                        -10
                                                                                    )}>><<"`,
                                                                                    true
                                                                                );
                                                                            } /*
                                                        if(![4, 8].includes(rgba.length)){
                                                            player.sendError(
                                                                `§cSyntax error: ${rgba} is not a valid RGBA color code. ${(rgba.length==3)||(rgba.length==6)?`If you do not want to specify the alpha channel use RGB mode instead, replace "${
                                                                    switchTestB.slice(
                                                                        switchTestB.toLowerCase().indexOf("rgba"),
                                                                        switchTestB.toLowerCase().indexOf("rgba")+4
                                                                    )
                                                                }" at "${
                                                                    switchTestB.slice(
                                                                        switchTestB.toLowerCase().indexOf("rgba")-10,
                                                                        switchTestB.toLowerCase().indexOf("rgba")
                                                                    )
                                                                }>>${
                                                                    switchTestB.slice(
                                                                        switchTestB.toLowerCase().indexOf("rgba"),
                                                                        switchTestB.toLowerCase().indexOf("rgba")+4
                                                                    )
                                                                }<<${
                                                                    switchTestB.slice(
                                                                        switchTestB.toLowerCase().indexOf("rgba")+4,
                                                                        switchTestB.toLowerCase().indexOf("rgba")+14
                                                                    )
                                                                }" with rgb. `:""}A valid RGBA hex code should be formatted either as "RGBA" or "RRGGBBAA". ex. 9AEF or 97A2EBFA.`,
                                                                true
                                                            )
                                                        }*/


























                                                                            const currentColor = block?.block.getComponent(
                                                                                "fluidContainer"
                                                                            ).fluidColor;
                                                                            const red = rgba[0].trim() ==
                                                                                "~"
                                                                                ? currentColor.red
                                                                                : rgba[0]
                                                                                    .toNumber()
                                                                                    .round() /
                                                                                255;
                                                                            const green = rgba[1].trim() ==
                                                                                "~"
                                                                                ? currentColor.green
                                                                                : rgba[1]
                                                                                    .toNumber()
                                                                                    .round() /
                                                                                255;
                                                                            const blue = rgba[2].trim() ==
                                                                                "~"
                                                                                ? currentColor.blue
                                                                                : rgba[2]
                                                                                    .toNumber()
                                                                                    .round() /
                                                                                255;
                                                                            block.block.getComponent(
                                                                                "fluidContainer"
                                                                            ).fluidColor =
                                                                            {
                                                                                red,
                                                                                green,
                                                                                blue,
                                                                                alpha: 1,
                                                                            };
                                                                        }
                                                                        break;
                                                                    default:
                                                                        if ((
                                                                            argsc
                                                                                .args[1] ??
                                                                            ""
                                                                        ).trim() ==
                                                                            "") {
                                                                            player.sendError(
                                                                                `§cSyntax error: Unexpected "": at "${switchTestB.slice(
                                                                                    -10
                                                                                )}>><<"`,
                                                                                true
                                                                            );
                                                                        } else {
                                                                            player.sendError(
                                                                                `§cSyntax error: Unexpected "${argsc
                                                                                    .args[1]}": at "${switchTestB.slice(
                                                                                        switchTestB.indexOf(
                                                                                            argsc
                                                                                                .args[1]
                                                                                        ) -
                                                                                        10,
                                                                                        switchTestB.indexOf(
                                                                                            argsc
                                                                                                .args[1]
                                                                                        )
                                                                                    )}>>${argsc
                                                                                    .args[1]}<<${switchTestB.slice(
                                                                                        switchTestB.indexOf(
                                                                                            argsc
                                                                                                .args[1]
                                                                                        ) +
                                                                                        argsc
                                                                                            .args[1]
                                                                                            .length,
                                                                                        switchTestB.indexOf(
                                                                                            argsc
                                                                                                .args[1]
                                                                                        ) +
                                                                                        argsc
                                                                                            .args[1]
                                                                                            .length +
                                                                                        10
                                                                                    )}"`,
                                                                                true
                                                                            );
                                                                        }
                                                                }
                                                            }
                                                            break;
                                                        case "hsl":
                                                            {
                                                                const hsl = evaluateParameters(
                                                                    argsc.extra,
                                                                    [
                                                                        "number",
                                                                        "number",
                                                                        "number",
                                                                    ]
                                                                ).args;
                                                                if (hsl.length <
                                                                    3) {
                                                                    player.sendError(
                                                                        `§cSyntax error: Unexpected "": at "${switchTestB.slice(
                                                                            -10
                                                                        )}>><<"`,
                                                                        true
                                                                    );
                                                                    return;
                                                                }
                                                                const currentColor = block?.block.getComponent(
                                                                    "fluidContainer"
                                                                ).fluidColor;
                                                                const hslB = HSLToRGB(
                                                                    ...hsl
                                                                );
                                                                const [
                                                                    red, green, blue,
                                                                ] = hslB;
                                                                block.block.getComponent(
                                                                    "fluidContainer"
                                                                ).fluidColor = {
                                                                    red: red /
                                                                        255,
                                                                    green: green /
                                                                        255,
                                                                    blue: blue /
                                                                        255,
                                                                    alpha: currentColor.alpha,
                                                                };
                                                            }
                                                            break;
                                                        /**
                                                         * @todo HSL, HSV/HSB, BINARY, PERCENT, CYMK
                                                         */
                                                        default:
                                                            if ((
                                                                argsc
                                                                    .args[0] ??
                                                                ""
                                                            ).trim() == "") {
                                                                player.sendError(
                                                                    `§cSyntax error: Unexpected "": at "${switchTestB.slice(
                                                                        -10
                                                                    )}>><<"`,
                                                                    true
                                                                );
                                                            } else {
                                                                player.sendError(
                                                                    `§cSyntax error: Unexpected "${argsc
                                                                        .args[0]}": at "${switchTestB.slice(
                                                                            switchTestB.indexOf(
                                                                                argsc
                                                                                    .args[0]
                                                                            ) - 10,
                                                                            switchTestB.indexOf(
                                                                                argsc
                                                                                    .args[0]
                                                                            )
                                                                        )}>>${argsc
                                                                        .args[0]}<<${switchTestB.slice(
                                                                            switchTestB.indexOf(
                                                                                argsc
                                                                                    .args[0]
                                                                            ) +
                                                                            argsc
                                                                                .args[0]
                                                                                .length,
                                                                            switchTestB.indexOf(
                                                                                argsc
                                                                                    .args[0]
                                                                            ) +
                                                                            argsc
                                                                                .args[0]
                                                                                .length +
                                                                            10
                                                                        )}"`,
                                                                    true
                                                                );
                                                            }
                                                    }
                                                }
                                                break;
                                            /**
                                             * @todo
                                             */
                                            case "filllevel":
                                                {
                                                    if (!!!block.block.getComponent(
                                                        "fluidContainer"
                                                    )) {
                                                        throw new Error(
                                                            `This block does not have any fluid container components.`
                                                        );
                                                    }
                                                    const argsc = evaluateParameters(
                                                        argsb.extra,
                                                        ["presetText"]
                                                    );
                                                    block.block.getComponent(
                                                        "fluidContainer"
                                                    ).fillLevel =
                                                        argsc.args[0].toNumber();
                                                }
                                                break;
                                            /**
                                             * @todo
                                             */
                                            case "liquidtype":
                                                break;
                                            default:
                                                if ((
                                                    argsb.args[1] ?? ""
                                                ).trim() == "") {
                                                    player.sendError(
                                                        `§cSyntax error: Unexpected "": at "${switchTestB.slice(
                                                            -10
                                                        )}>><<"`,
                                                        true
                                                    );
                                                } else {
                                                    player.sendError(
                                                        `§cSyntax error: Unexpected "${argsa.args[1]}": at "${switchTestB.slice(
                                                            switchTestB.indexOf(
                                                                argsb.args[1]
                                                            ) - 10,
                                                            switchTestB.indexOf(
                                                                argsb.args[1]
                                                            )
                                                        )}>>${argsb.args[1]}<<${switchTestB.slice(
                                                            switchTestB.indexOf(
                                                                argsb.args[1]
                                                            ) +
                                                            argsb.args[1]
                                                                .length,
                                                            switchTestB.indexOf(
                                                                argsb.args[1]
                                                            ) +
                                                            argsb.args[1]
                                                                .length +
                                                            10
                                                        )}"`,
                                                        true
                                                    );
                                                }
                                        }
                                        break;
                                    /**
                                     * @todo
                                     */
                                    case "debug":
                                        break;
                                    default:
                                        if ((argsb.args[0] ?? "").trim() == "") {
                                            player.sendError(
                                                `§cSyntax error: Unexpected "": at "${switchTestB.slice(
                                                    -10
                                                )}>><<"`,
                                                true
                                            );
                                        } else {
                                            player.sendError(
                                                `§cSyntax error: Unexpected "${argsb.args[0]}": at "${switchTestB.slice(
                                                    switchTestB.indexOf(
                                                        argsb.args[0]
                                                    ) - 10,
                                                    switchTestB.indexOf(
                                                        argsb.args[0]
                                                    )
                                                )}>>${argsb.args[0]}<<${switchTestB.slice(
                                                    switchTestB.indexOf(
                                                        argsb.args[0]
                                                    ) + argsb.args[0].length,
                                                    switchTestB.indexOf(
                                                        argsb.args[0]
                                                    ) +
                                                    argsb.args[0].length +
                                                    10
                                                )}"`,
                                                true
                                            );
                                        }
                                }
                            }
                            break;
                        default:
                            if ((argsa.args[1] ?? "").trim() == "") {
                                player.sendError(
                                    `§cSyntax error: Unexpected "": at "${switchTestB.slice(
                                        -10
                                    )}>><<"`,
                                    true
                                );
                            } else {
                                player.sendError(
                                    `§cSyntax error: Unexpected "${argsa.args[1]}": at "${switchTestB.slice(
                                        switchTestB.indexOf(argsa.args[1]) - 10,
                                        switchTestB.indexOf(argsa.args[1])
                                    )}>>${argsa.args[1]}<<${switchTestB.slice(
                                        switchTestB.indexOf(argsa.args[1]) +
                                        argsa.args[1].length,
                                        switchTestB.indexOf(argsa.args[1]) +
                                        argsa.args[1].length +
                                        10
                                    )}"`,
                                    true
                                );
                            }
                    }
                });
                break;
            case !!switchTest.match(/^gmc$/):
                eventData.cancel = true;
                try {
                    player.runCommandAsync("/gamemode c");
                } catch (e) {
                    player.sendError("§c" + e + e.stack, true);
                }
                system.run(() => {
                    targetSelectorAllListE(
                        "@a [tag=canSeeCustomChatCommandFeedbackFromMods]",
                        player.location.x +
                        " " +
                        player.location.y +
                        " " +
                        player.location.z
                    ).forEach((entity) => {
                        (entity as Player).sendMessage(
                            String(
                                "{§l§dCMDFEED§r§f}[" +
                                player.name +
                                "§r§f]: Set gamemode to creative. "
                            )
                        );
                    });
                });
                break;
            case !!switchTest.match(/^gms$/):
                eventData.cancel = true;
                try {
                    player.runCommandAsync("/gamemode s");
                } catch (e) {
                    player.sendError("§c" + e + e.stack, true);
                }
                system.run(() => {
                    targetSelectorAllListE(
                        "@a [tag=canSeeCustomChatCommandFeedbackFromMods]",
                        player.location.x +
                        " " +
                        player.location.y +
                        " " +
                        player.location.z
                    ).forEach((entity) => {
                        (entity as Player).sendMessage(
                            String(
                                "{§l§dCMDFEED§r§f}[" +
                                player.name +
                                "§r§f]: Set gamemode to survival. "
                            )
                        );
                    });
                });
                break;
            case !!switchTest.match(/^gma$/):
                eventData.cancel = true;
                try {
                    player.runCommandAsync("/gamemode a");
                } catch (e) {
                    player.sendError("§c" + e + e.stack, true);
                }
                system.run(() => {
                    targetSelectorAllListE(
                        "@a [tag=canSeeCustomChatCommandFeedbackFromMods]",
                        player.location.x +
                        " " +
                        player.location.y +
                        " " +
                        player.location.z
                    ).forEach((entity) => {
                        (entity as Player).sendMessage(
                            String(
                                "{§l§dCMDFEED§r§f}[" +
                                player.name +
                                "§r§f]: Set gamemode to adventure. "
                            )
                        );
                    });
                });
                break;
            case !!switchTest.match(/^gmd$/):
                eventData.cancel = true;
                try {
                    player.runCommandAsync("/gamemode d");
                } catch (e) {
                    player.sendError("§c" + e + e.stack, true);
                }
                system.run(() => {
                    targetSelectorAllListE(
                        "@a [tag=canSeeCustomChatCommandFeedbackFromMods]",
                        player.location.x +
                        " " +
                        player.location.y +
                        " " +
                        player.location.z
                    ).forEach((entity) => {
                        (entity as Player).sendMessage(
                            String(
                                "{§l§dCMDFEED§r§f}[" +
                                player.name +
                                "§r§f]: Set gamemode to default. "
                            )
                        );
                    });
                });
                break;
            case !!switchTest.match(/^gmp$/):
                eventData.cancel = true;
                try {
                    player.runCommandAsync("/gamemode spectator");
                } catch (e) {
                    player.sendError("§c" + e + e.stack, true);
                }
                system.run(() => {
                    targetSelectorAllListE(
                        "@a [tag=canSeeCustomChatCommandFeedbackFromMods]",
                        player.location.x +
                        " " +
                        player.location.y +
                        " " +
                        player.location.z
                    ).forEach((entity) => {
                        (entity as Player).sendMessage(
                            String(
                                "{§l§dCMDFEED§r§f}[" +
                                player.name +
                                "§r§f]: Set gamemode to spectator. "
                            )
                        );
                    });
                });
                break;
            case !!switchTest.match(/^gmr$/):
                eventData.cancel = true;
                switch (Math.round(Math.random() * 4)) {
                    case 0:
                        try {
                            player.runCommandAsync("/gamemode c");
                        } catch (e) {
                            player.sendError("§c" + e + e.stack, true);
                        }
                        break;
                    case 1:
                        try {
                            player.runCommandAsync("/gamemode s");
                        } catch (e) {
                            player.sendError("§c" + e + e.stack, true);
                        }
                        break;
                    case 2:
                        try {
                            player.runCommandAsync("/gamemode a");
                        } catch (e) {
                            player.sendError("§c" + e + e.stack, true);
                        }
                        break;
                    case 3:
                        try {
                            player.runCommandAsync("/gamemode d");
                        } catch (e) {
                            player.sendError("§c" + e + e.stack, true);
                        }
                        break;
                    case 4:
                        try {
                            player.runCommandAsync("/gamemode spectator");
                        } catch (e) {
                            player.sendError("§c" + e + e.stack, true);
                        }
                        break;
                } /*
            try{player.runCommandAsync("/gamemode random")}catch(e){player.sendError("§c" + e + e.stack, true)}*/

                system.run(() => {
                    targetSelectorAllListE(
                        "@a [tag=canSeeCustomChatCommandFeedbackFromMods]",
                        player.location.x +
                        " " +
                        player.location.y +
                        " " +
                        player.location.z
                    ).forEach((entity) => {
                        (entity as Player).sendMessage(
                            String(
                                "{§l§dCMDFEED§r§f}[" +
                                player.name +
                                "§r§f]: Set gamemode to random. "
                            )
                        );
                    });
                });
                break; /*
    case !!switchTest.match(/^settings$/):
        eventData.cancel = true;
        switch (Math.min(newMessage.split(" ").length, 3)){
            case 3:
                try{player.runCommandAsync("/scriptevent andexdb:setWorldDynamicPropertyB " + newMessage.slice(10).split(" ")[0] + "|" + newMessage.slice(newMessage.split(" ")[1].length+10))}catch(e){player.sendError("§c" + e + e.stack, true)}
                try{eventData.sender.sendMessage("Set " + newMessage.split(" ")[1] + " to " + newMessage.slice(newMessage.split(" ")[1].length+10)); }catch(e){player.sendError("§c" + e + e.stack, true)}
            break;
            case 2:
                try{eventData.sender.sendMessage("Setting " + newMessage.split(" ")[1] + ": " + world.getDynamicProperty(newMessage.split(" ")[1])); }catch(e){player.sendError("§c" + e + e.stack, true)}
            break;
        }
    break; */












            case !!switchTest.match(/^enderchest$/):
                eventData.cancel = true;
                try {
                    player.runCommandAsync("/setblock ~~~ ender_chest");
                } catch (e) {
                    player.sendError("§c" + e + e.stack, true);
                }
                system.run(() => {
                    targetSelectorAllListE(
                        "@a [tag=canSeeCustomChatCommandFeedbackFromMods]",
                        player.location.x +
                        " " +
                        player.location.y +
                        " " +
                        player.location.z
                    ).forEach((entity) => {
                        (entity as Player).sendMessage(
                            String(
                                "{§l§dCMDFEED§r§f}[" +
                                player.name +
                                "§r§f]: Spawned an ender chest. "
                            )
                        );
                    });
                });
                break;
            case !!switchTest.match(/^playersettings$/):
                eventData.cancel = true;
                switch (Math.min(newMessage.split(" ").length, 3)) {
                    case 3:
                        try {
                            player.setDynamicProperty(
                                newMessage.split(" ")[1],
                                newMessage.slice(
                                    newMessage.split(" ")[1].length + 17
                                )
                            );
                        } catch (e) {
                            player.sendError("§c" + e + e.stack, true);
                        }
                        try {
                            eventData.sender.sendMessage(
                                "Set " +
                                newMessage.split(" ")[1] +
                                " to " +
                                newMessage.slice(
                                    newMessage.split(" ")[1].length + 17
                                )
                            );
                        } catch (e) {
                            player.sendError("§c" + e + e.stack, true);
                        }
                        break;
                    case 2:
                        try {
                            eventData.sender.sendMessage(
                                "Setting " +
                                newMessage.split(" ")[1] +
                                ": " +
                                player.getDynamicProperty(
                                    newMessage.split(" ")[1]
                                )
                            );
                        } catch (e) {
                            player.sendError("§c" + e + e.stack, true);
                        }
                        break;
                }
                break;
            case !!switchTest.match(/^entitysettings$/):
                eventData.cancel = true;
                switch (Math.min(newMessage.split(" ").length, 3)) {
                    case 3:
                        try {
                            targetSelectorAllListB(
                                newMessage.split(" ")[1].replaceAll("\\s", " "),
                                "",
                                Number(eventData.sender.id)
                            ).forEach((currentEntitySelectedValues) => {
                                currentEntitySelectedValues.setDynamicProperty(
                                    newMessage.split(" ")[1],
                                    newMessage.slice(
                                        newMessage.split(" ")[1].length + 17
                                    )
                                );
                            });
                        } catch (e) {
                            player.sendError("§c" + e + e.stack, true);
                        }
                        try {
                            eventData.sender.sendMessage(
                                "Set " +
                                newMessage.split(" ")[2] +
                                " to " +
                                newMessage.slice(
                                    newMessage.split(" ")[2].length + 17
                                )
                            );
                        } catch (e) {
                            player.sendError("§c" + e + e.stack, true);
                        }
                        break;
                    case 2:
                        try {
                            eventData.sender.sendMessage(
                                "Setting " +
                                newMessage.split(" ")[2] +
                                ": " +
                                player.getDynamicProperty(
                                    newMessage.split(" ")[2]
                                )
                            );
                        } catch (e) {
                            player.sendError("§c" + e + e.stack, true);
                        }
                        break;
                }
                break;
            case !!switchTest.match(/^entitysettingsuuidselection$/):
                eventData.cancel = true;
                switch (Math.min(newMessage.split(" ").length, 3)) {
                    case 3:
                        try {
                            world
                                .getDimension(
                                    DimensionTypes.getAll().find((dimension) => world
                                        .getDimension(dimension.typeId)
                                        .getEntities()
                                        .find(
                                            (entity) => entity.id ==
                                                newMessage.split(" ")[1]
                                        )
                                    ).typeId
                                )
                                .getEntities()
                                .find(
                                    (entity) => entity.id == newMessage.split(" ")[1]
                                )
                                .setDynamicProperty(
                                    newMessage.split(" ")[1],
                                    newMessage.slice(
                                        newMessage.split(" ")[1].length + 30
                                    )
                                );
                        } catch (e) {
                            player.sendError("§c" + e + e.stack, true);
                        }
                        try {
                            eventData.sender.sendMessage(
                                "Set " +
                                newMessage.split(" ")[1] +
                                " to " +
                                newMessage.slice(
                                    newMessage.split(" ")[1].length + 17
                                )
                            );
                        } catch (e) {
                            player.sendError("§c" + e + e.stack, true);
                        }
                        break;
                    case 2:
                        try {
                            eventData.sender.sendMessage(
                                "Setting " +
                                newMessage.split(" ")[1] +
                                ": " +
                                player.getDynamicProperty(
                                    newMessage.split(" ")[1]
                                )
                            );
                        } catch (e) {
                            player.sendError("§c" + e + e.stack, true);
                        }
                        break;
                }
                break;
            case !!switchTest.match(/^help$/):
                eventData.cancel = true;
                switch (switchTestB.split(" ").slice(0, 2).join(" ").toLowerCase()) {
                    case "help":
                        eventData.sender.sendMessage(
                            "§2Help Chat Command Syntax§f\n.help scriptevent\n.help cmd <command: CommandName>\n.help command <command: CommandName>\n.help cmdextra <command: CommandName>\n.help commandextra <command: CommandName>\n.help cmddebug <command: CommandName>\n.help commanddebug <command: CommandName>\n.help cmddebugplus <command: CommandName>\n.help commanddebugplus <command: CommandName>\n.help customcmddebug <command: CommandName>\n.help customcommanddebug <command: CommandName>\n.help chatcommands\n.help chatcommandsb\n.help javascriptfunctions\n.help js <JavaScriptFunctionVariableConstantOrClassName: string>\n.help jsfunction <JavaScriptFunctionVariableConstantOrClassName: string>\n.help itemjsonformat\n.help itemjsonformatcmpr\n.help itemjsonformatsimplified§c\n.help entityevents\n.help items\n.help tags\n.help debugsticks".replaceAll(
                                "\n.",
                                "\n" +
                                (world.getDynamicProperty(
                                    "andexdbSettings:chatCommandPrefix"
                                ) ?? "\\")
                            )
                        );
                        break;
                    case "help scriptevent":
                        eventData.sender.sendMessage(
                            "§2/scriptevent Syntax§f\n/scriptevent andexdb:debugStick <message: string>\n/scriptevent andexdb:spawnSimulatedPlayer [playerName: string]|[location: location]|[dimensionId: string]|[gametestStructureSpawnLocation: location]"
                        );
                        break;
                    case "help cmd":
                        eventData.sender.sendMessage(
                            getCommandHelpPage(
                                switchTestB.split(" ").slice(2).join(" "),
                                player
                            )
                        );
                        break;
                    case "help command":
                        eventData.sender.sendMessage(
                            getCommandHelpPage(
                                switchTestB.split(" ").slice(2).join(" "),
                                player
                            )
                        );
                        break;
                    case "help cmdextra":
                        eventData.sender.sendMessage(
                            getCommandHelpPageExtra(
                                switchTestB.split(" ").slice(2).join(" "),
                                player
                            )
                        );
                        break;
                    case "help commandextra":
                        eventData.sender.sendMessage(
                            getCommandHelpPageExtra(
                                switchTestB.split(" ").slice(2).join(" "),
                                player
                            )
                        );
                        break;
                    case "help cmddebug":
                        eventData.sender.sendMessage(
                            getCommandHelpPageDebug(
                                switchTestB.split(" ").slice(2).join(" "),
                                player
                            )
                        );
                        break;
                    case "help commanddebug":
                        eventData.sender.sendMessage(
                            getCommandHelpPageDebug(
                                switchTestB.split(" ").slice(2).join(" "),
                                player
                            )
                        );
                        break;
                    case "help cmddebugplus":
                        eventData.sender.sendMessage(
                            getCommandHelpPageDebugPlus(
                                switchTestB.split(" ").slice(2).join(" "),
                                player
                            )
                        );
                        break;
                    case "help commanddebugplus":
                        eventData.sender.sendMessage(
                            getCommandHelpPageDebugPlus(
                                switchTestB.split(" ").slice(2).join(" "),
                                player
                            )
                        );
                        break;
                    case "help customcmddebug":
                        eventData.sender.sendMessage(
                            getCommandHelpPageCustomDebug(
                                switchTestB.split(" ").slice(2).join(" "),
                                player
                            )
                        );
                        break;
                    case "help customcommanddebug":
                        eventData.sender.sendMessage(
                            getCommandHelpPageCustomDebug(
                                switchTestB.split(" ").slice(2).join(" "),
                                player
                            )
                        );
                        break;
                    case "help chatcommands":
                        eventData.sender.sendMessage(
                            helpCommandChatCommandsList.replaceAll(
                                "\n.",
                                "\n" +
                                (world.getDynamicProperty(
                                    "andexdbSettings:chatCommandPrefix"
                                ) ?? "\\")
                            )
                        );
                        break;
                    case "help chatcommandsb":
                        eventData.sender.sendMessage(
                            `§2Chat Commands Syntax§f\n.give <item: itemType> <amount: int>
.giveb <item: itemType> [amount: int]
.givec <itemJSON: itemJSON>
.setitem <item: itemType> <amount: int> <slot: int>
.invsee <target: targetSelector>
.offlineinfo <playerName: string>
.offlineuuidinfo <playerUUID: int>
.offlineinvsee <playerName: string>
.offlineuuidinvsee <playerUUID: int>
.binvsee <dimension: dimension|~> <block: x y z>
.einvsee <targetSelector: targetSelector>
.invseeuuidmode <entityUUID: int>
.h<presetId: float> <containerRow: float>
.hset <presetId: float> [dimensionId: string] [x: float] [y: float] [z: float]
.gmc
.gms
.gma
.gmd
.gmp
.gmr
.getuuid <target: target>
.warpset <dimension: dimension> <x: float> <y: float> <z: float> <name: escapableString>
.warp <name: escapableString>
.warpremove <name: escapableString>
.warpreset
.warplist
.warplistdetails
.warplistrawdata
.wset <dimension: dimension> <x: float> <y: float> <z: float> <name: escapableString>
.w <name: escapableString>
.wremove <name: escapableString>
.wreset
.wlist
.wlistdetails
.wlistrawdata
.run <delayTicks: int> <command: command>
.eval <ScriptAPICode: JavaScript>
.top
.up <count: int> [placeGlass: bool]
.printlayers
.mainmenu
.settings
.datapickblock`.replaceAll(
                                "\n.",
                                "\n" +
                                (world.getDynamicProperty(
                                    "andexdbSettings:chatCommandPrefix"
                                ) ?? "\\")
                            )
                        );
                        break;
                    case "help javascriptfunctions":
                        eventData.sender.sendMessage(
                            `§2List of JavaScript Functions, Constants, Variables, and Classes§f\n{§bmain: [§f${Object.keys(
                                modules.main
                            ).join("§b, §f")}§b], coords: [§f${Object.keys(
                                modules.coords
                            ).join("§b, §f")}§b], cmds: [§f${Object.keys(
                                modules.cmds
                            ).join("§b, §f")}§b], bans: [§f${Object.keys(
                                modules.bans
                            ).join("§b, §f")}§b], uis: [§f${Object.keys(
                                modules.uis
                            ).join("§b, §f")}§b], playersave: [§f${Object.keys(
                                modules.playersave
                            ).join("§b, §f")}§b], spawnprot: [§f${Object.keys(
                                modules.spawnprot
                            ).join("§b, §f")}§b]§f}`
                        );
                        break;
                    case "help jsfunction":
                        eventData.sender.sendMessage(
                            `§2${newMessage
                                .slice(
                                    String(
                                        world.getDynamicProperty(
                                            "andexdbSettings:chatCommandPrefix"
                                        ) ?? "\\"
                                    ).length
                                )
                                .split(" ")
                                .slice(2)
                                .join(" ")} js object definition§f\n${([
                                    ...Object.entries(modules.main),
                                    ...Object.entries(modules.coords),
                                    ...Object.entries(modules.cmds),
                                    ...Object.entries(modules.bans),
                                    ...Object.entries(modules.uis),
                                    ...Object.entries(modules.playersave),
                                    ...Object.entries(modules.spawnprot),
                                ].find(
                                    (v) => v[0] ==
                                        newMessage
                                            .slice(
                                                String(
                                                    world.getDynamicProperty(
                                                        "andexdbSettings:chatCommandPrefix"
                                                    ) ?? "\\"
                                                ).length
                                            )
                                            .split(" ")
                                            .slice(2)
                                            .join(" ")
                                ) ?? [
                                        ,

                                        "§cError: The specified javascript function/constant/variable/class does not exist, check your spelling and capitallization. ",
                                    ])[1]
                                    .toString()
                                    .replaceAll("\\n", "\n")}`
                        );
                        break;
                    case "help js":
                        eventData.sender.sendMessage(
                            `§2${newMessage
                                .slice(
                                    String(
                                        world.getDynamicProperty(
                                            "andexdbSettings:chatCommandPrefix"
                                        ) ?? "\\"
                                    ).length
                                )
                                .split(" ")
                                .slice(2)
                                .join(" ")} js object definition§f\n${([
                                    ...Object.entries(modules.main),
                                    ...Object.entries(modules.coords),
                                    ...Object.entries(modules.cmds),
                                    ...Object.entries(modules.bans),
                                    ...Object.entries(modules.uis),
                                    ...Object.entries(modules.playersave),
                                    ...Object.entries(modules.spawnprot),
                                ].find(
                                    (v) => v[0] ==
                                        newMessage
                                            .slice(
                                                String(
                                                    world.getDynamicProperty(
                                                        "andexdbSettings:chatCommandPrefix"
                                                    ) ?? "\\"
                                                ).length
                                            )
                                            .split(" ")
                                            .slice(2)
                                            .join(" ")
                                ) ?? [
                                        ,

                                        "§cError: The specified javascript function/constant/variable/class does not exist, check your spelling and capitallization. ",
                                    ])[1]
                                    .toString()
                                    .replaceAll("\\n", "\n")}`
                        );
                        break;
                    case "help itemjsonformat":
                        eventData.sender.sendMessage(`itemJSON Format: 
export interface ItemJSONParseInput {
    "name"?: string,
    "minecraft:name"?: string,
    "nameTag"?: string,
    "minecraft:nameTag"?: string,
    "lore"?: string[],
    "minecraft:lore"?: string[],
    "description"?: string[],
    "minecraft:description"?: string[],
    "count"?: number,
    "minecraft:count"?: number,
    "amount"?: number,
    "minecraft:amount"?: number,
    "keepOnDeath"?: boolean,
    "minecraft:keepOnDeath"?: boolean,
    "keepondeath"?: boolean,
    "minecraft:keepondeath"?: boolean,
    "keep_on_death"?: boolean,
    "minecraft:keep_on_death"?: boolean,
    "lockMode"?: ItemLockMode,
    "minecraft:lockMode"?: ItemLockMode,
    "lockmode"?: ItemLockMode,
    "minecraft:lockmode"?: ItemLockMode,
    "lock_mode"?: ItemLockMode,
    "minecraft:lock_mode"?: ItemLockMode,
    "itemLockMode"?: ItemLockMode,
    "minecraft:itemLockMode"?: ItemLockMode,
    "itemlockmode"?: ItemLockMode,
    "minecraft:itemlockmode"?: ItemLockMode,
    "item_lock_mode"?: ItemLockMode,
    "minecraft:item_lock_mode"?: ItemLockMode,
    "canPlaceOn"?: string[],
    "minecraft:canPlaceOn"?: string[],
    "canplaceon"?: string[],
    "minecraft:canplaceon"?: string[],
    "can_place_on"?: string[],
    "minecraft:can_place_on"?: string[],
    "canDestroy"?: string[],
    "minecraft:canDestroy"?: string[],
    "candestroy"?: string[],
    "minecraft:candestroy"?: string[],
    "can_destroy"?: string[],
    "minecraft:can_destroy"?: string[],
    "components"?: {
        "enchantable"?: {
            "add"?: Enchantment|Enchantment[],
            "minecraft:add"?: Enchantment|Enchantment[],
            "addEnchantment"?: Enchantment|Enchantment[],
            "minecraft:addEnchantment"?: Enchantment|Enchantment[],
            "addList"?: Enchantment[],
            "minecraft:addList"?: Enchantment[],
            "addEnchantments"?: Enchantment[],
            "minecraft:addEnchantments"?: Enchantment[],
            "remove"?: Enchantment,
            "minecraft:remove"?: Enchantment,
            "removeEnchantments"?: Enchantment,
            "minecraft:removeEnchantments"?: Enchantment,
            "clear"?: any,
            "minecraft:clear"?: any,
            "clearAll"?: any,
            "minecraft:clearAll"?: any,
            "removeAll"?: any,
            "minecraft:removeAll"?: any,
            "removeAllEnchantments"?: any,
            "minecraft:removeAllEnchantments"?: any
        },
        "minecraft:enchantable"?: {
            "add"?: Enchantment|Enchantment[],
            "minecraft:add"?: Enchantment|Enchantment[],
            "addEnchantment"?: Enchantment|Enchantment[],
            "minecraft:addEnchantment"?: Enchantment|Enchantment[],
            "addList"?: Enchantment[],
            "minecraft:addList"?: Enchantment[],
            "addEnchantments"?: Enchantment[],
            "minecraft:addEnchantments"?: Enchantment[],
            "remove"?: Enchantment,
            "minecraft:remove"?: Enchantment,
            "removeEnchantments"?: Enchantment,
            "minecraft:removeEnchantments"?: Enchantment,
            "clear"?: any,
            "minecraft:clear"?: any,
            "clearAll"?: any,
            "minecraft:clearAll"?: any,
            "removeAll"?: any,
            "minecraft:removeAll"?: any,
            "removeAllEnchantments"?: any,
            "minecraft:removeAllEnchantments"?: any
        },
        "durability"?: {
            "durability"?: number,
            "minecraft:durability"?: number,
            "setDurability"?: number,
            "minecraft:setDurability"?: number,
            "damage"?: number,
            "minecraft:damage"?: number,
            "setDamage"?: number,
            "minecraft:setDamage"?: number,
            "repair"?: number,
            "minecraft:repair"?: number,
            "setDurabilityToMax"?: any,
            "minecraft:setDurabilityToMax"?: any
        },
        "minecraft:durability"?: {
            "durability"?: number,
            "minecraft:durability"?: number,
            "setDurability"?: number,
            "minecraft:setDurability"?: number,
            "damage"?: number,
            "minecraft:damage"?: number,
            "setDamage"?: number,
            "minecraft:setDamage"?: number,
            "repair"?: number,
            "minecraft:repair"?: number,
            "setDurabilityToMax"?: any,
            "minecraft:setDurabilityToMax"?: any
        },
        "damage"?: {
            "durability"?: number,
            "minecraft:durability"?: number,
            "setDurability"?: number,
            "minecraft:setDurability"?: number,
            "damage"?: number,
            "minecraft:damage"?: number,
            "setDamage"?: number,
            "minecraft:setDamage"?: number,
            "repair"?: number,
            "minecraft:repair"?: number,
            "setDurabilityToMax"?: any,
            "minecraft:setDurabilityToMax"?: any
        },
        "minecraft:damage"?: {
            "durability"?: number,
            "minecraft:durability"?: number,
            "setDurability"?: number,
            "minecraft:setDurability"?: number,
            "damage"?: number,
            "minecraft:damage"?: number,
            "setDamage"?: number,
            "minecraft:setDamage"?: number,
            "repair"?: number,
            "minecraft:repair"?: number,
            "setDurabilityToMax"?: any,
            "minecraft:setDurabilityToMax"?: any
        },
        "cooldown"?: any,
        "minecraft:cooldown"?: any,
        "food"?: any,
        "minecraft:food"?: any
    },
    "minecraft:components"?: {
        "enchantable"?: {
            "add"?: Enchantment|Enchantment[],
            "minecraft:add"?: Enchantment|Enchantment[],
            "addEnchantment"?: Enchantment|Enchantment[],
            "minecraft:addEnchantment"?: Enchantment|Enchantment[],
            "addList"?: Enchantment[],
            "minecraft:addList"?: Enchantment[],
            "addEnchantments"?: Enchantment[],
            "minecraft:addEnchantments"?: Enchantment[],
            "remove"?: Enchantment,
            "minecraft:remove"?: Enchantment,
            "removeEnchantments"?: Enchantment,
            "minecraft:removeEnchantments"?: Enchantment,
            "clear"?: any,
            "minecraft:clear"?: any,
            "clearAll"?: any,
            "minecraft:clearAll"?: any,
            "removeAll"?: any,
            "minecraft:removeAll"?: any,
            "removeAllEnchantments"?: any,
            "minecraft:removeAllEnchantments"?: any
        },
        "minecraft:enchantable"?: {
            "add"?: Enchantment|Enchantment[],
            "minecraft:add"?: Enchantment|Enchantment[],
            "addEnchantment"?: Enchantment|Enchantment[],
            "minecraft:addEnchantment"?: Enchantment|Enchantment[],
            "addList"?: Enchantment[],
            "minecraft:addList"?: Enchantment[],
            "addEnchantments"?: Enchantment[],
            "minecraft:addEnchantments"?: Enchantment[],
            "remove"?: Enchantment,
            "minecraft:remove"?: Enchantment,
            "removeEnchantments"?: Enchantment,
            "minecraft:removeEnchantments"?: Enchantment,
            "clear"?: any,
            "minecraft:clear"?: any,
            "clearAll"?: any,
            "minecraft:clearAll"?: any,
            "removeAll"?: any,
            "minecraft:removeAll"?: any,
            "removeAllEnchantments"?: any,
            "minecraft:removeAllEnchantments"?: any
        },
        "durability"?: {
            "durability"?: number,
            "minecraft:durability"?: number,
            "setDurability"?: number,
            "minecraft:setDurability"?: number,
            "damage"?: number,
            "minecraft:damage"?: number,
            "setDamage"?: number,
            "minecraft:setDamage"?: number,
            "repair"?: number,
            "minecraft:repair"?: number,
            "setDurabilityToMax"?: any,
            "minecraft:setDurabilityToMax"?: any
        },
        "minecraft:durability"?: {
            "durability"?: number,
            "minecraft:durability"?: number,
            "setDurability"?: number,
            "minecraft:setDurability"?: number,
            "damage"?: number,
            "minecraft:damage"?: number,
            "setDamage"?: number,
            "minecraft:setDamage"?: number,
            "repair"?: number,
            "minecraft:repair"?: number,
            "setDurabilityToMax"?: any,
            "minecraft:setDurabilityToMax"?: any
        },
        "damage"?: {
            "durability"?: number,
            "minecraft:durability"?: number,
            "setDurability"?: number,
            "minecraft:setDurability"?: number,
            "damage"?: number,
            "minecraft:damage"?: number,
            "setDamage"?: number,
            "minecraft:setDamage"?: number,
            "repair"?: number,
            "minecraft:repair"?: number,
            "setDurabilityToMax"?: any,
            "minecraft:setDurabilityToMax"?: any
        },
        "minecraft:damage"?: {
            "durability"?: number,
            "minecraft:durability"?: number,
            "setDurability"?: number,
            "minecraft:setDurability"?: number,
            "damage"?: number,
            "minecraft:damage"?: number,
            "setDamage"?: number,
            "minecraft:setDamage"?: number,
            "repair"?: number,
            "minecraft:repair"?: number,
            "setDurabilityToMax"?: any,
            "minecraft:setDurabilityToMax"?: any
        },
        "cooldown"?: any,
        "minecraft:cooldown"?: any,
        "food"?: any,
        "minecraft:food"?: any
    }
    force?: boolean
    source?: {
        type?: string,
        targetSelector?: string,
        targetSelectorExecutionLocation?: DimensionLocation,
        targetSelectorSourceEntity?: Entity,
        player?: string,
        entityAtBlock?: DimensionLocation,
        entityType?: string,
        entityTypeId?: string,
        entityId?: string|number,
        block?: DimensionLocation,
        slot?: number,
        id?: string,
        itemId?: string,
        count?: number,
        amount?: number
    },
    type?: string,
    id?: string,
    itemId?: string,
    new?: [string, number?],
    dynamicProperties?: [string, string|number|boolean|Vector3|undefined][]|Record<string, string|number|boolean|Vector3|undefined>,
    dynamicproperties?: [string, string|number|boolean|Vector3|undefined][]|Record<string, string|number|boolean|Vector3|undefined>,
    properties?: [string, string|number|boolean|Vector3|undefined][]|Record<string, string|number|boolean|Vector3|undefined>,
    itemproperties?: [string, string|number|boolean|Vector3|undefined][]|Record<string, string|number|boolean|Vector3|undefined>,
    itemProperties?: [string, string|number|boolean|Vector3|undefined][]|Record<string, string|number|boolean|Vector3|undefined>
    clearAllDynamicProperties?: any,
    clearDynamicProperties?: any,
    clearalldynamicproperties?: any,
    cleardynamicproperties?: any,
    removeDynamicProperties?: string[],
    removedynamicproperties?: string[],
    removeDynamicProperty?: string,
    removedynamicproperty?: string,
    "minecraft:dynamicProperties"?: [string, string|number|boolean|Vector3|undefined][]|Record<string, string|number|boolean|Vector3|undefined>,
    "minecraft:dynamicproperties"?: [string, string|number|boolean|Vector3|undefined][]|Record<string, string|number|boolean|Vector3|undefined>,
    "minecraft:properties"?: [string, string|number|boolean|Vector3|undefined][]|Record<string, string|number|boolean|Vector3|undefined>,
    "minecraft:itemProperties"?: [string, string|number|boolean|Vector3|undefined][]|Record<string, string|number|boolean|Vector3|undefined>,
    "minecraft:itemproperties"?: [string, string|number|boolean|Vector3|undefined][]|Record<string, string|number|boolean|Vector3|undefined>,
    "minecraft:clearAllDynamicProperties"?: any,
    "minecraft:clearDynamicProperties"?: any,
    "minecraft:clearalldynamicproperties"?: any,
    "minecraft:cleardynamicproperties"?: any,
    "minecraft:removeDynamicProperties"?: string[],
    "minecraft:removedynamicproperties"?: string[],
    "minecraft:removeDynamicProperty"?: string,
    "minecraft:removedynamicproperty"?: string
}
examples: 
stack of 255 sharpness 1 wooden swords: {"minecraft:components": {"enchantable": {"add": {"level": 1, "type": "sharpness"}}}, "id": "wooden_sword", "count": 255}
sharpness 5 fortune 3 efficiency 5 iron axe that cannot be dropped and are kept on death with the name "§4Storage Hog Axe§r" and the lore "§eTakes\\nUp\\nYour\\nInventory§r" (with the \\n as line break characters) that says lol in the chat and damages the user when used: {"minecraft:components": {"enchantable": {"add": [{"level": 1, "type": "sharpness"}, {"type": "fortune", "level": 3}, {"type": "efficiency", "level": 5}]}}, "id": "iron_axe", "count": 72, "keepondeath": true, "lockMode": "inventory", "name": "§r§4Storage Hog Axe§r§f", "lore": ["§r§eTakes\\nUp§r§f","§r§eYour\\nInventory§r§f"], "dynamicProperties": {"code": "world.sendMessage('lol'); event.source.runCommandAsync(\\"/damage @s 1 thorns entity @s\\")"}}
stack of 16 unbreaking 3 mending 1 shields that are locked to a specific slot and are kept on death: {"minecraft:components": {"enchantable": {"addList": [{"level": 1, "type": "mending"}, {"type": "unbreaking", "level": 3}]}}, "id": "shield", "count": 16, "keepondeath": true, "lockMode": "slot"}`);
                        break;
                    case "help itemjsonformatcmpr":
                        eventData.sender.sendMessage(`itemJSON Format: 
${`export interface ItemJSONParseInput {
"name"?: string,
"minecraft:name"?: string,
"nameTag"?: string,
"minecraft:nameTag"?: string,
"lore"?: string[],
"minecraft:lore"?: string[],
"description"?: string[],
"minecraft:description"?: string[],
"count"?: number,
"minecraft:count"?: number,
"amount"?: number,
"minecraft:amount"?: number,
"keepOnDeath"?: boolean,
"minecraft:keepOnDeath"?: boolean,
"keepondeath"?: boolean,
"minecraft:keepondeath"?: boolean,
"keep_on_death"?: boolean,
"minecraft:keep_on_death"?: boolean,
"lockMode"?: ItemLockMode,
"minecraft:lockMode"?: ItemLockMode,
"lockmode"?: ItemLockMode,
"minecraft:lockmode"?: ItemLockMode,
"lock_mode"?: ItemLockMode,
"minecraft:lock_mode"?: ItemLockMode,
"itemLockMode"?: ItemLockMode,
"minecraft:itemLockMode"?: ItemLockMode,
"itemlockmode"?: ItemLockMode,
"minecraft:itemlockmode"?: ItemLockMode,
"item_lock_mode"?: ItemLockMode,
"minecraft:item_lock_mode"?: ItemLockMode,
"canPlaceOn"?: string[],
"minecraft:canPlaceOn"?: string[],
"canplaceon"?: string[],
"minecraft:canplaceon"?: string[],
"can_place_on"?: string[],
"minecraft:can_place_on"?: string[],
"canDestroy"?: string[],
"minecraft:canDestroy"?: string[],
"candestroy"?: string[],
"minecraft:candestroy"?: string[],
"can_destroy"?: string[],
"minecraft:can_destroy"?: string[],
"components"?: {
"enchantable"?: {
"add"?: Enchantment|Enchantment[],
"minecraft:add"?: Enchantment|Enchantment[],
"addEnchantment"?: Enchantment|Enchantment[],
"minecraft:addEnchantment"?: Enchantment|Enchantment[],
"addList"?: Enchantment[],
"minecraft:addList"?: Enchantment[],
"addEnchantments"?: Enchantment[],
"minecraft:addEnchantments"?: Enchantment[],
"remove"?: Enchantment,
"minecraft:remove"?: Enchantment,
"removeEnchantments"?: Enchantment,
"minecraft:removeEnchantments"?: Enchantment,
"clear"?: any,
"minecraft:clear"?: any,
"clearAll"?: any,
"minecraft:clearAll"?: any,
"removeAll"?: any,
"minecraft:removeAll"?: any,
"removeAllEnchantments"?: any,
"minecraft:removeAllEnchantments"?: any
},
"minecraft:enchantable"?: {
"add"?: Enchantment|Enchantment[],
"minecraft:add"?: Enchantment|Enchantment[],
"addEnchantment"?: Enchantment|Enchantment[],
"minecraft:addEnchantment"?: Enchantment|Enchantment[],
"addList"?: Enchantment[],
"minecraft:addList"?: Enchantment[],
"addEnchantments"?: Enchantment[],
"minecraft:addEnchantments"?: Enchantment[],
"remove"?: Enchantment,
"minecraft:remove"?: Enchantment,
"removeEnchantments"?: Enchantment,
"minecraft:removeEnchantments"?: Enchantment,
"clear"?: any,
"minecraft:clear"?: any,
"clearAll"?: any,
"minecraft:clearAll"?: any,
"removeAll"?: any,
"minecraft:removeAll"?: any,
"removeAllEnchantments"?: any,
"minecraft:removeAllEnchantments"?: any
},
"durability"?: {
"durability"?: number,
"minecraft:durability"?: number,
"setDurability"?: number,
"minecraft:setDurability"?: number,
"damage"?: number,
"minecraft:damage"?: number,
"setDamage"?: number,
"minecraft:setDamage"?: number,
"repair"?: number,
"minecraft:repair"?: number,
"setDurabilityToMax"?: any,
"minecraft:setDurabilityToMax"?: any
},
"minecraft:durability"?: {
"durability"?: number,
"minecraft:durability"?: number,
"setDurability"?: number,
"minecraft:setDurability"?: number,
"damage"?: number,
"minecraft:damage"?: number,
"setDamage"?: number,
"minecraft:setDamage"?: number,
"repair"?: number,
"minecraft:repair"?: number,
"setDurabilityToMax"?: any,
"minecraft:setDurabilityToMax"?: any
},
"damage"?: {
"durability"?: number,
"minecraft:durability"?: number,
"setDurability"?: number,
"minecraft:setDurability"?: number,
"damage"?: number,
"minecraft:damage"?: number,
"setDamage"?: number,
"minecraft:setDamage"?: number,
"repair"?: number,
"minecraft:repair"?: number,
"setDurabilityToMax"?: any,
"minecraft:setDurabilityToMax"?: any
},
"minecraft:damage"?: {
"durability"?: number,
"minecraft:durability"?: number,
"setDurability"?: number,
"minecraft:setDurability"?: number,
"damage"?: number,
"minecraft:damage"?: number,
"setDamage"?: number,
"minecraft:setDamage"?: number,
"repair"?: number,
"minecraft:repair"?: number,
"setDurabilityToMax"?: any,
"minecraft:setDurabilityToMax"?: any
},
"cooldown"?: any,
"minecraft:cooldown"?: any,
"food"?: any,
"minecraft:food"?: any
},
"minecraft:components"?: {
"enchantable"?: {
"add"?: Enchantment|Enchantment[],
"minecraft:add"?: Enchantment|Enchantment[],
"addEnchantment"?: Enchantment|Enchantment[],
"minecraft:addEnchantment"?: Enchantment|Enchantment[],
"addList"?: Enchantment[],
"minecraft:addList"?: Enchantment[],
"addEnchantments"?: Enchantment[],
"minecraft:addEnchantments"?: Enchantment[],
"remove"?: Enchantment,
"minecraft:remove"?: Enchantment,
"removeEnchantments"?: Enchantment,
"minecraft:removeEnchantments"?: Enchantment,
"clear"?: any,
"minecraft:clear"?: any,
"clearAll"?: any,
"minecraft:clearAll"?: any,
"removeAll"?: any,
"minecraft:removeAll"?: any,
"removeAllEnchantments"?: any,
"minecraft:removeAllEnchantments"?: any
},
"minecraft:enchantable"?: {
"add"?: Enchantment|Enchantment[],
"minecraft:add"?: Enchantment|Enchantment[],
"addEnchantment"?: Enchantment|Enchantment[],
"minecraft:addEnchantment"?: Enchantment|Enchantment[],
"addList"?: Enchantment[],
"minecraft:addList"?: Enchantment[],
"addEnchantments"?: Enchantment[],
"minecraft:addEnchantments"?: Enchantment[],
"remove"?: Enchantment,
"minecraft:remove"?: Enchantment,
"removeEnchantments"?: Enchantment,
"minecraft:removeEnchantments"?: Enchantment,
"clear"?: any,
"minecraft:clear"?: any,
"clearAll"?: any,
"minecraft:clearAll"?: any,
"removeAll"?: any,
"minecraft:removeAll"?: any,
"removeAllEnchantments"?: any,
"minecraft:removeAllEnchantments"?: any
},
"durability"?: {
"durability"?: number,
"minecraft:durability"?: number,
"setDurability"?: number,
"minecraft:setDurability"?: number,
"damage"?: number,
"minecraft:damage"?: number,
"setDamage"?: number,
"minecraft:setDamage"?: number,
"repair"?: number,
"minecraft:repair"?: number,
"setDurabilityToMax"?: any,
"minecraft:setDurabilityToMax"?: any
},
"minecraft:durability"?: {
"durability"?: number,
"minecraft:durability"?: number,
"setDurability"?: number,
"minecraft:setDurability"?: number,
"damage"?: number,
"minecraft:damage"?: number,
"setDamage"?: number,
"minecraft:setDamage"?: number,
"repair"?: number,
"minecraft:repair"?: number,
"setDurabilityToMax"?: any,
"minecraft:setDurabilityToMax"?: any
},
"damage"?: {
"durability"?: number,
"minecraft:durability"?: number,
"setDurability"?: number,
"minecraft:setDurability"?: number,
"damage"?: number,
"minecraft:damage"?: number,
"setDamage"?: number,
"minecraft:setDamage"?: number,
"repair"?: number,
"minecraft:repair"?: number,
"setDurabilityToMax"?: any,
"minecraft:setDurabilityToMax"?: any
},
"minecraft:damage"?: {
"durability"?: number,
"minecraft:durability"?: number,
"setDurability"?: number,
"minecraft:setDurability"?: number,
"damage"?: number,
"minecraft:damage"?: number,
"setDamage"?: number,
"minecraft:setDamage"?: number,
"repair"?: number,
"minecraft:repair"?: number,
"setDurabilityToMax"?: any,
"minecraft:setDurabilityToMax"?: any
},
"cooldown"?: any,
"minecraft:cooldown"?: any,
"food"?: any,
"minecraft:food"?: any
}
force?: boolean
source?: {
type?: string,
targetSelector?: string,
targetSelectorExecutionLocation?: DimensionLocation,
targetSelectorSourceEntity?: Entity,
player?: string,
entityAtBlock?: DimensionLocation,
entityType?: string,
entityTypeId?: string,
entityId?: string|number,
block?: DimensionLocation,
slot?: number,
id?: string,
itemId?: string,
count?: number,
amount?: number
},
type?: string,
id?: string,
itemId?: string,
new?: [string, number?],
dynamicProperties?: [string, string|number|boolean|Vector3|undefined][]|Record<string, string|number|boolean|Vector3|undefined>,
dynamicproperties?: [string, string|number|boolean|Vector3|undefined][]|Record<string, string|number|boolean|Vector3|undefined>,
properties?: [string, string|number|boolean|Vector3|undefined][]|Record<string, string|number|boolean|Vector3|undefined>,
itemproperties?: [string, string|number|boolean|Vector3|undefined][]|Record<string, string|number|boolean|Vector3|undefined>,
itemProperties?: [string, string|number|boolean|Vector3|undefined][]|Record<string, string|number|boolean|Vector3|undefined>
clearAllDynamicProperties?: any,
clearDynamicProperties?: any,
clearalldynamicproperties?: any,
cleardynamicproperties?: any,
removeDynamicProperties?: string[],
removedynamicproperties?: string[],
removeDynamicProperty?: string,
removedynamicproperty?: string,
"minecraft:dynamicProperties"?: [string, string|number|boolean|Vector3|undefined][]|Record<string, string|number|boolean|Vector3|undefined>,
"minecraft:dynamicproperties"?: [string, string|number|boolean|Vector3|undefined][]|Record<string, string|number|boolean|Vector3|undefined>,
"minecraft:properties"?: [string, string|number|boolean|Vector3|undefined][]|Record<string, string|number|boolean|Vector3|undefined>,
"minecraft:itemProperties"?: [string, string|number|boolean|Vector3|undefined][]|Record<string, string|number|boolean|Vector3|undefined>,
"minecraft:itemproperties"?: [string, string|number|boolean|Vector3|undefined][]|Record<string, string|number|boolean|Vector3|undefined>,
"minecraft:clearAllDynamicProperties"?: any,
"minecraft:clearDynamicProperties"?: any,
"minecraft:clearalldynamicproperties"?: any,
"minecraft:cleardynamicproperties"?: any,
"minecraft:removeDynamicProperties"?: string[],
"minecraft:removedynamicproperties"?: string[],
"minecraft:removeDynamicProperty"?: string,
"minecraft:removedynamicproperty"?: string
}
examples: 
stack of 255 sharpness 1 wooden swords: {"minecraft:components": {"enchantable": {"add": {"level": 1, "type": "sharpness"}}}, "id": "wooden_sword", "count": 255}
sharpness 5 fortune 3 efficiency 5 iron axe that cannot be dropped and are kept on death with the name "§4Storage Hog Axe§r" and the lore "§eTakes\\nUp\\nYour\\nInventory§r" (with the \\n as line break characters) that says lol in the chat and damages the user when used: {"minecraft:components": {"enchantable": {"add": [{"level": 1, "type": "sharpness"}, {"type": "fortune", "level": 3}, {"type": "efficiency", "level": 5}]}}, "id": "iron_axe", "count": 72, "keepondeath": true, "lockMode": "inventory", "name": "§r§4Storage Hog Axe§r§f", "lore": ["§r§eTakes\\nUp§r§f","§r§eYour\\nInventory§r§f"], "dynamicProperties": {"code": "world.sendMessage('lol'); event.source.runCommandAsync(\\"/damage @s 1 thorns entity @s\\")"}}
stack of 16 unbreaking 3 mending 1 shields that are locked to a specific slot and are kept on death: {"minecraft:components": {"enchantable": {"addList": [{"level": 1, "type": "mending"}, {"type": "unbreaking", "level": 3}]}}, "id": "shield", "count": 16, "keepondeath": true, "lockMode": "slot"}`.replaceAll(
                            "\n",
                            ""
                        )}`);
                        break;
                    case "help itemjsonformatsimplified":
                        player.sendMessageB(`simplified itemJSON format (type "${String(
                            world.getDynamicProperty(
                                "andexdbSettings:chatCommandPrefix"
                            ) ?? "\\"
                        )}help itemJSONFormat" to see full format options): 
{
    "name"?: string,
    "lore"?: string[],
    "count"?: number,
    "keepondeath"?: boolean,
    "lockmode"?: ItemLockMode,
    "canplaceon"?: string[],
    "components"?: {
        "enchantable"?: {
            "add"?: Enchantment|Enchantment[],
            "addList"?: Enchantment[],
            "remove"?: Enchantment,
            "removeEnchantments"?: Enchantment,
            "clear"?: any
        },
        "durability"?: {
            "durability"?: number,
            "damage"?: number,
            "repair"?: number,
            "setDurabilityToMax"?: any
        },
        "damage"?: {
            "durability"?: number,
            "damage"?: number,
            "repair"?: number,
            "setDurabilityToMax"?: any
        }
    },
    force?: boolean
    source?: {
        type?: string,
        targetSelector?: string,
        targetSelectorExecutionLocation?: DimensionLocation,
        targetSelectorSourceEntity?: Entity,
        player?: string,
        entityAtBlock?: DimensionLocation,
        entityType?: string,
        entityTypeId?: string,
        entityId?: string|number,
        block?: DimensionLocation,
        slot?: number,
        id?: string,
        itemId?: string,
        count?: number,
        amount?: number
    },
    type?: string,
    dynamicproperties?: [string, string|number|boolean|Vector3|undefined][]|Record<string, string|number|boolean|Vector3|undefined>,
    cleardynamicproperties?: any,
    removedynamicproperties?: string[],
    removedynamicproperty?: string
}
examples: 
stack of 255 sharpness 1 wooden swords: {"minecraft:components": {"enchantable": {"add": {"level": 1, "type": "sharpness"}}}, "id": "wooden_sword", "count": 255}
sharpness 5 fortune 3 efficiency 5 iron axe that cannot be dropped and are kept on death with the name "§4Storage Hog Axe§r" and the lore "§eTakes\\nUp\\nYour\\nInventory§r" (with the \\n as line break characters) that says lol in the chat and damages the user when used: {"minecraft:components": {"enchantable": {"add": [{"level": 1, "type": "sharpness"}, {"type": "fortune", "level": 3}, {"type": "efficiency", "level": 5}]}}, "id": "iron_axe", "count": 72, "keepondeath": true, "lockMode": "inventory", "name": "§r§4Storage Hog Axe§r§f", "lore": ["§r§eTakes\\nUp§r§f","§r§eYour\\nInventory§r§f"], "dynamicProperties": {"code": "world.sendMessage('lol'); event.source.runCommandAsync(\\"/damage @s 1 thorns entity @s\\")"}}
stack of 16 unbreaking 3 mending 1 shields that are locked to a specific slot and are kept on death: {"minecraft:components": {"enchantable": {"addList": [{"level": 1, "type": "mending"}, {"type": "unbreaking", "level": 3}]}}, "id": "shield", "count": 16, "keepondeath": true, "lockMode": "slot"}`);
                        break;
                    default:
                        player.sendError(
                            '§cSyntax error: Unexpected "' +
                            newMessage.slice(
                                String(
                                    world.getDynamicProperty(
                                        "andexdbSettings:chatCommandPrefix"
                                    ) ?? "\\"
                                ).length + 4
                            ) +
                            '": at "' +
                            String(
                                world.getDynamicProperty(
                                    "andexdbSettings:chatCommandPrefix"
                                ) ?? "\\"
                            ) +
                            "help >>" +
                            newMessage.slice(
                                String(
                                    world.getDynamicProperty(
                                        "andexdbSettings:chatCommandPrefix"
                                    ) ?? "\\"
                                ).length + 5
                            ) +
                            '<<"',
                            true
                        );
                        break;
                }
                break;
            case !!switchTest.match(/^getuuid$/):
                eventData.cancel = true;
                try {
                    system.runTimeout(() => {
                        player.sendMessageB(
                            targetSelectorAllListC(
                                switchTestB.split(" ").slice(1).join(" "),
                                "",
                                vTStr(player.location),
                                player.player
                            )
                                .map((v) => v.id)
                                .join("\n")
                        );
                    }, 2);
                } catch (e) {
                    player.sendError("§c" + e + e.stack, true);
                }

                break;
            case !!switchTest.match(/^run$/):
                eventData.cancel = true;
                try {
                    system.runTimeout(() => {
                        let a = player.runCommand(
                            (params.fromExecute == true
                                ? `/execute positioned ${vTStr(
                                    player.location
                                )} rotated ${player.getRotation().y} ${player.getRotation().x} in ${dimensionTypeDisplayFormattingF[player.dimension.id]} run `
                                : "") + newMessage.split(" ").slice(2).join(" ")
                        );
                        player.sendError(String(a.successCount), true);
                        if (a.successCount != 0.0) {
                            targetSelectorAllListE(
                                "@a [tag=canSeeCustomChatCommandFeedbackFromMods]",
                                player.location.x +
                                " " +
                                player.location.y +
                                " " +
                                player.location.z
                            ).forEach((entity) => {
                                (entity as Player).sendMessage(
                                    String(
                                        "{§l§dCMDFEED§r§f}[" +
                                        player.name +
                                        "§r§f]: " +
                                        a +
                                        " Successfully waited " +
                                        Number(newMessage.split(" ")[1]) +
                                        " ticks and executed the command: " +
                                        newMessage.slice(
                                            Number(
                                                newMessage.split(" ")[1]
                                            ) + 5
                                        )
                                    )
                                );
                            });
                        }
                    }, Number(newMessage.split(" ")[1]));
                } catch (e) {
                    player.sendError("§c" + e + e.stack, true);
                }

                break;
            case !!switchTest.match(/^eval$/):
                eventData.cancel = true;
                try {
                    eval(
                        newMessage.slice(
                            String(
                                world.getDynamicProperty(
                                    "andexdbSettings:chatCommandPrefix"
                                ) ?? "\\"
                            ).length + 5
                        )
                    );
                } catch (e) {
                    player.sendMessageB("§c" + e + e.stack);
                }

                break;
            case !!switchTest.match(/^warpset$/):
                eventData.cancel = true;
                let warpList = String(
                    world.getDynamicProperty("globalWarpListValues")
                ).split("||||"); /*
            console.warn("wasdqrte\\sanwqhieasdrt\\p\\nasqw".replaceAll(/(?<!\\p)\\n/g, "\n").replaceAll(/(?<!\\p)\\s/g, "\s").replaceAll(/(?<!\\p)\\0/g, "\0").replaceAll(/(?<!\\p)\\r/g, "\r").replaceAll(/(?<!\\p)\\t/g, "\t").replaceAll(/(?<!\\p)\\v/g, "\v").replaceAll(/(?<!\\p)\\f/g, "\f")*/ /*.replaceAll(/[\\x]/g, "\x").replaceAll(/[\\u]/g, "\u")*/ /*.replaceAll(/(?<!\\p)\\k/g, "\k").replaceAll(/(?<!\\p)\\p/g, ""))*/

                if (newMessage
                    .split(" ")
                    .slice(5)
                    .join(" ")
                    .escapeCharactersB(true).e == undefined)
                    switch (warpList.find(
                        (findWarp) => findWarp.split(", ")[0] ==
                            newMessage
                                .split(" ")
                                .slice(5)
                                .join(
                                    " "
                                ) /*.replaceAll(/(?<!\\p)\\n/g, "\n").replaceAll(/(?<!\\p)\\s/g, "\s").replaceAll(/(?<!\\p)\\0/g, "\0").replaceAll(/(?<!\\p)\\r/g, "\r").replaceAll(/(?<!\\p)\\t/g, "\t").replaceAll(/(?<!\\p)\\v/g, "\v").replaceAll(/(?<!\\p)\\f/g, "\f").replaceAll(/(?<!\\p)\\k/g, "\k").replaceAll(/(?<!\\p)\\p/g, "")*/
                                .replaceAll(", ", " ")
                                .replaceAll("|", "\\u007c")
                    ) == undefined) {
                        case false /*
                if (newMessage.split(" ").slice(5).join(" ").replaceAll(/(?<!\\p)\\n/g, "\n").replaceAll(/(?<!\\p)\\s/g, "\s").replaceAll(/(?<!\\p)\\0/g, "\0").replaceAll(/(?<!\\p)\\r/g, "\r").replaceAll(/(?<!\\p)\\t/g, "\t").replaceAll(/(?<!\\p)\\v/g, "\v").replaceAll(/(?<!\\p)\\f/g, "\f").replaceAll(/(?<!\\p)\\k/g, "\k").replaceAll(/(?<!\\p)\\p/g, "").replaceAll(", ", " ") == ""){*/ /*player.sendMessageB("§cError: missing required \"name\" field. "); */ /*break; */ /*}*/:
                            try {
                                warpList[warpList.findIndex(
                                    (warpItem) => warpItem.split(", ")[0] ==
                                        newMessage
                                            .split(" ")
                                            .slice(5)
                                            .join(
                                                " "
                                            ) /*.replaceAll(/(?<!\\p)\\n/g, "\n").replaceAll(/(?<!\\p)\\s/g, "\s").replaceAll(/(?<!\\p)\\0/g, "\0").replaceAll(/(?<!\\p)\\r/g, "\r").replaceAll(/(?<!\\p)\\t/g, "\t").replaceAll(/(?<!\\p)\\v/g, "\v").replaceAll(/(?<!\\p)\\f/g, "\f").replaceAll(/(?<!\\p)\\k/g, "\k").replaceAll(/(?<!\\p)\\p/g, "")*/
                                            .replaceAll(", ", " ")
                                            .replaceAll("|", "\\u007c")
                                )] = String(
                                    newMessage
                                        .split(" ")
                                        .slice(5)
                                        .join(" ")
                                        .replaceAll(/(?<!\\p)\\n/g, "\n")
                                        .replaceAll(/(?<!\\p)\\s/g, "s")
                                        .replaceAll(/(?<!\\p)\\0/g, "\0")
                                        .replaceAll(/(?<!\\p)\\r/g, "\r")
                                        .replaceAll(/(?<!\\p)\\t/g, "\t")
                                        .replaceAll(/(?<!\\p)\\v/g, "\v")
                                        .replaceAll(/(?<!\\p)\\f/g, "\f")
                                        .replaceAll(/(?<!\\p)\\k/g, "k")
                                        .replaceAll(/(?<!\\p)\\p/g, "")
                                        .replaceAll(", ", " ") +
                                    ", " +
                                    world.getDimension(
                                        newMessage.split(" ")[1]
                                    ).id +
                                    ", " +
                                    Number(newMessage.split(" ")[2]) +
                                    ", " +
                                    Number(newMessage.split(" ")[3]) +
                                    ", " +
                                    Number(newMessage.split(" ")[4])
                                );
                            } catch (e) {
                                player.sendMessageB("§c" + e + e.stack);
                                break;
                            }
                            try {
                                system.run(() => {
                                    world.setDynamicProperty(
                                        "globalWarpListValues",
                                        warpList.join("||||")
                                    );
                                });
                            } catch (e) {
                                player.sendMessageB("§c" + e + e.stack);
                            }
                            try {
                                player.sendMessageB(
                                    'Set global warp "' +
                                    newMessage
                                        .split(" ")
                                        .slice(5)
                                        .join(" ")
                                        .escapeCharacters(
                                            true
                                        ) /*.replaceAll(/(?<!\\p)\\n/g, "\n").replaceAll(/(?<!\\p)\\s/g, "\s").replaceAll(/(?<!\\p)\\0/g, "\0").replaceAll(/(?<!\\p)\\r/g, "\r").replaceAll(/(?<!\\p)\\t/g, "\t").replaceAll(/(?<!\\p)\\v/g, "\v").replaceAll(/(?<!\\p)\\f/g, "\f").replaceAll(/(?<!\\p)\\k/g, "\k").replaceAll(/(?<!\\p)\\p/g, "")*/
                                        .replaceAll(", ", " ") +
                                    '" at dimension: ' +
                                    newMessage.split(" ")[1] +
                                    ", x: " +
                                    newMessage.split(" ")[2] +
                                    ", y: " +
                                    newMessage.split(" ")[3] +
                                    ", z: " +
                                    newMessage.split(" ")[4] +
                                    ". "
                                );
                            } catch (e) {
                                player.sendMessageB("§c" + e + e.stack);
                            }
                            break;
                        case true:
                            try {
                                warpList.push(
                                    String(
                                        newMessage
                                            .split(" ")
                                            .slice(5)
                                            .join(
                                                " "
                                            ) /*.replaceAll(/(?<!\\p)\\n/g, "\n").replaceAll(/(?<!\\p)\\s/g, "\s").replaceAll(/(?<!\\p)\\0/g, "\0").replaceAll(/(?<!\\p)\\r/g, "\r").replaceAll(/(?<!\\p)\\t/g, "\t").replaceAll(/(?<!\\p)\\v/g, "\v").replaceAll(/(?<!\\p)\\f/g, "\f").replaceAll(/(?<!\\p)\\k/g, "\k").replaceAll(/(?<!\\p)\\p/g, "")*/
                                            .replaceAll(", ", " ")
                                            .replaceAll("|", "\\u007c") +
                                        ", " +
                                        newMessage.split(" ")[1] +
                                        ", " +
                                        newMessage.split(" ")[2] +
                                        ", " +
                                        newMessage.split(" ")[3] +
                                        ", " +
                                        newMessage.split(" ")[4]
                                    )
                                );
                            } catch (e) {
                                player.sendMessageB("§c" + e + e.stack);
                            }
                            try {
                                system.run(() => {
                                    world.setDynamicProperty(
                                        "globalWarpListValues",
                                        warpList.join("||||")
                                    );
                                });
                            } catch (e) {
                                player.sendMessageB("§c" + e + e.stack);
                            }
                            try {
                                player.sendMessageB(
                                    'Added global warp "' +
                                    newMessage
                                        .split(" ")
                                        .slice(5)
                                        .join(" ")
                                        .escapeCharacters(
                                            true
                                        ) /*.replaceAll(/(?<!\\p)\\n/g, "\n").replaceAll(/(?<!\\p)\\s/g, "\s").replaceAll(/(?<!\\p)\\0/g, "\0").replaceAll(/(?<!\\p)\\r/g, "\r").replaceAll(/(?<!\\p)\\t/g, "\t").replaceAll(/(?<!\\p)\\v/g, "\v").replaceAll(/(?<!\\p)\\f/g, "\f").replaceAll(/(?<!\\p)\\k/g, "\k").replaceAll(/(?<!\\p)\\p/g, "")*/
                                        .replaceAll(", ", " ") +
                                    '" at dimension: ' +
                                    newMessage.split(" ")[1] +
                                    ", x: " +
                                    newMessage.split(" ")[2] +
                                    ", y: " +
                                    newMessage.split(" ")[3] +
                                    ", z: " +
                                    newMessage.split(" ")[4] +
                                    ". "
                                );
                            } catch (e) {
                                player.sendMessageB("§c" + e + e.stack);
                            }
                            break;
                    }
                break;
            case !!switchTest.match(/^warpremove$/):
                eventData.cancel = true;
                let warpListB = String(
                    world.getDynamicProperty("globalWarpListValues")
                ).split("||||"); /*
            console.warn("wasdqrte\\sanwqhieasdrt\\p\\nasqw".replaceAll(/(?<!\\p)\\n/g, "\n").replaceAll(/(?<!\\p)\\s/g, "\s").replaceAll(/(?<!\\p)\\0/g, "\0").replaceAll(/(?<!\\p)\\r/g, "\r").replaceAll(/(?<!\\p)\\t/g, "\t").replaceAll(/(?<!\\p)\\v/g, "\v").replaceAll(/(?<!\\p)\\f/g, "\f")*/ /*.replaceAll(/[\\x]/g, "\x").replaceAll(/[\\u]/g, "\u")*/ /*.replaceAll(/(?<!\\p)\\k/g, "\k").replaceAll(/(?<!\\p)\\p/g, ""))*/

                switch (warpListB.find(
                    (findWarp) => findWarp
                        .split(", ")[0]
                        .escapeCharacters(true)
                        .replaceAll(", ", " ")
                        .replaceAll("|", "\\u007c") ==
                        newMessage
                            .split(" ")
                            .slice(1)
                            .join(" ")
                            .escapeCharacters(
                                true
                            ) /*.replaceAll(/(?<!\\p)\\n/g, "\n").replaceAll(/(?<!\\p)\\s/g, "\s").replaceAll(/(?<!\\p)\\0/g, "\0").replaceAll(/(?<!\\p)\\r/g, "\r").replaceAll(/(?<!\\p)\\t/g, "\t").replaceAll(/(?<!\\p)\\v/g, "\v").replaceAll(/(?<!\\p)\\f/g, "\f").replaceAll(/(?<!\\p)\\k/g, "\k").replaceAll(/(?<!\\p)\\p/g, "")*/
                            .replaceAll(", ", " ")
                            .replaceAll("|", "\\u007c")
                ) == undefined) {
                    case false:
                        try {
                            system.run(() => {
                                warpListB[warpListB.findIndex(
                                    (findWarp) => findWarp
                                        .split(", ")[0]
                                        .escapeCharacters(true)
                                        .replaceAll(", ", " ")
                                        .replaceAll("|", "\\u007c") ==
                                        newMessage
                                            .split(" ")
                                            .slice(1)
                                            .join(" ")
                                            .escapeCharacters(
                                                true
                                            ) /*.replaceAll(/(?<!\\p)\\n/g, "\n").replaceAll(/(?<!\\p)\\s/g, "\s").replaceAll(/(?<!\\p)\\0/g, "\0").replaceAll(/(?<!\\p)\\r/g, "\r").replaceAll(/(?<!\\p)\\t/g, "\t").replaceAll(/(?<!\\p)\\v/g, "\v").replaceAll(/(?<!\\p)\\f/g, "\f").replaceAll(/(?<!\\p)\\k/g, "\k").replaceAll(/(?<!\\p)\\p/g, "")*/
                                            .replaceAll(", ", " ")
                                            .replaceAll("|", "\\u007c")
                                )] = undefined;
                                world.setDynamicProperty(
                                    "globalWarpListValues",
                                    warpListB.join("||||")
                                );
                            });
                        } catch (e) {
                            player.sendMessageB("§c" + e + e.stack);
                        }
                        try {
                            player.sendMessageB(
                                'Removed global warp with name "' +
                                newMessage
                                    .split(" ")
                                    .slice(1)
                                    .join(" ")
                                    .escapeCharacters(
                                        true
                                    ) /*.replaceAll(/(?<!\\p)\\n/g, "\n").replaceAll(/(?<!\\p)\\s/g, "\s").replaceAll(/(?<!\\p)\\0/g, "\0").replaceAll(/(?<!\\p)\\r/g, "\r").replaceAll(/(?<!\\p)\\t/g, "\t").replaceAll(/(?<!\\p)\\v/g, "\v").replaceAll(/(?<!\\p)\\f/g, "\f").replaceAll(/(?<!\\p)\\k/g, "\k").replaceAll(/(?<!\\p)\\p/g, "")*/
                                    .replaceAll(", ", " ") +
                                '". '
                            );
                        } catch (e) {
                            player.sendMessageB("§c" + e + e.stack);
                        }
                        break;
                    case true:
                        try {
                            player.sendMessageB(
                                '§cError: could not find global warp "' +
                                newMessage
                                    .split(" ")
                                    .slice(1)
                                    .join(" ")
                                    .escapeCharacters(
                                        true
                                    ) /*.replaceAll(/(?<!\\p)\\n/g, "\n").replaceAll(/(?<!\\p)\\s/g, "\s").replaceAll(/(?<!\\p)\\0/g, "\0").replaceAll(/(?<!\\p)\\r/g, "\r").replaceAll(/(?<!\\p)\\t/g, "\t").replaceAll(/(?<!\\p)\\v/g, "\v").replaceAll(/(?<!\\p)\\f/g, "\f").replaceAll(/(?<!\\p)\\k/g, "\k").replaceAll(/(?<!\\p)\\p/g, "")*/
                                    .replaceAll(", ", " ") +
                                '". '
                            );
                        } catch (e) {
                            player.sendMessageB("§c" + e + e.stack);
                        }
                        break;
                }
                break;
            case !!switchTest.match(/^warp$/):
                eventData.cancel = true;
                let warpListD = String(
                    world.getDynamicProperty("globalWarpListValues")
                ).split("||||");
                let warp = undefined; /*
            console.warn("wasdqrte\\sanwqhieasdrt\\p\\nasqw".replaceAll(/(?<!\\p)\\n/g, "\n").replaceAll(/(?<!\\p)\\s/g, "\s").replaceAll(/(?<!\\p)\\0/g, "\0").replaceAll(/(?<!\\p)\\r/g, "\r").replaceAll(/(?<!\\p)\\t/g, "\t").replaceAll(/(?<!\\p)\\v/g, "\v").replaceAll(/(?<!\\p)\\f/g, "\f")*/ /*.replaceAll(/[\\x]/g, "\x").replaceAll(/[\\u]/g, "\u")*/ /*.replaceAll(/(?<!\\p)\\k/g, "\k").replaceAll(/(?<!\\p)\\p/g, ""))*/

                switch (warpListD.find(
                    (findWarp) => findWarp
                        .split(", ")[0]
                        .escapeCharacters(true)
                        .replaceAll("|", "\\u007c") ==
                        newMessage
                            .split(" ")
                            .slice(1)
                            .join(" ")
                            .escapeCharacters(
                                true
                            ) /*.replaceAll(/(?<!\\p)\\n/g, "\n").replaceAll(/(?<!\\p)\\s/g, "\s").replaceAll(/(?<!\\p)\\0/g, "\0").replaceAll(/(?<!\\p)\\r/g, "\r").replaceAll(/(?<!\\p)\\t/g, "\t").replaceAll(/(?<!\\p)\\v/g, "\v").replaceAll(/(?<!\\p)\\f/g, "\f").replaceAll(/(?<!\\p)\\k/g, "\k").replaceAll(/(?<!\\p)\\p/g, "")*/
                            .replaceAll("|", "\\u007c")
                ) == undefined) {
                    case false:
                        try {
                            warp = warpListD
                                .find(
                                    (findWarp) => findWarp
                                        .split(", ")[0]
                                        .escapeCharacters(true)
                                        .replaceAll("|", "\\u007c") ==
                                        newMessage
                                            .split(" ")
                                            .slice(1)
                                            .join(" ")
                                            .escapeCharacters(
                                                true
                                            ) /*.replaceAll(/(?<!\\p)\\n/g, "\n").replaceAll(/(?<!\\p)\\s/g, "\s").replaceAll(/(?<!\\p)\\0/g, "\0").replaceAll(/(?<!\\p)\\r/g, "\r").replaceAll(/(?<!\\p)\\t/g, "\t").replaceAll(/(?<!\\p)\\v/g, "\v").replaceAll(/(?<!\\p)\\f/g, "\f").replaceAll(/(?<!\\p)\\k/g, "\k").replaceAll(/(?<!\\p)\\p/g, "")*/
                                            .replaceAll("|", "\\u007c")
                                )
                                .split(", ");
                        } catch (e) {
                            player.sendMessageB("§c" + e + e.stack);
                        }
                        try {
                            system.run(() => {
                                player.teleport(
                                    {
                                        x: Number(warp[2]),
                                        y: Number(warp[3]),
                                        z: Number(warp[4]),
                                    },
                                    {
                                        dimension: world.getDimension(
                                            String(warp[1])
                                        ),
                                        keepVelocity: false,
                                    }
                                );
                            });
                        } catch (e) {
                            player.sendMessageB("§c" + e + e.stack);
                        }
                        try {
                            player.sendMessageB(
                                'Warped to "' +
                                newMessage
                                    .split(" ")
                                    .slice(1)
                                    .join(" ")
                                    .escapeCharacters(
                                        true
                                    ) /*.replaceAll(/(?<!\\p)\\n/g, "\n").replaceAll(/(?<!\\p)\\s/g, "\s").replaceAll(/(?<!\\p)\\0/g, "\0").replaceAll(/(?<!\\p)\\r/g, "\r").replaceAll(/(?<!\\p)\\t/g, "\t").replaceAll(/(?<!\\p)\\v/g, "\v").replaceAll(/(?<!\\p)\\f/g, "\f").replaceAll(/(?<!\\p)\\k/g, "\k").replaceAll(/(?<!\\p)\\p/g, "")*/ +
                                '". '
                            );
                        } catch (e) {
                            player.sendMessageB("§c" + e + e.stack);
                        }
                        break;
                    case true:
                        try {
                            player.sendMessageB(
                                '§cError: could not find global warp "' +
                                newMessage
                                    .split(" ")
                                    .slice(1)
                                    .join(" ")
                                    .escapeCharacters(
                                        true
                                    ) /*.replaceAll(/(?<!\\p)\\n/g, "\n").replaceAll(/(?<!\\p)\\s/g, "\s").replaceAll(/(?<!\\p)\\0/g, "\0").replaceAll(/(?<!\\p)\\r/g, "\r").replaceAll(/(?<!\\p)\\t/g, "\t").replaceAll(/(?<!\\p)\\v/g, "\v").replaceAll(/(?<!\\p)\\f/g, "\f").replaceAll(/(?<!\\p)\\k/g, "\k").replaceAll(/(?<!\\p)\\p/g, "")*/ +
                                '". '
                            );
                        } catch (e) {
                            player.sendMessageB("§c" + e + e.stack);
                        }
                        break;
                }
                break;
            case !!switchTest.match(/^warplistdetails$/):
                eventData.cancel = true;
                let warpListC = String(
                    world.getDynamicProperty("globalWarpListValues")
                ).split("||||");
                if (warpListC.length == 1) {
                    player.sendMessageB(
                        "You have no global warps, set them with \\warpset"
                    );
                } else {
                    try {
                        player.sendMessageB(
                            warpListC.join("\n").escapeCharacters(true)
                        );
                    } catch (e) {
                        player.sendMessageB("§c" + e + e.stack);
                    }
                }
                break;
            case !!switchTest.match(/^warplist$/):
                eventData.cancel = true;
                let warpListE = String(
                    world.getDynamicProperty("globalWarpListValues")
                ).split("||||");
                for (let i in warpListE) {
                    warpListE[i] = warpListE[i].split(", ")[0];
                }
                if (warpListE.length == 1) {
                    player.sendMessageB(
                        "You have no global warps, set them with \\warpset"
                    );
                } else {
                    try {
                        player.sendMessageB(
                            warpListE.join("\n").escapeCharacters(true)
                        );
                    } catch (e) {
                        player.sendMessageB("§c" + e + e.stack);
                    }
                }
                break;
            case !!switchTest.match(/^warplistrawdata$/):
                eventData.cancel = true;
                try {
                    player.sendMessageB(
                        "Global Warp List Raw Data: \n" +
                        String(
                            world.getDynamicProperty("globalWarpListValues")
                        )
                    );
                } catch (e) {
                    player.sendMessageB("§c" + e + e.stack);
                }
                break;
            case !!switchTest.match(/^warpreset$/):
                eventData.cancel = true;
                try {
                    system.run(() => {
                        world.setDynamicProperty("globalWarpListValues");
                    });
                } catch (e) {
                    player.sendMessageB("§c" + e + e.stack);
                }
                try {
                    player.sendMessageB("Global warps lists has been reset. ");
                } catch (e) {
                    player.sendMessageB("§c" + e + e.stack);
                }
                break;
            case !!switchTest.match(/^wset$/):
                eventData.cancel = true;
                let wList = String(player.getDynamicProperty("warpList")).split(
                    "||||"
                ); /*
            console.warn("wasdqrte\\sanwqhieasdrt\\p\\nasqw".replaceAll(/(?<!\\p)\\n/g, "\n").replaceAll(/(?<!\\p)\\s/g, "\s").replaceAll(/(?<!\\p)\\0/g, "\0").replaceAll(/(?<!\\p)\\r/g, "\r").replaceAll(/(?<!\\p)\\t/g, "\t").replaceAll(/(?<!\\p)\\v/g, "\v").replaceAll(/(?<!\\p)\\f/g, "\f")*/ /*.replaceAll(/[\\x]/g, "\x").replaceAll(/[\\u]/g, "\u")*/ /*.replaceAll(/(?<!\\p)\\k/g, "\k").replaceAll(/(?<!\\p)\\p/g, ""))*/

                switch (wList.find(
                    (findWarp) => findWarp
                        .split(", ")[0]
                        .escapeCharacters(true)
                        .replaceAll("|", "\\u007c") ==
                        newMessage
                            .split(" ")
                            .slice(5)
                            .join(" ")
                            .escapeCharacters(true)
                            .replaceAll("|", "\\u007c")
                ) == undefined) {
                    case false /*
                if (newMessage.split(" ").slice(5).join(" ").replaceAll(/(?<!\\p)\\n/g, "\n").replaceAll(/(?<!\\p)\\s/g, "\s").replaceAll(/(?<!\\p)\\0/g, "\0").replaceAll(/(?<!\\p)\\r/g, "\r").replaceAll(/(?<!\\p)\\t/g, "\t").replaceAll(/(?<!\\p)\\v/g, "\v").replaceAll(/(?<!\\p)\\f/g, "\f").replaceAll(/(?<!\\p)\\k/g, "\k").replaceAll(/(?<!\\p)\\p/g, "").replaceAll(", ", " ") == ""){*/ /*eventData.sender.sendMessage("§cError: missing required \"name\" field. "); */ /*break; */ /*}*/:
                        try {
                            wList[wList.findIndex(
                                (warpItem) => warpItem
                                    .split(", ")[0]
                                    .escapeCharacters(true)
                                    .replaceAll("|", "\\u007c") ==
                                    newMessage
                                        .split(" ")
                                        .slice(5)
                                        .join(" ")
                                        .escapeCharacters(true)
                                        .replaceAll("|", "\\u007c")
                            )] = String(
                                newMessage
                                    .split(" ")
                                    .slice(5)
                                    .join(" ")
                                    .replaceAll(", ", " ")
                                    .replaceAll("|", "\\u007c") +
                                ", " +
                                world.getDimension(newMessage.split(" ")[1])
                                    .id +
                                ", " +
                                Number(newMessage.split(" ")[2]) +
                                ", " +
                                Number(newMessage.split(" ")[3]) +
                                ", " +
                                Number(newMessage.split(" ")[4])
                            );
                        } catch (e) {
                            player.sendError("§c" + e + e.stack, true);
                            break;
                        }
                        try {
                            system.run(() => {
                                player.setDynamicProperty(
                                    "warpList",
                                    wList.join("||||")
                                );
                            });
                        } catch (e) {
                            player.sendError("§c" + e + e.stack, true);
                        }
                        try {
                            eventData.sender.sendMessage(
                                'Set warp "' +
                                newMessage
                                    .split(" ")
                                    .slice(5)
                                    .join(" ")
                                    .escapeCharacters(true) +
                                '" at dimension: ' +
                                newMessage.split(" ")[1] +
                                ", x: " +
                                newMessage.split(" ")[2] +
                                ", y: " +
                                newMessage.split(" ")[3] +
                                ", z: " +
                                newMessage.split(" ")[4] +
                                ". "
                            );
                        } catch (e) {
                            player.sendError("§c" + e + e.stack, true);
                        }
                        break;
                    case true:
                        try {
                            wList.push(
                                String(
                                    newMessage
                                        .split(" ")
                                        .slice(5)
                                        .join(" ")
                                        .replaceAll(", ", " ")
                                        .replaceAll("|", "\\u007c") +
                                    ", " +
                                    newMessage.split(" ")[1] +
                                    ", " +
                                    newMessage.split(" ")[2] +
                                    ", " +
                                    newMessage.split(" ")[3] +
                                    ", " +
                                    newMessage.split(" ")[4]
                                )
                            );
                        } catch (e) {
                            player.sendError("§c" + e + e.stack, true);
                        }
                        try {
                            system.run(() => {
                                player.setDynamicProperty(
                                    "warpList",
                                    wList.join("||||")
                                );
                            });
                        } catch (e) {
                            player.sendError("§c" + e + e.stack, true);
                        }
                        try {
                            eventData.sender.sendMessage(
                                'Added warp "' +
                                newMessage
                                    .split(" ")
                                    .slice(5)
                                    .join(" ")
                                    .escapeCharacters(true) +
                                '" at dimension: ' +
                                newMessage.split(" ")[1] +
                                ", x: " +
                                newMessage.split(" ")[2] +
                                ", y: " +
                                newMessage.split(" ")[3] +
                                ", z: " +
                                newMessage.split(" ")[4] +
                                ". "
                            );
                        } catch (e) {
                            player.sendError("§c" + e + e.stack, true);
                        }
                        break;
                }
                break;
            case !!switchTest.match(/^wremove$/):
                eventData.cancel = true;
                let wListB = String(
                    player.getDynamicProperty("warpList")
                ).split("||||"); /*
            console.warn("wasdqrte\\sanwqhieasdrt\\p\\nasqw".replaceAll(/(?<!\\p)\\n/g, "\n").replaceAll(/(?<!\\p)\\s/g, "\s").replaceAll(/(?<!\\p)\\0/g, "\0").replaceAll(/(?<!\\p)\\r/g, "\r").replaceAll(/(?<!\\p)\\t/g, "\t").replaceAll(/(?<!\\p)\\v/g, "\v").replaceAll(/(?<!\\p)\\f/g, "\f")*/ /*.replaceAll(/[\\x]/g, "\x").replaceAll(/[\\u]/g, "\u")*/ /*.replaceAll(/(?<!\\p)\\k/g, "\k").replaceAll(/(?<!\\p)\\p/g, ""))*/

                switch (wListB.find(
                    (findWarp) => findWarp
                        .split(", ")[0]
                        .escapeCharacters(true)
                        .replaceAll("|", "\\u007c") ==
                        newMessage
                            .split(" ")
                            .slice(1)
                            .join(" ")
                            .escapeCharacters(true)
                            .replaceAll("|", "\\u007c")
                ) == undefined) {
                    case false:
                        try {
                            system.run(() => {
                                wListB[wListB.findIndex(
                                    (findWarp) => findWarp
                                        .split(", ")[0]
                                        .escapeCharacters(true)
                                        .replaceAll("|", "\\u007c") ==
                                        newMessage
                                            .split(" ")
                                            .slice(1)
                                            .join(" ")
                                            .escapeCharacters(true)
                                            .replaceAll("|", "\\u007c")
                                )] = undefined;
                                player.setDynamicProperty(
                                    "warpList",
                                    wListB.join("||||")
                                );
                            });
                        } catch (e) {
                            player.sendError("§c" + e + e.stack, true);
                        }
                        try {
                            eventData.sender.sendMessage(
                                'Removed warp with name "' +
                                newMessage
                                    .split(" ")
                                    .slice(1)
                                    .join(" ")
                                    .escapeCharacters(true) +
                                '". '
                            );
                        } catch (e) {
                            player.sendError("§c" + e + e.stack, true);
                        }
                        break;
                    case true:
                        try {
                            eventData.sender.sendMessage(
                                '§cError: could not find warp "' +
                                newMessage
                                    .split(" ")
                                    .slice(1)
                                    .join(" ")
                                    .escapeCharacters(true) +
                                '". '
                            );
                        } catch (e) {
                            player.sendError("§c" + e + e.stack, true);
                        }
                        break;
                }
                break;
            case !!switchTest.match(/^w$/):
                eventData.cancel = true;
                let wListD = String(
                    player.getDynamicProperty("warpList")
                ).split("||||");
                let warpB = undefined;
                switch (wListD.find(
                    (findWarp) => findWarp.split(", ")[0] ==
                        newMessage
                            .split(" ")
                            .slice(1)
                            .join(" ")
                            .escapeCharacters(true)
                            .replaceAll(", ", " ")
                ) == undefined) {
                    case false:
                        try {
                            warpB = wListD
                                .find(
                                    (findWarp) => findWarp.split(", ")[0] ==
                                        newMessage
                                            .split(" ")
                                            .slice(1)
                                            .join(" ")
                                            .escapeCharacters(true)
                                            .replaceAll("|", "\\u007c")
                                )
                                .split(", ");
                        } catch (e) {
                            player.sendError("§c" + e + e.stack, true);
                        }
                        try {
                            system.run(() => {
                                player.teleport(
                                    {
                                        x: Number(warpB[2]),
                                        y: Number(warpB[3]),
                                        z: Number(warpB[4]),
                                    },
                                    {
                                        dimension: world.getDimension(
                                            String(warpB[1])
                                        ),
                                        keepVelocity: false,
                                    }
                                );
                            });
                        } catch (e) {
                            player.sendError("§c" + e + e.stack, true);
                        }
                        try {
                            eventData.sender.sendMessage(
                                'Warped to "' +
                                newMessage
                                    .split(" ")
                                    .slice(1)
                                    .join(" ")
                                    .escapeCharacters(true) +
                                '". '
                            );
                        } catch (e) {
                            player.sendError("§c" + e + e.stack, true);
                        }
                        break;
                    case true:
                        try {
                            eventData.sender.sendMessage(
                                '§cError: could not find warp "' +
                                newMessage
                                    .split(" ")
                                    .slice(1)
                                    .join(" ")
                                    .escapeCharacters(true) +
                                '". '
                            );
                        } catch (e) {
                            player.sendError("§c" + e + e.stack, true);
                        }
                        break;
                }
                break;
            case !!switchTest.match(/^wlistdetails$/):
                eventData.cancel = true;
                let wListC = String(
                    player.getDynamicProperty("warpList")
                ).split("||||");
                if (wListC.length == 1) {
                    eventData.sender.sendMessage(
                        "You have no warps, set them with \\wset"
                    );
                } else {
                    try {
                        eventData.sender.sendMessage(
                            wListC.join("\n").escapeCharacters(true)
                        );
                    } catch (e) {
                        player.sendError("§c" + e + e.stack, true);
                    }
                }
                break;
            case !!switchTest.match(/^wlist$/):
                eventData.cancel = true;
                let wListE = String(
                    player.getDynamicProperty("warpList")
                ).split("||||");
                for (let i in wListE) {
                    wListE[i] = wListE[i].split(", ")[0];
                }
                if (wListE.length == 1) {
                    eventData.sender.sendMessage(
                        "You have no warps, set them with \\wset"
                    );
                } else {
                    try {
                        eventData.sender.sendMessage(
                            wListE.join("\n").escapeCharacters(true)
                        );
                    } catch (e) {
                        player.sendError("§c" + e + e.stack, true);
                    }
                }
                break;
            case !!switchTest.match(/^wlistrawdata$/):
                eventData.cancel = true;
                try {
                    eventData.sender.sendMessage(
                        "Warp List Raw Data: \n" +
                        String(player.getDynamicProperty("warpList"))
                    );
                } catch (e) {
                    player.sendError("§c" + e + e.stack, true);
                }
                break;
            case !!switchTest.match(/^wreset$/):
                eventData.cancel = true;
                try {
                    system.run(() => {
                        player.setDynamicProperty("warpList", undefined);
                    });
                } catch (e) {
                    player.sendError("§c" + e + e.stack, true);
                }
                try {
                    eventData.sender.sendMessage(
                        "Warps lists has been reset. "
                    );
                } catch (e) {
                    player.sendError("§c" + e + e.stack, true);
                }
                break;
            case !!switchTest.match(/^up$/):
                eventData.cancel = true;
                try {
                    system.run(() => {
                        try {
                            if (player.dimension
                                .getBlock(player.location)
                                .above(Number(newMessage.split(" ")[1]) - 1)
                                .typeId == "minecraft:air" &&
                                ((newMessage.split(" ")[2]?.toLowerCase() !=
                                    "false" &&
                                    newMessage.split(" ")[2] != "0") ||
                                    newMessage.split(" ")[2] == undefined)) {
                                player.dimension
                                    .getBlock(player.location)
                                    .above(Number(newMessage.split(" ")[1]) - 1)
                                    .setType("minecraft:glass");
                            }
                        } catch { }
                        player.teleport(
                            Vector.add(
                                roundVector3ToMiddleOfBlockFloorY(
                                    player.location
                                ),
                                {
                                    x: 0,
                                    y: Number(newMessage.split(" ")[1]),
                                    z: 0,
                                }
                            )
                        );
                        eventData.sender.sendMessage(String());
                    });
                } catch (e) {
                    player.sendError("§c" + e + e.stack, true);
                }
                break;
            case !!switchTest.match(/^top$/):
                eventData.cancel = true;
                try {
                    const flags = evaluateParameters(switchTestB, [
                        "presetText",
                        "f-lp",
                    ]).args[1] as { l: boolean; p: boolean; };
                    system.run(() => {
                        let block = player.dimension.getBlockBelow(
                            {
                                x: player.x,
                                y: player.dimension.heightRange.max,
                                z: player.z,
                            },
                            {
                                includeLiquidBlocks: flags.l,
                                includePassableBlocks: flags.p,
                            }
                        );
                        if (block != undefined) {
                            player.teleport(
                                {
                                    x: player.location.x,
                                    y: block.y + 1,
                                    z: player.location.z,
                                },
                                {}
                            );
                        } else {
                            eventData.sender.sendMessage(
                                "§4No block could be found. "
                            );
                        }
                        eventData.sender.sendMessage(
                            "Teleported to highest block at coordinates: " +
                            player.location.x +
                            ", " +
                            player.location.y +
                            ", " +
                            player.location.z
                        );
                        targetSelectorAllListE(
                            "@a [tag=canSeeCustomChatCommandFeedbackFromMods]",
                            player.location.x +
                            " " +
                            player.location.y +
                            " " +
                            player.location.z
                        ).forEach((entity) => {
                            (entity as Player).sendMessage(
                                "Teleported to highest block at coordinates: " +
                                player.location.x +
                                ", " +
                                player.location.y +
                                ", " +
                                player.location.z
                            );
                        });
                    });
                } catch (e) {
                    player.sendError("§c" + e + e.stack, true);
                }
                break;
            case !!switchTest.match(/^ground$/):
                eventData.cancel = true;
                try {
                    const flags = evaluateParameters(switchTestB, [
                        "presetText",
                        "f-lp",
                    ]).args[1] as { l: boolean; p: boolean; };
                    system.run(() => {
                        let block = player.dimension.getBlockBelow(player, {
                            includeLiquidBlocks: flags.l,
                            includePassableBlocks: flags.p,
                        });
                        if (block != undefined) {
                            player.teleport(
                                {
                                    x: player.location.x,
                                    y: block.y + 1,
                                    z: player.location.z,
                                },
                                {}
                            );
                        } else {
                            eventData.sender.sendMessage(
                                "§4No block could be found. "
                            );
                        }
                        eventData.sender.sendMessage(
                            "Teleported to highest block at coordinates: " +
                            player.location.x +
                            ", " +
                            player.location.y +
                            ", " +
                            player.location.z
                        );
                        targetSelectorAllListE(
                            "@a [tag=canSeeCustomChatCommandFeedbackFromMods]",
                            player.location.x +
                            " " +
                            player.location.y +
                            " " +
                            player.location.z
                        ).forEach((entity) => {
                            (entity as Player).sendMessage(
                                "Teleported to highest block at coordinates: " +
                                player.location.x +
                                ", " +
                                player.location.y +
                                ", " +
                                player.location.z
                            );
                        });
                    });
                } catch (e) {
                    player.sendError("§c" + e + e.stack, true);
                }
                break;
            case !!switchTest.match(/^printlayers$/):
                eventData.cancel = true;
                try {
                    system.run(() => {
                        let block = getTopSolidBlock(
                            player.dimension.getBlock(player.location),
                            player.dimension
                        );
                        let messageCustom = "";
                        let a = 0;
                        while (a != 1) {
                            if (messageCustom.endsWith(block.typeId + "; ")) {
                            } else {
                                messageCustom =
                                    messageCustom +
                                    block.y +
                                    ". " +
                                    block.typeId +
                                    "; ";
                            }
                            try {
                                block = block.below(1);
                            } catch {
                                a = 1;
                            }
                        }
                        player.sendMessageB(messageCustom);
                        eventData.sender.sendMessage(
                            "Teleported to highest block at coordinates: " +
                            player.location.x +
                            ", " +
                            player.location.y +
                            ", " +
                            player.location.z
                        );
                        targetSelectorAllListE(
                            "@a [tag=canSeeCustomChatCommandFeedbackFromMods]",
                            player.location.x +
                            " " +
                            player.location.y +
                            " " +
                            player.location.z
                        ).forEach((entity) => {
                            (entity as Player).sendMessage(
                                "Printed blocks at: x: " +
                                player.location.x +
                                ", z: " +
                                player.location.z
                            );
                        });
                    });
                } catch (e) {
                    player.sendError("§c" + e + e.stack, true);
                }
                break;
            case !!switchTest.match(/^thru$/):
                {
                    eventData.cancel = true;
                    // player.dimension.getBlockFromRay(player.location, player.getViewDirection(), {includeTypes: ["minecraft:air", "air"]})
                    let la = player.getBlockFromViewDirection();
                    if (!!!la) {
                        player.sendMessageB(
                            "§cError: No obstruction found to go through. "
                        );
                    } else {
                        let l = Vector3Utils.add(
                            Vector3Utils.add(
                                la.block,
                                Vector3Utils.scale(
                                    VECTOR3_ONE,
                                    0.01
                                )
                            ),
                            Vector3Utils.scale(la.faceLocation, 0.98)
                        );
                        let rot = player.getRotation();
                        for (let i = 0; i < 100 &&
                            !(
                                tryget(
                                    () => player.dimension.getBlock(l).isAir
                                ) &&
                                (tryget(
                                    () => player.dimension.getBlock(l).above()
                                        .isAir
                                ) ||
                                    tryget(
                                        () => player.dimension.getBlock(l).below()
                                            .isAir
                                    ))
                            ) &&
                            l.y >= player.dimension.heightRange.min - 1; i++) {
                            l = caretNotationC(l, VECTOR3_FORWARD, rot);
                        }
                        l.y <= player.dimension.heightRange.min + 2
                            ? player.sendMessageB(
                                "§cError: The other side of this obstruction is void, if you want to be able to go to the other side even if it is in the void then just use \\vthru. "
                            )
                            : player.dimension.getBlock(l).isAir &&
                                player.dimension.getBlock(l).below().isAir
                                ? tryrun(() => {
                                    try {
                                        srun(() => {
                                            player.teleport(
                                                roundVector3ToMiddleOfBlockFloorY(
                                                    player.dimension
                                                        .getBlock(l)
                                                        .below().location
                                                )
                                            );
                                        });
                                    } catch (e) {
                                        player.sendError(
                                            "§c" + e + e.stack,
                                            true
                                        );
                                    }
                                })
                                : player.dimension.getBlock(l).isAir &&
                                    player.dimension.getBlock(l).above().isAir
                                    ? tryrun(() => {
                                        try {
                                            srun(() => {
                                                player.teleport(
                                                    roundVector3ToMiddleOfBlock(
                                                        player.dimension.getBlock(l)
                                                            .location
                                                    )
                                                );
                                            });
                                        } catch (e) {
                                            player.sendError(
                                                "§c" + e + e.stack,
                                                true
                                            );
                                        }
                                    })
                                    : player.sendMessageB(
                                        "§cError: Unable to find other side of obstruction. "
                                    );
                    }
                }
                break;
            case !!switchTest.match(/^pthru$/):
                {
                    eventData.cancel = true;
                    const args: { l: boolean; s: boolean; p: boolean; } = evaluateParameters(switchTestB, ["presetText", "f-lsp"])
                        .args as any;
                    // player.dimension.getBlockFromRay(player.location, player.getViewDirection(), {includeTypes: ["minecraft:air", "air"]})
                    let la = player.getBlockFromViewDirection();
                    if (!!!la) {
                        player.sendMessageB(
                            "§cError: No obstruction found to go through. "
                        );
                    } else {
                        let l = Vector3Utils.add(
                            Vector3Utils.add(
                                la.block,
                                Vector3Utils.scale(
                                    VECTOR3_ONE,
                                    0.01
                                )
                            ),
                            Vector3Utils.scale(la.faceLocation, 0.98)
                        );
                        let rot = player.getRotation();
                        for (let i = 0; i < 100 &&
                            !tryget(() => ((b) => b.isAir ||
                                (b.isSolid && args.s) ||
                                (!b.isSolid && args.p && !b.isAir) ||
                                (b.isLiquid && args.l))(
                                    player.dimension.getBlock(l)
                                )
                            ) &&
                            l.y >= player.dimension.heightRange.min - 1; i++) {
                            l = caretNotationC(l, VECTOR3_FORWARD, rot);
                        }
                        l.y <= player.dimension.heightRange.min + 2
                            ? player.sendMessageB(
                                "§cError: The other side of this obstruction is void, if you want to be able to go to the other side even if it is in the void then just use \\vthru. "
                            )
                            : ((b) => b.isAir ||
                                (b.isSolid && args.s) ||
                                (!b.isSolid && args.p) ||
                                (b.isLiquid && args.l))(
                                    player.dimension.getBlock(l)
                                )
                                ? tryrun(() => {
                                    try {
                                        srun(() => {
                                            player.teleport(
                                                roundVector3ToMiddleOfBlockFloorY(
                                                    player.dimension.getBlock(l)
                                                        .location
                                                )
                                            );
                                        });
                                    } catch (e) {
                                        player.sendError(
                                            "§c" + e + e.stack,
                                            true
                                        );
                                    }
                                })
                                : player.sendMessageB(
                                    "§cError: Unable to find other side of obstruction. "
                                );
                    }
                }
                break;
            case !!switchTest.match(/^vthru$/):
                {
                    eventData.cancel = true;
                    let la = player.getBlockFromViewDirection();
                    if (!!!la) {
                        player.sendMessageB(
                            "§cError: No obstruction found to go through. "
                        );
                    } else {
                        let l = Vector3Utils.add(
                            Vector3Utils.add(
                                la.block,
                                Vector3Utils.scale(
                                    VECTOR3_ONE,
                                    0.01
                                )
                            ),
                            Vector3Utils.scale(la.faceLocation, 0.98)
                        );
                        let rot = player.getRotation();
                        for (let i = 0; i < 100 &&
                            !(
                                tryget(
                                    () => player.dimension.getBlock(l).isAir
                                ) &&
                                (tryget(
                                    () => player.dimension.getBlock(l).above()
                                        .isAir
                                ) ||
                                    tryget(
                                        () => player.dimension.getBlock(l).below()
                                            .isAir
                                    ))
                            ) &&
                            l.y >= player.dimension.heightRange.min - 2; i++) {
                            l = caretNotationC(l, VECTOR3_FORWARD, rot);
                        }
                        (tryget(
                            () => player.dimension.getBlock(l).isAir &&
                                player.dimension.getBlock(l).below().isAir
                        ) ?? l.y <= player.dimension.heightRange.min + 2)
                            ? tryrun(() => {
                                try {
                                    srun(() => {
                                        player.teleport(
                                            roundVector3ToMiddleOfBlockFloorY(
                                                tryget(
                                                    () => player.dimension
                                                        .getBlock(l)
                                                        .below().location
                                                ) ??
                                                (l.y <=
                                                    player.dimension
                                                        .heightRange.min +
                                                    2
                                                    ? Vector3Utils.add(
                                                        l,
                                                        VECTOR3_DOWN
                                                    )
                                                    : undefined)
                                            )
                                        );
                                    });
                                } catch (e) {
                                    player.sendError(
                                        "§c" + e + e.stack,
                                        true
                                    );
                                }
                            })
                            : (tryget(
                                () => player.dimension.getBlock(l).isAir &&
                                    player.dimension.getBlock(l).above().isAir
                            ) ?? l.y <= player.dimension.heightRange.min + 2)
                                ? tryrun(() => {
                                    try {
                                        srun(() => {
                                            player.teleport(
                                                roundVector3ToMiddleOfBlock(
                                                    tryget(
                                                        () => player.dimension.getBlock(
                                                            l
                                                        ).location
                                                    ) ??
                                                    (l.y <=
                                                        player.dimension
                                                            .heightRange.min +
                                                        2
                                                        ? l
                                                        : undefined)
                                                )
                                            );
                                        });
                                    } catch (e) {
                                        player.sendError(
                                            "§c" + e + e.stack,
                                            true
                                        );
                                    }
                                })
                                : player.sendMessageB(
                                    "§cError: Unable to find other side of obstruction. "
                                );
                    }
                }
                break;
            case !!switchTest.match(/^phase$/):
                {
                    eventData.cancel = true;
                    let l = caretNotationC(
                        player.location,
                        Vector3Utils.scale(VECTOR3_FORWARD, 2),
                        player.getRotation()
                    );
                    try {
                        srun(() => {
                            player.teleport(l);
                        });
                    } catch (e) {
                        player.sendError("§c" + e + e.stack, true);
                    }
                }
                break;
            case !!switchTest.match(/^structure$/):
                {
                    eventData.cancel = true;
                    srun(() => {
                        let argsa = evaluateParameters(switchTestB, [
                            "presetText",
                            "presetText",
                        ]);
                        try {
                            //let args = argsa.args;
                            switch (String(argsa.args[1]).toLowerCase()) {
                                case "save":
                                    {
                                        let args = evaluateParameters(
                                            switchTestB,
                                            [
                                                { type: "presetText" },
                                                { type: "presetText" },
                                                { type: "string" },
                                                { type: "Vector" },
                                                { type: "Vector" },
                                                { type: "Vector" },
                                                { type: "Vector" },
                                                { type: "Vector" },
                                                { type: "Vector" },
                                                { type: "presetText" },
                                                { type: "neboolean" },
                                                { type: "neboolean" },
                                            ]
                                        ).args;
                                        const locationa = evaluateCoordinates(
                                            args[3] ?? "~",
                                            args[4] ?? "~",
                                            args[5] ?? "~",
                                            player.location,
                                            player.getRotation()
                                        );
                                        const locationb = evaluateCoordinates(
                                            args[6] ?? "~",
                                            args[7] ?? "~",
                                            args[8] ?? "~",
                                            player.location,
                                            player.getRotation()
                                        );
                                        world.structureManager.createFromWorld(
                                            args[2],
                                            player.dimension,
                                            locationa,
                                            locationb,
                                            {
                                                saveMode: (
                                                    args[9] ?? ""
                                                ).toLowerCase() == "world"
                                                    ? StructureSaveMode.World
                                                    : StructureSaveMode.Memory,
                                                includeBlocks: args[10] ?? true,
                                                includeEntities: args[11] ?? true,
                                            }
                                        );
                                        //name; fx,fy,fz,tx,ty,tz; savemode; includeblocks; includeentities
                                    }
                                    break;
                                case "saveempty":
                                    {
                                        let args = evaluateParameters(
                                            switchTestB,
                                            [
                                                { type: "presetText" },
                                                { type: "presetText" },
                                                { type: "string" },
                                                { type: "number" },
                                                { type: "number" },
                                                { type: "number" },
                                                { type: "presetText" },
                                            ]
                                        ).args;
                                        //name; sizex; sizey; sizez
                                        world.structureManager.createEmpty(
                                            args[2],
                                            {
                                                x: args[3],
                                                y: args[4],
                                                z: args[5],
                                            },
                                            args[6].toLowerCase() == "disk"
                                                ? StructureSaveMode.World
                                                : StructureSaveMode.Memory
                                        );
                                        psend(
                                            player,
                                            `§aSuccessfully created an empty structure of size ${args
                                                .slice(3, 6)
                                                .map((v) => v.toString())
                                                .join("x")} with the name "§r${args[2]}§a" and saved it to ${args[6].toLowerCase() == "disk"
                                                ? "the disk"
                                                : "memory"}.`
                                        );
                                    }
                                    break;
                                case "createempty":
                                    {
                                        let args = evaluateParameters(
                                            switchTestB,
                                            [
                                                { type: "presetText" },
                                                { type: "presetText" },
                                                { type: "string" },
                                                { type: "number" },
                                                { type: "number" },
                                                { type: "number" },
                                                { type: "presetText" },
                                            ]
                                        ).args;
                                        //name; sizex; sizey; sizez
                                        world.structureManager.createEmpty(
                                            args[2],
                                            {
                                                x: args[3],
                                                y: args[4],
                                                z: args[5],
                                            },
                                            args[6].toLowerCase() == "disk"
                                                ? StructureSaveMode.World
                                                : StructureSaveMode.Memory
                                        );
                                        psend(
                                            player,
                                            `§aSuccessfully created an empty structure of size ${args
                                                .slice(3, 6)
                                                .map((v) => v.toString())
                                                .join("x")} with the name "§r${args[2]}§a" and saved it to ${args[6].toLowerCase() == "disk"
                                                ? "the disk"
                                                : "memory"}.`
                                        );
                                    }
                                    break;
                                case "delete":
                                    {
                                        let args = [
                                            ...argsa.args,
                                            argsa.extra,
                                        ] as [
                                                ...typeof argsa.args,
                                                typeof argsa.extra
                                            ];
                                        if (!!world.structureManager.get(
                                            args[2]
                                        )) {
                                            world.structureManager.delete(
                                                args[2]
                                            )
                                                ? psend(
                                                    player,
                                                    `§aSuccessfully deleted the structure "§r${args[2]}§a".`
                                                )
                                                : psend(
                                                    player,
                                                    `§cError: Failed to delete the structure "§r${args[2]}§c".`
                                                );
                                        } else {
                                            psend(
                                                player,
                                                `§cError: Unable to find the structure "§r${args[2]}§r§c".`
                                            );
                                        }
                                    }
                                    break;
                                case "load":
                                    {
                                        let args = evaluateParameters(
                                            switchTestB,
                                            [
                                                { type: "presetText" },
                                                { type: "presetText" },
                                                { type: "string" },
                                                { type: "Vector" },
                                                { type: "Vector" },
                                                { type: "Vector" },
                                                { type: "number" },
                                                { type: "string" },
                                                { type: "neboolean" },
                                                { type: "neboolean" },
                                                { type: "neboolean" },
                                                { type: "number" },
                                                { type: "string" },
                                                { type: "presetText" },
                                                { type: "number" },
                                            ]
                                        ).args;
                                        //name; x; y; z; includeblocks; includeentities; waterlogged; rotation; loadmode; animationtime
                                        if (!!world.structureManager.get(
                                            args[2]
                                        )) {
                                            args[6] ??= 0;
                                            args[7] ??= "";
                                            const location = evaluateCoordinates(
                                                args[3] ?? "~",
                                                args[4] ?? "~",
                                                args[5] ?? "~",
                                                player.location,
                                                player.getRotation()
                                            );
                                            world.structureManager.place(
                                                args[2],
                                                player.dimension,
                                                location,
                                                {
                                                    includeBlocks: args[8] ?? true,
                                                    includeEntities: args[9] ?? true,
                                                    waterlogged: args[10] ?? false,
                                                    animationMode: StructureAnimationMode[args[13]] ??
                                                        StructureAnimationMode.None,
                                                    animationSeconds: args[14],
                                                    mirror: args[7].includes(
                                                        "x"
                                                    )
                                                        ? args[7].includes("z")
                                                            ? StructureMirrorAxis.XZ
                                                            : StructureMirrorAxis.X
                                                        : args[7].includes("z")
                                                            ? StructureMirrorAxis.Z
                                                            : StructureMirrorAxis.None,
                                                    integrity: args[11],
                                                    integritySeed: args[12],
                                                    rotation: Math.round(
                                                        args[6] / 90
                                                    ) == 0
                                                        ? StructureRotation.None
                                                        : Math.round(
                                                            args[6] / 90
                                                        ) == 1
                                                            ? StructureRotation.Rotate90
                                                            : Math.round(
                                                                args[6] / 90
                                                            ) == 2
                                                                ? StructureRotation.Rotate180
                                                                : Math.round(
                                                                    args[6] / 90
                                                                ) == 3
                                                                    ? StructureRotation.Rotate270
                                                                    : StructureRotation.None,
                                                }
                                            );
                                            psend(
                                                player,
                                                `§aSuccessfully loaded the structure "§r${args[2]}§a".`
                                            );
                                        } else {
                                            psend(
                                                player,
                                                `§cError: Unable to find the structure "§r${args[2]}§r§c".`
                                            );
                                        }
                                    }
                                    break;
                                case "copy":
                                    {
                                        let args = evaluateParameters(
                                            switchTestB,
                                            [
                                                { type: "presetText" },
                                                { type: "presetText" },
                                                { type: "string" },
                                                { type: "string" },
                                            ]
                                        ).args;
                                        if (!!world.structureManager.get(
                                            args[2]
                                        )) {
                                            world.structureManager
                                                .get(args[2])
                                                .saveAs(args[3]);
                                            psend(
                                                player,
                                                `§aSuccessfully copied the structure "§r${args[2]}§a" to "§r${args[3]}§a".`
                                            );
                                        } else {
                                            psend(
                                                player,
                                                `§cError: Unable to find the structure "§r${args[2]}§r§c".`
                                            );
                                        }
                                    }
                                    break;
                                case "copytodisk":
                                    {
                                        let args = evaluateParameters(
                                            switchTestB,
                                            [
                                                { type: "presetText" },
                                                { type: "presetText" },
                                                { type: "string" },
                                                { type: "string" },
                                            ]
                                        ).args;
                                        if (!!world.structureManager.get(
                                            args[2]
                                        )) {
                                            world.structureManager
                                                .get(args[2])
                                                .saveAs(
                                                    args[3],
                                                    StructureSaveMode.World
                                                );
                                            psend(
                                                player,
                                                `§aSuccessfully copied the structure "§r${args[2]}§a" to "§r${args[3]}§a" on the disk.`
                                            );
                                        } else {
                                            psend(
                                                player,
                                                `§cError: Unable to find the structure "§r${args[2]}§r§c".`
                                            );
                                        }
                                    }
                                    break;
                                case "copytomemory":
                                    {
                                        let args = evaluateParameters(
                                            switchTestB,
                                            [
                                                { type: "presetText" },
                                                { type: "presetText" },
                                                { type: "string" },
                                                { type: "string" },
                                            ]
                                        ).args;
                                        if (!!world.structureManager.get(
                                            args[2]
                                        )) {
                                            world.structureManager
                                                .get(args[2])
                                                .saveAs(
                                                    args[3],
                                                    StructureSaveMode.Memory
                                                );
                                            psend(
                                                player,
                                                `§aSuccessfully copied the structure "§r${args[2]}§a" to "§r${args[3]}§a" in memory.`
                                            );
                                        } else {
                                            psend(
                                                player,
                                                `§cError: Unable to find the structure "§r${args[2]}§r§c".`
                                            );
                                        }
                                    }
                                    break;
                                case "savetodisk":
                                    {
                                        let args = [
                                            ...argsa.args,
                                            argsa.extra,
                                        ] as [
                                                ...typeof argsa.args,
                                                typeof argsa.extra
                                            ];
                                        if (!!world.structureManager.get(
                                            args[2]
                                        )) {
                                            const a = world.structureManager
                                                .get(args[2])
                                                .saveAs(
                                                    "andexdb:structuresavingtodiskplaceholderreserved5164896135268634876548961853426912579081261744790127659073267276846741241230675914307695134567412541637516742890576243098",
                                                    StructureSaveMode.World
                                                );
                                            world.structureManager.delete(
                                                args[2]
                                            );
                                            a.saveAs(
                                                args[2],
                                                StructureSaveMode.World
                                            );
                                            world.structureManager.delete(a);
                                            psend(
                                                player,
                                                `§aSuccessfully saved the structure "§r${args[2]}§a" to the disk.`
                                            );
                                        } else {
                                            psend(
                                                player,
                                                `§cError: Unable to find the structure "§r${args[2]}§r§c".`
                                            );
                                        }
                                    }
                                    break;
                                case "movetomemory":
                                    {
                                        let args = [
                                            ...argsa.args,
                                            argsa.extra,
                                        ] as [
                                                ...typeof argsa.args,
                                                typeof argsa.extra
                                            ];
                                        if (!!world.structureManager.get(
                                            args[2]
                                        )) {
                                            let s = world.structureManager
                                                .get(args[2])
                                                .saveAs(
                                                    "andexdb:structuremovingtomemoryplaceholderreserved5164896135268634876548961853426912579081261744790127659073267276846741241230675914307695134567412541637516742890576243098"
                                                );
                                            world.structureManager.delete(
                                                args[2]
                                            );
                                            s.saveAs(
                                                args[2],
                                                StructureSaveMode.Memory
                                            );
                                            world.structureManager.delete(s);
                                            psend(
                                                player,
                                                `§aSuccessfully moved the structure "§r${args[2]}§a" to memory.`
                                            );
                                        } else {
                                            psend(
                                                player,
                                                `§cError: Unable to find the structure "§r${args[2]}§r§c".`
                                            );
                                        }
                                    }
                                    break;
                                case "removeall":
                                    {
                                        //  world.structureManager.getIds().forEach(v=>world.structureManager.delete(v))
                                    }
                                    break;
                                case "list":
                                    {
                                        player.sendMessageB(
                                            world.structureManager
                                                .getWorldStructureIds()
                                                .map((h) => h.replaceAll("§", "\uF019")
                                                )
                                                .join("§r§f\n")
                                        );
                                    }
                                    break;
                                case "getinfo":
                                    {
                                        let args = [
                                            ...argsa.args,
                                            argsa.extra,
                                        ] as [
                                                ...typeof argsa.args,
                                                typeof argsa.extra
                                            ];
                                        if (!!world.structureManager.get(
                                            args[2]
                                        )) {
                                            const structure = world.structureManager.get(
                                                args[2]
                                            );
                                            psend(
                                                player,
                                                `§aID: ${structure.id}\nisValid: ${structure.isValid()}\nSize: ${JSON.stringify(
                                                    structure.size
                                                )}.`
                                            );
                                        } else {
                                            psend(
                                                player,
                                                `§cError: Unable to find the structure "§r${args[2]}§r§c".`
                                            );
                                        }
                                    }
                                    break;
                                case "removeair":
                                    {
                                        let args = [
                                            ...argsa.args,
                                            argsa.extra,
                                        ] as [
                                                ...typeof argsa.args,
                                                typeof argsa.extra
                                            ];
                                        if (!!world.structureManager.get(
                                            args[2]
                                        )) {
                                            const structure = world.structureManager.get(
                                                args[2]
                                            );
                                            completeGenerator(
                                                removeAirFromStructure(
                                                    structure
                                                ),
                                                2500
                                            )
                                                .then((v) => psend(
                                                    player,
                                                    `Removed air blocks from the structure "§r${args[2]}§r§c".`
                                                )
                                                )
                                                .catch((e) => perror(player, e)
                                                );
                                        } else {
                                            psend(
                                                player,
                                                `§cError: Unable to find the structure "§r${args[2]}§r§c".`
                                            );
                                        }
                                    }
                                    break;
                            }
                        } catch (e) {
                            perror(player, e);
                        }
                    });
                }
                break;
            case !!switchTest.match(/^home$/):
                {
                    eventData.cancel = true;
                    if (config.homeSystem.homeSystemEnabled) {
                        let argsa = evaluateParameters(switchTestB, [
                            "presetText",
                            "presetText",
                        ]);
                        let args = [...argsa.args, argsa.extra] as [
                            ...typeof argsa.args,
                            typeof argsa.extra
                        ];
                        switch (String(args[1])) {
                            case "set":
                                if (HomeSystem.testIfPlayerAtMaxHomes(player)) {
                                    player.sendMessageB(
                                        "§cError: Max homes reached. Please delete a home if you want to add a new one. "
                                    );
                                } else if (!!HomeSystem.getHomesForPlayer(player).find(
                                    (h) => h.name == args[2]
                                )) {
                                    player.sendMessageB(
                                        "§cError: You already have a home with this name. Please delete the home and create it again if you want to change its location. "
                                    );
                                } else {
                                    new Home({
                                        location: Object.assign(
                                            player.location,
                                            { dimension: player.dimension }
                                        ),
                                        name: args[2],
                                        owner: player.player,
                                        saveId: "home:" + player.id + ":" + args[2],
                                    }).save();
                                    player.sendMessageB(
                                        `Successfully set the home "${args[2]}§r§f" to ${vTStr(
                                            player.location
                                        )} in ${dimensionTypeDisplayFormatting[player.dimension.id]}. `
                                    );
                                }
                                break;
                            case "remove":
                                if (!!HomeSystem.getHomesForPlayer(player).find(
                                    (h) => h.name == args[2]
                                )) {
                                    HomeSystem.getHomesForPlayer(player)
                                        .find((h) => h.name == args[2])
                                        .remove();
                                    player.sendMessageB(
                                        `Successfully removed the home "${args[2]}§r§f". `
                                    );
                                } else {
                                    player.sendError(
                                        `§cError: Could not find a home with the name "${args[2]}§r§c". `,
                                        true
                                    );
                                }
                                break;
                            case "go":
                                if (!!HomeSystem.getHomesForPlayer(player).find(
                                    (h) => h.name == args[2]
                                )) {
                                    srun(() => player.teleport(
                                        HomeSystem.getHomesForPlayer(
                                            player
                                        ).find((h) => h.name == args[2])
                                            .location,
                                        {
                                            dimension: HomeSystem.getHomesForPlayer(
                                                player
                                            ).find(
                                                (h) => h.name == args[2]
                                            ).location.dimension,
                                        }
                                    )
                                    );
                                    player.sendMessageB(
                                        `Successfully teleported to the home "${args[2]}§r§f". `
                                    );
                                } else {
                                    player.sendError(
                                        `§cError: Could not find a home with the name "${args[2]}§r§c". `,
                                        true
                                    );
                                }
                                break;
                            case "warp":
                                if (!!HomeSystem.getHomesForPlayer(player).find(
                                    (h) => h.name == args[2]
                                )) {
                                    srun(() => player.teleport(
                                        HomeSystem.getHomesForPlayer(
                                            player
                                        ).find((h) => h.name == args[2])
                                            .location,
                                        {
                                            dimension: HomeSystem.getHomesForPlayer(
                                                player
                                            ).find(
                                                (h) => h.name == args[2]
                                            ).location.dimension,
                                        }
                                    )
                                    );
                                    player.sendMessageB(
                                        `Successfully teleported to the home "${args[2]}§r§f". `
                                    );
                                } else {
                                    player.sendError(
                                        `§cError: Could not find a home with the name "${args[2]}§r§c". `,
                                        true
                                    );
                                }
                                break;
                            case "teleport":
                                if (!!HomeSystem.getHomesForPlayer(player).find(
                                    (h) => h.name == args[2]
                                )) {
                                    srun(() => player.teleport(
                                        HomeSystem.getHomesForPlayer(
                                            player
                                        ).find((h) => h.name == args[2])
                                            .location,
                                        {
                                            dimension: HomeSystem.getHomesForPlayer(
                                                player
                                            ).find(
                                                (h) => h.name == args[2]
                                            ).location.dimension,
                                        }
                                    )
                                    );
                                    player.sendMessageB(
                                        `Successfully teleported to the home "${args[2]}§r§f". `
                                    );
                                } else {
                                    player.sendError(
                                        `§cError: Could not find a home with the name "${args[2]}§r§c". `,
                                        true
                                    );
                                }
                                break;
                            case "clear":
                                HomeSystem.getHomesForPlayer(player).forEach(
                                    (h) => h.remove()
                                );
                                player.sendMessageB(
                                    `Successfully cleared all of your homes. `
                                );
                                break;
                            case "removeall":
                                HomeSystem.getHomesForPlayer(player).forEach(
                                    (h) => h.remove()
                                );
                                player.sendMessageB(
                                    `Successfully removed all of your homes. `
                                );
                                break;
                            case "list":
                                player.sendMessageB(
                                    HomeSystem.getHomesForPlayer(player)
                                        .map((h) => h.name.replaceAll("§", "\uF019")
                                        )
                                        .join("§r§f\n")
                                );
                                break;
                        }
                    } else {
                        player.sendMessageB(
                            '§cError: This command cannot be used becuase the experimental home system is not enabled. It can be enabled at "Main Menu>Settings>Home System>Enable Home System"'
                        );
                    }
                }
                break;
            case !!switchTest.match(/^gohome$/):
                {
                    eventData.cancel = true;
                    if (config.homeSystem.homeSystemEnabled) {
                        let argsa = evaluateParameters(switchTestB, [
                            "presetText",
                        ]);
                        if (!!HomeSystem.getHomesForPlayer(player).find(
                            (h) => h.name == argsa.extra
                        )) {
                            srun(() => player.teleport(
                                Home.get(
                                    "home:" + player.id + ":" + argsa.extra
                                ).location,
                                {
                                    dimension: Home.get(
                                        "home:" +
                                        player.id +
                                        ":" +
                                        argsa.extra
                                    ).location.dimension,
                                }
                            )
                            );
                            player.sendMessageB(
                                `Successfully teleported to the home "${argsa.extra}§r§f". `
                            );
                        } else {
                            player.sendError(
                                `§cError: Could not find a home with the name "${argsa.extra}§r§c". `,
                                true
                            );
                        }
                    } else {
                        player.sendMessageB(
                            '§cError: This command cannot be used becuase the experimental home system is not enabled. It can be enabled at "Main Menu>Settings>Home System>Enable Home System"'
                        );
                    }
                }
                break;
            case !!switchTest.match(/^spawn$/):
                {
                    eventData.cancel = true;
                    if (!!!config.spawnCommandLocation.x) {
                        player.sendMessageB(
                            '§cError: This command cannot be used becuase no spawn teleport location has been set. It can be enabled at "Main Menu>Settings>Global Settings>spawnCommandLocation"'
                        );
                    } else {
                        srun(() => player.teleport(config.spawnCommandLocation, {
                            dimension: config.spawnCommandLocation.dimension,
                        })
                        );
                    }
                }
                break;
            case !!switchTest.match(/^tpa$/):
                {
                    eventData.cancel = true;
                    // /scriptevent andexdb:spawnSimulatedPlayer t§ee§as§ft §4P§dl§layer|~~~|overworld|~~~
                    if (config.tpaSystem.tpaSystemEnabled) {
                        srun(() => {
                            let args = evaluateParameters(switchTestB, [
                                "presetText",
                                "targetSelector",
                                "string",
                            ]).args;
                            args[1].trim().startsWith("@");
                            let target = targetSelectorAllListC(
                                args[1],
                                "",
                                vTStr(player.location),
                                player
                            ).filter(
                                (v) => v.typeId == "minecraft:player"
                            )[0] as Player;
                            if (!!target) {
                                //requestChatInput(player, "a").then(v=>psend(player, "as")); srun(()=>requestChatInput(player, "b").then(v=>psend(player, "bs")));
                                player.sendMessageB(
                                    `§aSent a teleport request to "${target.name}".`
                                );
                                requestConditionalChatInput(
                                    target,
                                    (player, message) => message.toLowerCase().trim() == "y" ||
                                        message.toLowerCase().trim() == "n",
                                    {
                                        requestMessage: `§a${player.name} sent you a teleport request, type "y" to accept or "n" to deny, this request will expire in ${config.tpaSystem.timeoutDuration ==
                                                60
                                                ? "1 minute"
                                                : (
                                                    config.tpaSystem
                                                        .timeoutDuration / 60
                                                ).floor() == 1
                                                    ? `1 minute and ${(
                                                        config.tpaSystem
                                                            .timeoutDuration % 60
                                                    ).floor()} second${(
                                                        config.tpaSystem
                                                            .timeoutDuration %
                                                        60
                                                    ).floor() != 1
                                                        ? "s"
                                                        : ""}`
                                                    : (
                                                        config.tpaSystem
                                                            .timeoutDuration / 60
                                                    ).floor() == 0
                                                        ? `${(
                                                            config.tpaSystem
                                                                .timeoutDuration % 60
                                                        ).floor()} second${(
                                                            config.tpaSystem
                                                                .timeoutDuration %
                                                            60
                                                        ).floor() != 1
                                                            ? "s"
                                                            : ""}`
                                                        : `${(
                                                            config.tpaSystem
                                                                .timeoutDuration / 60
                                                        ).floor()} minutes and ${(
                                                            config.tpaSystem
                                                                .timeoutDuration % 60
                                                        ).floor()} second${(
                                                            config.tpaSystem
                                                                .timeoutDuration %
                                                            60
                                                        ).floor() != 1
                                                            ? "s"
                                                            : ""}`}.`,
                                        expireMs: config.tpaSystem.timeoutDuration *
                                            1000,
                                    }
                                )
                                    .then((t) => {
                                        if (t.toLowerCase().trim() == "y") {
                                            player.teleport(target.location, {
                                                dimension: target.dimension,
                                            });
                                            target.sendMessage(
                                                `§aAccepted teleport request from "${player.name}".`
                                            );
                                            player.sendMessageB(
                                                `§aSuccessfully teleported to "${target.name}".`
                                            );
                                        } else {
                                            target.sendMessage(
                                                `§cDenied "${player.name}"'s teleport request.`
                                            );
                                            player.sendMessageB(
                                                `§c"${target.name}" denied your teleport request.`
                                            );
                                        }
                                    })
                                    .catch((e) => {
                                        if (e instanceof TimeoutError) {
                                            psend(
                                                target,
                                                `§c${player.name}'s teleport request timed out.`
                                            );
                                            psend(
                                                player,
                                                `§cThe teleport request to ${target.name} timed out.`
                                            );
                                        } else if (e instanceof ExpireError) {
                                            psend(
                                                target,
                                                `§c${player.name}'s teleport request expired.`
                                            );
                                            psend(
                                                player,
                                                `§cThe teleport request to ${target.name} expired.`
                                            );
                                        }
                                        else
                                            psend(
                                                player,
                                                "§c" + e + " " + e.stack
                                            );
                                    });
                            } else {
                                player.sendError(
                                    `§cError: Unable to find player.`,
                                    true
                                );
                            }
                        });
                    } else {
                        player.sendMessageB(
                            '§cTPASystemDisabledError: This command cannot be used becuase the experimental teleport request system is not enabled. It can be enabled at "Main Menu>Settings>TPA System>Enable TPA System"'
                        );
                    }
                }
                break; /*
    case !!switchTest.match(/^tpablock$/): {
        eventData.cancel = true;
        if(config.tpaSystem.tpaSystemEnabled){
            srun(()=>{
            let args = evaluateParameters(switchTestB, ["presetText", "targetSelector", "string"]).args
            let target = targetSelectorAllListC(args[1], "", vTStr(player.location), player).filter(v=>v.typeId=="minecraft:player")[0] as Player
            if(!!target){
                requestConditionalChatInput(target, (player, message)=>(message.trim()=="y"||message.trim()=="n"), {requestMessage: `§a${player.name} sent you a teleport request, type "y" to accept or "n" to deny, this request will expire in 1 minute.`}).then(t=>{
                    if(t.trim()=="y"){
                        player.teleport(target.location, {dimension: target.dimension})
                        player.sendMessageB(`Successfully teleported to "${target.name}".`)
                    }else{
                        player.sendMessageB(`"${target.name}" denied your teleport request.`)
                    }
                }).catch(e=>{if(e instanceof TimeoutError){psend(target, `§c${player.name}'s teleport request expired.`); psend(player, "§cTeleport request timed out.")}else if(e instanceof ExpireError){psend(player, "§cTeleport request expired.")}else psend(player, "§c"+e+" "+e.stack)})
            }else{player.sendError(`§cError: Unable to find player.`, true)}
            })
        }else{
            player.sendMessageB("§cError: This command cannot be used becuase the experimental teleport request system is not enabled. It can be enabled at \"Main Menu>Settings>TPA System>Enable Teleport Request System\"")
        }
    }
    break; */ // COMING SOON!






















            case !!switchTest.match(/^summon$/):
                {
                    eventData.cancel = true;
                    system.run(() => {
                        try {
                            const args = evaluateParameters(switchTestB, [
                                "presetText",
                                "number",
                                "string",
                                "Vector",
                                "Vector",
                                "Vector",
                                "Vector",
                                "Vector",
                                "neboolean",
                                "string",
                            ]).args;
                            const rotation = evaluateRotationCoordinates(
                                String(args[7] ?? 0),
                                String(args[6] ?? 0).replace("~", "0"),
                                player.getRotation()
                            );
                            const location = evaluateCoordinates(
                                args[3] ?? "~",
                                args[4] ?? "~",
                                args[5] ?? "~",
                                player.location,
                                player.getRotation()
                            );
                            for (let i = 0; i < args[1]; i++) {
                                let a = player.dimension.spawnEntity(
                                    args[2].replace(
                                        /^[^\<\:]+(?=[\<\$])/,
                                        "minecraft:$&"
                                    ),
                                    location,
                                    { initialPersistence: args[8] ?? false }
                                );
                                a.setRotation(rotation);
                                a.nameTag = args[9] ?? "";
                            }
                            player?.sendMessage(
                                `${args[1] == 0 ? "§c" : ""}Summoned ${args[2]} * ${args[1]}. `
                            );
                        } catch (e) {
                            perror(player, e);
                        }
                    });
                }
                break;
            case !!switchTest.match(/^heal$/):
                {
                    eventData.cancel = true;
                    system.run(() => {
                        let args = evaluateParameters(switchTestB, [
                            "presetText",
                            "targetSelector",
                        ]).args;
                        if (switchTestB.split(/\s+/g)[1]?.trim() == "~") {
                            args[1] = player.name;
                        }
                        if ((switchTestB.split(/\s+/g)[1] ?? "").trim() == "") {
                            args[1] = player.name;
                        }
                        let targets = targetSelectorAllListC(
                            args[1],
                            "",
                            vTStr(player.location),
                            player
                        );
                        if (targets.length == 0) {
                            player.sendError(
                                `§cError: No players matching the specified target selector were found. `,
                                true
                            );
                        }
                        else
                            targets.forEach((target) => {
                                try {
                                    target
                                        .getComponent("health")
                                        .resetToMaxValue();
                                    player.sendMessageB(
                                        `Healed ${(target as Player)?.name ??
                                        tryget(() => target.nameTag == ""
                                            ? undefined
                                            : target.nameTag
                                        ) ??
                                        target.typeId +
                                        "<" +
                                        target.id +
                                        ">"}. Health is now ${target.getComponent("health")
                                            .effectiveMax}. `
                                    );
                                } catch (e) {
                                    player.sendMessageB(
                                        "§c" +
                                        e +
                                        " " +
                                        e.stack +
                                        "\nfor entity " +
                                        target.typeId +
                                        "<" +
                                        target.id +
                                        ">"
                                    );
                                }
                            });
                    });
                }
                break;
            case !!switchTest.match(/^setplayernametag$/) ||
                !!switchTest.match(/^setentitynametag$/) ||
                !!switchTest.match(/^setnametag$/):
                {
                    eventData.cancel = true;
                    system.run(() => {
                        let args = evaluateParameters(switchTestB, [
                            "presetText",
                            "targetSelector",
                            "string",
                        ]).args;
                        if (switchTestB.split(/\s+/g)[1]?.trim() == "~") {
                            args[1] = player.name;
                        }
                        if ((switchTestB.split(/\s+/g)[1] ?? "").trim() == "") {
                            args[1] = player.name;
                        }
                        let targets = targetSelectorAllListC(
                            args[1],
                            "",
                            vTStr(player.location),
                            player
                        );
                        if (targets.length == 0) {
                            player.sendError(
                                `§cError: No entities matching the specified target selector were found. `,
                                true
                            );
                        }
                        else
                            targets.forEach((target) => {
                                try {
                                    const name = (target as Player)?.name ??
                                        tryget(() => target.nameTag == ""
                                            ? undefined
                                            : target.nameTag +
                                            "<" +
                                            target.id +
                                            ">"
                                        ) ??
                                        target.typeId + "<" + target.id + ">";
                                    target.nameTag = args[2] ?? "";
                                    player.sendMessageB(
                                        `Set the name of ${name} to ${JSON.stringify(
                                            args[2] ?? ""
                                        )}. `
                                    );
                                } catch (e) {
                                    player.sendMessageB(
                                        "§c" +
                                        e +
                                        " " +
                                        e.stack +
                                        "\nfor entity " +
                                        target.typeId +
                                        "<" +
                                        target.id +
                                        ">"
                                    );
                                }
                            });
                    });
                }
                break;
            case !!switchTest.match(/^maxhealth$/):
                {
                    eventData.cancel = true;
                    system.run(() => {
                        let args = evaluateParameters(switchTestB, [
                            "presetText",
                            "targetSelector",
                        ]).args;
                        if (switchTestB.split(/\s+/g)[1]?.trim() == "~") {
                            args[1] = player.name;
                        }
                        if ((switchTestB.split(/\s+/g)[1] ?? "").trim() == "") {
                            args[1] = player.name;
                        }
                        let targets = targetSelectorAllListC(
                            args[1],
                            "",
                            vTStr(player.location),
                            player
                        );
                        if (targets.length == 0) {
                            player.sendError(
                                `§cError: No entities matching the specified target selector were found. `,
                                true
                            );
                        }
                        else
                            targets.forEach((target) => {
                                try {
                                    target
                                        .getComponent("health")
                                        .resetToMaxValue();
                                    player.sendMessageB(
                                        `Set health of ${(target as Player)?.name ??
                                        tryget(() => target.nameTag == ""
                                            ? undefined
                                            : target.nameTag
                                        ) ??
                                        target.typeId +
                                        "<" +
                                        target.id +
                                        ">"} to maximum: ${target.getComponent("health")
                                            .effectiveMax}. `
                                    );
                                } catch (e) {
                                    player.sendMessageB(
                                        "§c" +
                                        e +
                                        " " +
                                        e.stack +
                                        "\nfor entity " +
                                        target.typeId +
                                        "<" +
                                        target.id +
                                        ">"
                                    );
                                }
                            });
                    });
                }
                break;
            case !!switchTest.match(/^minhealth$/):
                {
                    eventData.cancel = true;
                    system.run(() => {
                        let args = evaluateParameters(switchTestB, [
                            "presetText",
                            "targetSelector",
                        ]).args;
                        if (switchTestB.split(/\s+/g)[1]?.trim() == "~") {
                            args[1] = player.name;
                        }
                        if ((switchTestB.split(/\s+/g)[1] ?? "").trim() == "") {
                            args[1] = player.name;
                        }
                        let targets = targetSelectorAllListC(
                            args[1],
                            "",
                            vTStr(player.location),
                            player
                        );
                        if (targets.length == 0) {
                            player.sendError(
                                `§cError: No entities matching the specified target selector were found. `,
                                true
                            );
                        }
                        else
                            targets.forEach((target) => {
                                try {
                                    target
                                        .getComponent("health")
                                        .resetToMinValue();
                                    player.sendMessageB(
                                        `Set health of ${(target as Player)?.name ??
                                        tryget(() => target.nameTag == ""
                                            ? undefined
                                            : target.nameTag
                                        ) ??
                                        target.typeId +
                                        "<" +
                                        target.id +
                                        ">"} to minimum: ${target.getComponent("health")
                                            .effectiveMin}. `
                                    );
                                } catch (e) {
                                    player.sendMessageB(
                                        "§c" +
                                        e +
                                        " " +
                                        e.stack +
                                        "\nfor entity " +
                                        target.typeId +
                                        "<" +
                                        target.id +
                                        ">"
                                    );
                                }
                            });
                    });
                }
                break;
            case !!switchTest.match(/^defaulthealth$/) ||
                !!switchTest.match(/^dfthlth$/) ||
                !!switchTest.match(/^dflthlth$/) ||
                !!switchTest.match(/^dfthealth$/) ||
                !!switchTest.match(/^dflthealth$/):
                {
                    eventData.cancel = true;
                    system.run(() => {
                        let args = evaluateParameters(switchTestB, [
                            "presetText",
                            "targetSelector" /*, "number"*/,
                        ]).args;
                        if (switchTestB.split(/\s+/g)[1]?.trim() == "~") {
                            args[1] = player.name;
                        }
                        if ((switchTestB.split(/\s+/g)[1] ?? "").trim() == "") {
                            args[1] = player.name;
                        }
                        let targets = targetSelectorAllListC(
                            args[1],
                            "",
                            vTStr(player.location),
                            player
                        );
                        if (targets.length == 0) {
                            player.sendError(
                                `§cError: No entities matching the specified target selector were found. `,
                                true
                            );
                        }
                        else
                            targets.forEach((target) => {
                                try {
                                    target
                                        .getComponent("health")
                                        .resetToDefaultValue();
                                    player.sendMessageB(
                                        `Set health of ${(target as Player)?.name ??
                                        tryget(() => target.nameTag == ""
                                            ? undefined
                                            : target.nameTag
                                        ) ??
                                        target.typeId +
                                        "<" +
                                        target.id +
                                        ">"} to default: ${target.getComponent("health")
                                            .defaultValue}. `
                                    );
                                } catch (e) {
                                    player.sendMessageB(
                                        "§c" +
                                        e +
                                        " " +
                                        e.stack +
                                        "\nfor entity " +
                                        target.typeId +
                                        "<" +
                                        target.id +
                                        ">"
                                    );
                                }
                            });
                    });
                }
                break;
            case !!switchTest.match(/^health$/):
                {
                    eventData.cancel = true;
                    system.run(() => {
                        let args = evaluateParameters(switchTestB, [
                            "presetText",
                            "presetText",
                            "targetSelector",
                        ]).args;
                        if (switchTestB.split(/\s+/g)[2]?.trim() == "~") {
                            args[2] = player.name;
                        }
                        if ((switchTestB.split(/\s+/g)[2] ?? "").trim() == "") {
                            args[2] = player.name;
                        }
                        let targets = targetSelectorAllListC(
                            args[2],
                            "",
                            vTStr(player.location),
                            player
                        );
                        if (targets.length == 0) {
                            player.sendError(
                                `§cError: No players matching the specified target selector were found. `,
                                true
                            );
                        }
                        else
                            targets.forEach((target) => {
                                try {
                                    target
                                        .getComponent("health")
                                        .setCurrentValue(Number(args[1]));
                                    player.sendMessageB(
                                        `Set health of ${(target as Player)?.name ??
                                        tryget(() => target.nameTag == ""
                                            ? undefined
                                            : target.nameTag
                                        ) ??
                                        target.typeId +
                                        "<" +
                                        target.id +
                                        ">"} to ${Number(args[1])}. `
                                    );
                                } catch (e) {
                                    player.sendMessageB(
                                        "§c" +
                                        e +
                                        " " +
                                        e.stack +
                                        "\nfor entity " +
                                        target.typeId +
                                        "<" +
                                        target.id +
                                        ">"
                                    );
                                }
                            });
                    });
                }
                break;
            case !!switchTest.match(/^liststructures$/) ||
                !!switchTest.match(/^getstructures$/):
                {
                    eventData.cancel = true;
                    srun(() => player.sendMessageB(
                        world.structureManager
                            .getWorldStructureIds()
                            .sort()
                            .join("§r\n")
                    )
                    );
                }
                break;
            case !!switchTest.match(/^listbans$/) ||
                !!switchTest.match(/^getbans$/):
                {
                    eventData.cancel = true;
                    player.sendMessageB(
                        ban
                            .getBans()
                            .allBans.map(
                                (b) => `${b.type == "id"
                                        ? "ID Ban: "
                                        : "Name Ban: "}${b.type == "id"
                                        ? b.playerId
                                        : b.playerName}, ${new Date(
                                            Number(b.banDate) +
                                            Number(
                                                player.getDynamicProperty(
                                                    "andexdbPersonalSettings:timeZone"
                                                ) ??
                                                world.getDynamicProperty(
                                                    "andexdbSettings:timeZone"
                                                ) ??
                                                0
                                            ) *
                                            3600000
                                        ).toLocaleString() +
                                    (Number(
                                        player.getDynamicProperty(
                                            "andexdbPersonalSettings:timeZone"
                                        ) ??
                                        world.getDynamicProperty(
                                            "andexdbSettings:timeZone"
                                        ) ??
                                        0
                                    ) < 0
                                        ? " GMT"
                                        : " GMT+") +
                                    Number(
                                        player.getDynamicProperty(
                                            "andexdbPersonalSettings:timeZone"
                                        ) ??
                                        world.getDynamicProperty(
                                            "andexdbSettings:timeZone"
                                        ) ??
                                        0
                                    )}, Time Remaining: ${b.timeRemaining.days}d, ${b.timeRemaining.hours}h ${b.timeRemaining.minutes}m ${b.timeRemaining.seconds}s ${b.timeRemaining.milliseconds}ms`
                            )
                            .join("§r§f\n")
                    );
                }
                break;
            case !!switchTest.match(/^listidbans$/) ||
                !!switchTest.match(/^getidbans$/):
                {
                    eventData.cancel = true;
                    player.sendMessageB(
                        ban
                            .getBans()
                            .idBans.map(
                                (b) => `${b.playerId}, Banned On: ${new Date(
                                    Number(b.banDate) +
                                    Number(
                                        player.getDynamicProperty(
                                            "andexdbPersonalSettings:timeZone"
                                        ) ??
                                        world.getDynamicProperty(
                                            "andexdbSettings:timeZone"
                                        ) ??
                                        0
                                    ) *
                                    3600000
                                ).toLocaleString() +
                                    (Number(
                                        player.getDynamicProperty(
                                            "andexdbPersonalSettings:timeZone"
                                        ) ??
                                        world.getDynamicProperty(
                                            "andexdbSettings:timeZone"
                                        ) ??
                                        0
                                    ) < 0
                                        ? " GMT"
                                        : " GMT+") +
                                    Number(
                                        player.getDynamicProperty(
                                            "andexdbPersonalSettings:timeZone"
                                        ) ??
                                        world.getDynamicProperty(
                                            "andexdbSettings:timeZone"
                                        ) ??
                                        0
                                    )}, Time Remaining: ${b.timeRemaining.days}d, ${b.timeRemaining.hours}h ${b.timeRemaining.minutes}m ${b.timeRemaining.seconds}s ${b.timeRemaining.milliseconds}ms`
                            )
                            .join("§r§f\n")
                    );
                }
                break;
            case !!switchTest.match(/^listnamebans$/) ||
                !!switchTest.match(/^getnamebans$/):
                {
                    eventData.cancel = true;
                    player.sendMessageB(
                        ban
                            .getBans()
                            .nameBans.map(
                                (b) => `${b.playerName}, Banned On: ${new Date(
                                    Number(b.banDate) +
                                    Number(
                                        player.getDynamicProperty(
                                            "andexdbPersonalSettings:timeZone"
                                        ) ??
                                        world.getDynamicProperty(
                                            "andexdbSettings:timeZone"
                                        ) ??
                                        0
                                    ) *
                                    3600000
                                ).toLocaleString() +
                                    (Number(
                                        player.getDynamicProperty(
                                            "andexdbPersonalSettings:timeZone"
                                        ) ??
                                        world.getDynamicProperty(
                                            "andexdbSettings:timeZone"
                                        ) ??
                                        0
                                    ) < 0
                                        ? " GMT"
                                        : " GMT+") +
                                    Number(
                                        player.getDynamicProperty(
                                            "andexdbPersonalSettings:timeZone"
                                        ) ??
                                        world.getDynamicProperty(
                                            "andexdbSettings:timeZone"
                                        ) ??
                                        0
                                    )}, Time Remaining: ${b.timeRemaining.days}d, ${b.timeRemaining.hours}h ${b.timeRemaining.minutes}m ${b.timeRemaining.seconds}s ${b.timeRemaining.milliseconds}ms`
                            )
                            .join("§r§f\n")
                    );
                }
                break;
            case !!switchTest.match(/^version$/) || !!switchTest.match(/^ver$/):
                {
                    eventData.cancel = true;
                    player.sendMessageB(format_version);
                }
                break;
            case !!switchTest.match(/^entityscaleversion$/) ||
                !!switchTest.match(/^esver$/):
                {
                    eventData.cancel = true;
                    player.sendMessageB(
                        (entity_scale_format_version != null
                            ? entity_scale_format_version
                            : !!tryget(
                                () => new ItemStack("andexsa:furnace_minecart")
                            )
                                ? "Unknown Version"
                                : "Entity Scale Not Detected") +
                        (multipleEntityScaleVersionsDetected
                            ? "<MULTIPLE VERSIONS WERE DETECTED!>"
                            : "")
                    );
                }
                break;
            case !!switchTest.match(/^despawn$/):
                {
                    eventData.cancel = true;
                    system.run(() => {
                        let args = evaluateParameters(switchTestB, [
                            "presetText",
                            "targetSelector",
                            "string",
                        ]).args;
                        if (switchTestB.split(/\s+/g)[1]?.trim() == "~") {
                            args[1] = player.name;
                        }
                        if ((switchTestB.split(/\s+/g)[1] ?? "").trim() == "") {
                            args[1] = player.name;
                        }
                        let targets = targetSelectorAllListC(
                            args[1],
                            "",
                            vTStr(player.location),
                            player
                        );
                        if (targets.length == 0) {
                            player.sendError(
                                `§cError: No players matching the specified target selector were found. `,
                                true
                            );
                        } else {
                            let despawnCount = 0;
                            targets.forEach((target) => {
                                try {
                                    target.remove();
                                    despawnCount++;
                                } catch (e) {
                                    player.sendMessageB(
                                        "§c" + e + " " + e.stack
                                    );
                                }
                            });
                            player?.sendMessage(
                                `${despawnCount == 0 ? "§c" : ""}${despawnCount} entities were despawned. `
                            );
                        }
                    });
                }
                break;
            case !!switchTest.match(/^kick$/):
                {
                    eventData.cancel = true;
                    system.run(() => {
                        let args = evaluateParameters(switchTestB, [
                            "presetText",
                            "targetSelector",
                            "string",
                        ]).args;
                        if (switchTestB.split(/\s+/g)[1]?.trim() == "~") {
                            args[1] = player.name;
                        }
                        if ((switchTestB.split(/\s+/g)[1] ?? "").trim() == "") {
                            args[1] = player.name;
                        }
                        let targets = targetSelectorAllListC(
                            args[1],
                            "",
                            vTStr(player.location),
                            player
                        ).filter(
                            (v) => v.typeId == "minecraft:player"
                        ) as Player[];
                        if (targets.length == 0) {
                            player.sendError(
                                `§cError: No players matching the specified target selector were found. `,
                                true
                            );
                        }
                        else
                            targets.forEach((target) => {
                                try {
                                    target.runCommand(
                                        "/kick " +
                                        JSON.stringify(target.name) +
                                        (!!args[2] ? " " + args[2] : "")
                                    );
                                    player?.sendMessage(
                                        `${target?.name ?? target?.id} was kicked from the game. `
                                    );
                                } catch (e) {
                                    player.sendMessageB(
                                        "§c" + e + " " + e.stack
                                    );
                                }
                            });
                    });
                }
                break;
            case !!switchTest.match(/^disconnect$/) ||
                !!switchTest.match(/^boot$/):
                {
                    eventData.cancel = true;
                    system.run(() => {
                        let args = evaluateParameters(switchTestB, [
                            "presetText",
                            "targetSelector",
                        ]).args;
                        if (switchTestB.split(/\s+/g)[1]?.trim() == "~") {
                            args[1] = player.name;
                        }
                        if ((switchTestB.split(/\s+/g)[1] ?? "").trim() == "") {
                            args[1] = player.name;
                        }
                        let targets = targetSelectorAllListC(
                            args[1],
                            "",
                            vTStr(player.location),
                            player
                        ).filter(
                            (v) => v.typeId == "minecraft:player"
                        ) as Player[];
                        if (targets.length == 0) {
                            player.sendError(
                                `§cError: No players matching the specified target selector were found. `,
                                true
                            );
                        }
                        else
                            targets.forEach((target) => {
                                try {
                                    disconnectingPlayers.push(target.id);
                                    target.triggerEvent("andexsa:explode");
                                    player?.sendMessage(
                                        `${target?.name ?? target?.id} was disconnected. `
                                    );
                                    system.run(() => {
                                        disconnectingPlayers.splice(
                                            disconnectingPlayers.indexOf(
                                                target.id
                                            ),
                                            +(
                                                disconnectingPlayers.indexOf(
                                                    target.id
                                                ) != -1
                                            )
                                        );
                                    });
                                    //${se}let abcd = [1, 0, 2, 3, 4, 5, 6, 7]; abcd.splice(2, 1); bsend(abcd)
                                    //${se}let abcd = [1, 0, 2, 3, 4, 5, 6, 7]; abcd.splice(-1, 1); bsend(abcd)
                                } catch (e) {
                                    if (e.message ==
                                        "The event andexsa:explode does not exist on minecraft:player") {
                                        player.sendMessageB(
                                            "§cError: Either the add-on \"8Crafter's Entity Scale, NBT, and Behavior Modifier, Bossbar, and Morph Addon\" is not on this world/server/realm or another pack is overriding the player.json file in its behavior pack, the host/owner of this world/server/realm must fix this issue before you can use this command. \nIf you are the host/owner and you don't have the add-on then you can download it from the website: §bhttps://modbay.org/mods/1218-8crafters-entity-scale-and-morph-addon.html"
                                        );
                                        return;
                                    } else {
                                        player.sendMessageB(
                                            "§c" + e + " " + e.stack
                                        );
                                    }
                                }
                            });
                    });
                }
                break;
            case !!switchTest.match(/^morph$/):
                eventData.cancel = true;
                try {
                    system.run(() => {
                        try {
                            if (newMessage.split(" ")[2] == undefined) {
                                player.setProperty(
                                    "andexpr:entity_type",
                                    Number(newMessage.split(" ")[1])
                                );
                            } else {
                                targetSelectorAllListB(
                                    newMessage.split(" ").slice(2).join(" "),
                                    "",
                                    Number(player.id)
                                ).forEach((p) => {
                                    p.setProperty(
                                        "andexpr:entity_type",
                                        Number(newMessage.split(" ")[1])
                                    );
                                });
                            }
                        } catch (e) {
                            player.sendError("§c" + e + e.stack, true);
                        }
                    });
                } catch (e) {
                    player.sendError("§c" + e + e.stack, true);
                }
                break;
            case !!switchTest.match(/^tint$/):
                eventData.cancel = true;
                try {
                    system.run(() => {
                        try {
                            if (newMessage.split(" ")[6] == undefined) {
                                player.setProperty(
                                    "andexpr:color_tint_r",
                                    Number(
                                        (
                                            newMessage.split(" ")[1] ?? "~"
                                        ).replaceAll(
                                            "~",
                                            String(
                                                player.getProperty(
                                                    "andexpr:color_tint_r"
                                                )
                                            )
                                        )
                                    ) ??
                                    player.getProperty(
                                        "andexpr:color_tint_r"
                                    )
                                );
                                player.setProperty(
                                    "andexpr:color_tint_g",
                                    Number(
                                        (
                                            newMessage.split(" ")[2] ?? "~"
                                        ).replaceAll(
                                            "~",
                                            String(
                                                player.getProperty(
                                                    "andexpr:color_tint_g"
                                                )
                                            )
                                        )
                                    ) ??
                                    player.getProperty(
                                        "andexpr:color_tint_g"
                                    )
                                );
                                player.setProperty(
                                    "andexpr:color_tint_b",
                                    Number(
                                        (
                                            newMessage.split(" ")[3] ?? "~"
                                        ).replaceAll(
                                            "~",
                                            String(
                                                player.getProperty(
                                                    "andexpr:color_tint_b"
                                                )
                                            )
                                        )
                                    ) ??
                                    player.getProperty(
                                        "andexpr:color_tint_b"
                                    )
                                );
                                player.setProperty(
                                    "andexpr:color_tint_a",
                                    Number(
                                        (
                                            newMessage.split(" ")[4] ?? "~"
                                        ).replaceAll(
                                            "~",
                                            String(
                                                player.getProperty(
                                                    "andexpr:color_tint_a"
                                                )
                                            )
                                        )
                                    ) ??
                                    player.getProperty(
                                        "andexpr:color_tint_a"
                                    )
                                );
                                player.setProperty(
                                    "andexpr:use_alphablend_player_materials",
                                    Number(
                                        (
                                            newMessage.split(" ")[5] ?? "~"
                                        ).replaceAll(
                                            "~",
                                            String(
                                                player.getProperty(
                                                    "andexpr:use_alphablend_player_materials"
                                                )
                                            )
                                        )
                                    ) ??
                                    player.getProperty(
                                        "andexpr:use_alphablend_player_materials"
                                    )
                                );
                            } else {
                                targetSelectorAllListB(
                                    newMessage.split(" ").slice(6).join(" "),
                                    "",
                                    Number(player.id)
                                ).forEach((p) => {
                                    p.setProperty(
                                        "andexpr:color_tint_r",
                                        Number(
                                            (
                                                newMessage.split(" ")[1] ?? "~"
                                            ).replaceAll(
                                                "~",
                                                String(
                                                    p.getProperty(
                                                        "andexpr:color_tint_r"
                                                    )
                                                )
                                            )
                                        ) ??
                                        p.getProperty(
                                            "andexpr:color_tint_r"
                                        )
                                    );
                                    p.setProperty(
                                        "andexpr:color_tint_g",
                                        Number(
                                            (
                                                newMessage.split(" ")[2] ?? "~"
                                            ).replaceAll(
                                                "~",
                                                String(
                                                    p.getProperty(
                                                        "andexpr:color_tint_g"
                                                    )
                                                )
                                            )
                                        ) ??
                                        p.getProperty(
                                            "andexpr:color_tint_g"
                                        )
                                    );
                                    p.setProperty(
                                        "andexpr:color_tint_b",
                                        Number(
                                            (
                                                newMessage.split(" ")[3] ?? "~"
                                            ).replaceAll(
                                                "~",
                                                String(
                                                    p.getProperty(
                                                        "andexpr:color_tint_b"
                                                    )
                                                )
                                            )
                                        ) ??
                                        p.getProperty(
                                            "andexpr:color_tint_b"
                                        )
                                    );
                                    p.setProperty(
                                        "andexpr:color_tint_a",
                                        Number(
                                            (
                                                newMessage.split(" ")[4] ?? "~"
                                            ).replaceAll(
                                                "~",
                                                String(
                                                    p.getProperty(
                                                        "andexpr:color_tint_a"
                                                    )
                                                )
                                            )
                                        ) ??
                                        p.getProperty(
                                            "andexpr:color_tint_a"
                                        )
                                    );
                                    p.setProperty(
                                        "andexpr:use_alphablend_player_materials",
                                        Number(
                                            (
                                                newMessage.split(" ")[5] ?? "~"
                                            ).replaceAll(
                                                "~",
                                                String(
                                                    p.getProperty(
                                                        "andexpr:use_alphablend_player_materials"
                                                    )
                                                )
                                            )
                                        ) ??
                                        p.getProperty(
                                            "andexpr:use_alphablend_player_materials"
                                        )
                                    );
                                });
                            }
                        } catch (e) {
                            player.sendError("§c" + e + e.stack, true);
                        }
                    });
                } catch (e) {
                    eventData.sender.sendMessage("§c" + e + " " + e.stack);
                }
                break;
            case !!switchTest.match(/^scale$/):
                eventData.cancel = true;
                try {
                    system.run(() => {
                        try {
                            if (newMessage.split(" ")[2] == undefined) {
                                player.getComponent("scale").value = Number(
                                    newMessage.split(" ")[1]
                                );
                            } else {
                                targetSelectorAllListE(
                                    newMessage.split(" ").slice(2).join(" "),
                                    "~~~"
                                ).forEach((p) => {
                                    p.setProperty(
                                        "andexpr:entity_type",
                                        Number(newMessage.split(" ")[1])
                                    );
                                });
                            }
                        } catch (e) {
                            player.sendError("§c" + e + e.stack, true);
                        }
                    });
                } catch (e) {
                    player.sendError("§c" + e + e.stack, true);
                }
                break;
            case !!switchTest.match(/^visualscale$/):
                eventData.cancel = true;
                try {
                    system.run(() => {
                        try {
                            if (newMessage.split(" ")[2] == undefined) {
                                player.setProperty(
                                    "andexpr:entity_scale_variable_override",
                                    Number(newMessage.split(" ")[1])
                                );
                            } else {
                                targetSelectorAllListE(
                                    newMessage.split(" ").slice(2).join(" "),
                                    "~~~"
                                ).forEach((p) => {
                                    p.setProperty(
                                        "andexpr:entity_type",
                                        Number(newMessage.split(" ")[1])
                                    );
                                });
                            }
                        } catch (e) {
                            player.sendError("§c" + e + e.stack, true);
                        }
                    });
                } catch (e) {
                    player.sendError("§c" + e + e.stack, true);
                }
                break;
            case !!switchTest.match(/^visualscaleenabled$/):
                eventData.cancel = true;
                try {
                    system.run(() => {
                        try {
                            if (newMessage.split(" ")[2] == undefined) {
                                player.setProperty(
                                    "andexpr:entity_scale_variable_override_enabled",
                                    Boolean(
                                        newMessage
                                            .split(" ")[1]
                                            .replaceAll("false", "")
                                            .replaceAll("0", "")
                                            .replaceAll("False", "")
                                            .replaceAll("0.0", "")
                                    )
                                );
                            } else {
                                targetSelectorAllListE(
                                    newMessage.split(" ").slice(2).join(" "),
                                    "~~~"
                                ).forEach((p) => {
                                    p.setProperty(
                                        "andexpr:entity_type",
                                        Number(newMessage.split(" ")[1])
                                    );
                                });
                            }
                        } catch (e) {
                            player.sendError("§c" + e + e.stack, true);
                        }
                    });
                } catch (e) {
                    player.sendError("§c" + e + e.stack, true);
                }
                break;
            case !!switchTest.match(/^tps$/):
                eventData.cancel = true;
                try {
                    player.runCommandAsync(
                        "/scriptevent andexsa:getTPSExtraDetails"
                    );
                } catch (e) {
                    player.sendError("§c" + e + e.stack, true);
                }
                break;
            case !!switchTest.match(/^managescriptautoeval$/):
                eventData.cancel = true;
                try {
                    system.run(() => {
                        try {
                            if (newMessage.split(" ")[2] == undefined) {
                                player.setProperty(
                                    "andexpr:entity_scale_variable_override_enabled",
                                    Boolean(
                                        newMessage
                                            .split(" ")[1]
                                            .replaceAll("false", "")
                                            .replaceAll("0", "")
                                            .replaceAll("False", "")
                                            .replaceAll("0.0", "")
                                    )
                                );
                            } else {
                                targetSelectorAllListE(
                                    newMessage.split(" ").slice(2).join(" "),
                                    "~~~"
                                ).forEach((p) => {
                                    p.setProperty(
                                        "andexpr:entity_type",
                                        Number(newMessage.split(" ")[1])
                                    );
                                });
                            }
                        } catch (e) {
                            player.sendError("§c" + e + e.stack, true);
                        }
                    });
                } catch (e) {
                    player.sendError("§c" + e + e.stack, true);
                }
                break;
            case !!switchTest.match(/^mainmenu$/) ||
                !!switchTest.match(/^mm$/) ||
                !!switchTest.match(/^menu$/):
                eventData.cancel = true;
                try {
                    system.run(() => mainMenu(player));
                } catch (e) {
                    player.sendError("§c" + e + e.stack, true);
                }
                break;
            case !!switchTest.match(/^terminal$/) ||
                !!switchTest.match(/^cmdrunner$/):
                eventData.cancel = true;
                try {
                    terminal(player);
                } catch (e) {
                    player.sendError("§c" + e + e.stack, true);
                }
                break;
            case !!switchTest.match(/^messageui$/) ||
                !!switchTest.match(/^msgui$/):
                eventData.cancel = true;
                try {
                    chatMessageNoCensor(player);
                } catch (e) {
                    player.sendError("§c" + e + e.stack, true);
                }
                break;
            case !!switchTest.match(/^chatsendui$/) ||
                !!switchTest.match(/^chtsendui$/) ||
                !!switchTest.match(/^chtsndui$/) ||
                !!switchTest.match(/^sendui$/):
                eventData.cancel = true;
                try {
                    chatSendNoCensor(player);
                } catch (e) {
                    player.sendError("§c" + e + e.stack, true);
                }
                break;
            case !!switchTest.match(/^chatcommandui$/) ||
                !!switchTest.match(/^cmdui$/) ||
                !!switchTest.match(/^chtcmdui$/) ||
                !!switchTest.match(/^commandui$/):
                eventData.cancel = true;
                try {
                    chatCommandRunner(player);
                } catch (e) {
                    player.sendError("§c" + e + e.stack, true);
                }
                break;
            case !!switchTest.match(/^managecommands$/) ||
                !!switchTest.match(/^mngcmds$/):
                eventData.cancel = true;
                try {
                    system.run(() => manageCommands(player));
                } catch (e) {
                    player.sendError("§c" + e + e.stack, true);
                }
                break;
            case !!switchTest.match(/^manageplayers$/) ||
                !!switchTest.match(/^mngplyrs$/):
                eventData.cancel = true;
                try {
                    system.run(() => managePlayers(player));
                } catch (e) {
                    player.sendError("§c" + e + e.stack, true);
                }
                break;
            case !!switchTest.match(/^settings$/):
                eventData.cancel = true;
                try {
                    system.run(() => settings(player));
                } catch (e) {
                    player.sendError("§c" + e + e.stack, true);
                }
                break;
            case !!switchTest.match(/^extrafeaturessettings$/) ||
                !!switchTest.match(/^extrasettings$/):
                eventData.cancel = true;
                try {
                    system.run(() => extraFeaturesSettings(player));
                } catch (e) {
                    player.sendError("§c" + e + e.stack, true);
                }
                break;
            case !!switchTest.match(/^worldbordersettings$/) ||
                !!switchTest.match(/^wbsettings$/):
                eventData.cancel = true;
                try {
                    system.run(() => worldBorderSettings(player));
                } catch (e) {
                    player.sendError("§c" + e + e.stack, true);
                }
                break;
            case !!switchTest.match(/^shopsystemsettings$/) ||
                !!switchTest.match(/^shopsyssettings$/):
                eventData.cancel = true;
                try {
                    system.run(() => mainShopSystemSettings(player));
                } catch (e) {
                    player.sendError("§c" + e + e.stack, true);
                }
                break;
            case !!switchTest.match(/^servershopsystemsettings$/) ||
                !!switchTest.match(/^servershopsyssettings$/) ||
                !!switchTest.match(/^srvrshopsyssettings$/):
                eventData.cancel = true;
                try {
                    system.run(() => ServerShopManager.serverShopSystemSettings(player)
                    );
                } catch (e) {
                    player.sendError("§c" + e + e.stack, true);
                }
                break;
            case !!switchTest.match(/^playershopsystemsettings$/) ||
                !!switchTest.match(/^playershopsyssettings$/) ||
                !!switchTest.match(/^plyrshopsyssettings$/):
                eventData.cancel = true;
                try {
                    system.run(() => PlayerShopManager.playerShopSystemSettings(player)
                    );
                } catch (e) {
                    player.sendError("§c" + e + e.stack, true);
                }
                break;
            case !!switchTest.match(/^editorstick$/):
                eventData.cancel = true;
                try {
                    system.run(() => editorStick(player));
                } catch (e) {
                    player.sendError("§c" + e + e.stack, true);
                }
                break;
            case !!switchTest.match(/^editorstickb$/):
                eventData.cancel = true;
                try {
                    system.run(() => editorStickMenuB(player));
                } catch (e) {
                    player.sendError("§c" + e + e.stack, true);
                }
                break;
            case !!switchTest.match(/^editorstickc$/):
                eventData.cancel = true;
                try {
                    system.run(() => editorStickMenuC(player));
                } catch (e) {
                    player.sendError("§c" + e + e.stack, true);
                }
                break;
            case !!switchTest.match(/^notificationsettings$/) ||
                !!switchTest.match(/^notificationssettings$/):
                eventData.cancel = true;
                try {
                    system.run(() => notificationsSettings(player));
                } catch (e) {
                    player.sendError("§c" + e + e.stack, true);
                }
                break; // coming very soon now!




            /*case !!switchTest.match(/^closeuis$/):
            eventData.cancel = true;
            try{system.run(()=>world.getAllPlayers().forEach(p=>uiManager.closeAllForms(p))); }catch(e){player.sendError("§c" + e + e.stack, true)}
        break; */
            case !!switchTest.match(/^closeuis$/) ||
                !!switchTest.match(/^closeui$/):
                {
                    eventData.cancel = true;
                    srun(() => {
                        try {
                            const args = evaluateParameters(switchTestB, [
                                "presetText",
                                "targetSelector",
                            ]).args;
                            const players = world.getAllPlayers();
                            if ((args[1] ?? "").trim() == "") {
                                try {
                                    system.run(() => players.forEach((p) => uiManager.closeAllForms(p)
                                    )
                                    );
                                } catch (e) {
                                    player.sendError("§c" + e + e.stack, true);
                                }
                            } else {
                                const playerids = players.map((p) => p.id);
                                const targets = targetSelectorAllListC(
                                    args[1],
                                    "",
                                    vTStr(player.location),
                                    player
                                ).filter((p) => playerids.includes(p.id)
                                ) as Player[];
                                try {
                                    system.run(() => targets.forEach((p) => uiManager.closeAllForms(p)
                                    )
                                    );
                                } catch (e) {
                                    player.sendError("§c" + e + e.stack, true);
                                }
                            }
                        } catch (e) {
                            player.sendError(e);
                        }
                    });
                }
                break;
            case !!switchTest.match(/^stopalldbintervals$/):
                eventData.cancel = true;
                try {
                    Object.values(repeatingIntervals).forEach((v) => tryrun(() => system.clearRun(v))
                    );
                } catch (e) {
                    player.sendError("§c" + e + e.stack, true);
                }
                break;
            case !!switchTest.match(/^stopallsaintervals$/):
                eventData.cancel = true;
                try {
                    player.runCommandAsync(
                        "/scriptevent andexsa:clearRepeatingIntervals"
                    );
                } catch (e) {
                    player.sendError("§c" + e + e.stack, true);
                }
                break;
            case !!switchTest.match(/^datapickblock$/) ||
                !!switchTest.match(/^dpb$/):
                eventData.cancel = true;
                try {
                    let item = player
                        .getBlockFromViewDirection({
                            includeLiquidBlocks: true,
                            includePassableBlocks: true,
                        })
                        .block.getItemStack(1, true);
                    system.run(() => {
                        player
                            .getComponent("inventory")
                            .container.addItem(item);
                    });
                } catch (e) {
                    player.sendError("§c" + e + e.stack, true);
                }
                break;
            case !!switchTest.match(/^createexplosion$/):
                eventData.cancel = true;
                if (switchTestB.trim().split(" ").length == 1) {
                    player.sendMessageB(
                        `createexplosion command format: \n${command.dp}createexplosion <location: x y z> [dimension: string] [radius: float] [allowUnderwater: bool] [breaksBlocks: bool] [causesFire: bool] [source: targetSelector]`
                    );
                } else {
                    srun(() => {
                        try {
                            const args = evaluateParameters(switchTestB, [
                                "presetText",
                                "Vector3",
                                "string",
                                "number",
                                "boolean",
                                "boolean",
                                "boolean",
                                "targetSelector",
                            ]).args;
                            const d = world.getDimension(
                                (args[2] ?? "~").replaceAll(
                                    "~",
                                    player.dimension.id
                                )
                            );
                            const l = coordinatesB(
                                args[1],
                                player.location,
                                player.getViewDirection()
                            );
                            const options = {
                                allowUnderwater: args[4] ?? false,
                                breaksBlocks: args[5] ?? true,
                                causesFire: args[6] ?? false,
                                source: (args[7] ?? "").trim() == ""
                                    ? undefined
                                    : targetSelectorAllListC(
                                        args[7],
                                        "",
                                        vTStr(player.location),
                                        player
                                    )[0],
                            };
                            let s = d.createExplosion(l, args[3] ?? 1, options);
                            s
                                ? player.sendMessageB(
                                    `Successfully created an explosion at ${vTStr(
                                        l
                                    )} with radius ${args[3]} with the options: ${JSONStringify(
                                        options,
                                        true
                                    )}. `
                                )
                                : player.sendError(
                                    `§cError: Failed to create an explosion at ${vTStr(
                                        l
                                    )} with radius ${args[3]} with the options: ${JSONStringify(
                                        options,
                                        true
                                    )}. `,
                                    true
                                );
                        } catch (e) {
                            player.sendError("§c" + e + e.stack, true);
                        }
                    });
                }
                break;
            case !!switchTest.match(/^fill$/):
                {
                    //            Object.setPrototypeOf({}, Player.prototype)
                    //            (()=>{let p = new executeCommandPlayerW(player); p.modifiedlocation = {x: 0, y: 0, z: 0}; return p})()
                    eventData.cancel = true;
                    if (switchTestB.trim().split(" ").length == 1) {
                        player.sendMessageB(
                            `fill command format: \n${command.dp}fill <from: x y z> <to: x y z> <tileName: Block> [blockStates: block states] [replaceTileName: Block] [replaceBlockStates: block states]\n${command.dp}fill <from: x y z> <to: x y z> <tileName: Block> <replaceTileName: Block> [replaceBlockStates: block states]`
                        );
                    }
                    let coordinatesa = evaluateCoordinates(
                        Array.from(
                            switchTestB
                                .split(" ")
                                .slice(1)
                                .join(" ")
                                .matchAll(
                                    /\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis
                                )
                        )[0][0],
                        Array.from(
                            switchTestB
                                .split(" ")
                                .slice(1)
                                .join(" ")
                                .matchAll(
                                    /\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis
                                )
                        )[1][0],
                        Array.from(
                            switchTestB
                                .split(" ")
                                .slice(1)
                                .join(" ")
                                .matchAll(
                                    /\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis
                                )
                        )[2][0],
                        player.location,
                        player.getRotation()
                    );
                    let coordinatesb = evaluateCoordinates(
                        Array.from(
                            switchTestB
                                .split(" ")
                                .slice(1)
                                .join(" ")
                                .matchAll(
                                    /\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis
                                )
                        )[3][0],
                        Array.from(
                            switchTestB
                                .split(" ")
                                .slice(1)
                                .join(" ")
                                .matchAll(
                                    /\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis
                                )
                        )[4][0],
                        Array.from(
                            switchTestB
                                .split(" ")
                                .slice(1)
                                .join(" ")
                                .matchAll(
                                    /\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis
                                )
                        )[5][0],
                        player.location,
                        player.getRotation()
                    );
                    let firstblocknameindex = Array.from(
                        switchTestB
                            .split(" ")
                            .slice(1)
                            .join(" ")
                            .matchAll(
                                /\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis
                            )
                    )[5].index +
                        Array.from(
                            switchTestB
                                .split(" ")
                                .slice(1)
                                .join(" ")
                                .matchAll(
                                    /\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis
                                )
                        )[5][0].indexOf(" ") +
                        1;
                    let reststringaftercoordinates = switchTestB
                        .split(" ")
                        .slice(1)
                        .join(" ")
                        .slice(firstblocknameindex);
                    let firstblockname = reststringaftercoordinates.split(" ")[0];
                    let firstblockstates = reststringaftercoordinates
                        .split(" ")
                        .slice(1)
                        .join(" ")
                        .trimStart()
                        .startsWith("{")
                        ? JSONParse(
                            extractJSONStrings(
                                reststringaftercoordinates
                                    .split(" ")
                                    .slice(1)
                                    .join(" ")
                                    .trimStart(),
                                false
                            )[0]
                        )
                        : reststringaftercoordinates
                            .split(" ")
                            .slice(1)
                            .join(" ")
                            .trimStart()
                            .startsWith("[")
                            ? JSONParse(
                                extractJSONStrings(
                                    reststringaftercoordinates
                                        .split(" ")
                                        .slice(1)
                                        .join(" ")
                                        .trimStart()
                                        .replaceAll("=", ":")
                                        .replaceAll("[", "{")
                                        .replaceAll("]", "}"),
                                    false
                                )[0]
                            )
                            : undefined;
                    let lastblockname = reststringaftercoordinates
                        .split(" ")
                        .slice(1)
                        .join(" ")
                        .trimStart()
                        .startsWith("{")
                        ? reststringaftercoordinates
                            .split(" ")
                            .slice(1)
                            .join(" ")
                            .trimStart()
                            .slice(
                                extractJSONStrings(
                                    reststringaftercoordinates
                                        .split(" ")
                                        .slice(1)
                                        .join(" ")
                                        .trimStart(),
                                    false
                                )[0].length
                            )
                            .trimStart()
                            .split(" ")[0]
                        : reststringaftercoordinates
                            .split(" ")
                            .slice(1)
                            .join(" ")
                            .trimStart()
                            .startsWith("[")
                            ? reststringaftercoordinates
                                .split(" ")
                                .slice(1)
                                .join(" ")
                                .trimStart()
                                .slice(
                                    extractJSONStrings(
                                        reststringaftercoordinates
                                            .split(" ")
                                            .slice(1)
                                            .join(" ")
                                            .trimStart()
                                            .replaceAll("=", ":")
                                            .replaceAll("[", "{")
                                            .replaceAll("]", "}"),
                                        false
                                    )[0].length
                                )
                                .trimStart()
                                .split(" ")[0]
                            : reststringaftercoordinates
                                .trimStart()
                                .split(" ")
                                .slice(1)
                                .join(" ")
                                .trimStart()
                                .split(" ")[0];
                    let somethingtest = reststringaftercoordinates
                        .split(" ")
                        .slice(1)
                        .join(" ")
                        .trimStart()
                        .startsWith("{")
                        ? reststringaftercoordinates
                            .split(" ")
                            .slice(1)
                            .join(" ")
                            .trimStart()
                            .slice(
                                extractJSONStrings(
                                    reststringaftercoordinates
                                        .split(" ")
                                        .slice(1)
                                        .join(" ")
                                        .trimStart(),
                                    false
                                )[0].length
                            )
                            .trimStart()
                            .split(" ")
                            .slice(1)
                            .join(" ")
                            .trim()
                        : reststringaftercoordinates
                            .split(" ")
                            .slice(1)
                            .join(" ")
                            .trimStart()
                            .startsWith("[")
                            ? reststringaftercoordinates
                                .split(" ")
                                .slice(1)
                                .join(" ")
                                .trimStart()
                                .slice(
                                    extractJSONStrings(
                                        reststringaftercoordinates
                                            .split(" ")
                                            .slice(1)
                                            .join(" ")
                                            .trimStart()
                                            .replaceAll("=", ":")
                                            .replaceAll("[", "{")
                                            .replaceAll("]", "}"),
                                        false
                                    )[0].length
                                )
                                .trimStart()
                                .split(" ")
                                .slice(1)
                                .join(" ")
                                .trim()
                            : reststringaftercoordinates
                                .trimStart()
                                .split(" ")
                                .slice(1)
                                .join(" ")
                                .trimStart()
                                .split(" ")
                                .slice(1)
                                .join(" ")
                                .trim();
                    let lastblockstates = somethingtest.startsWith("{")
                        ? JSONParse(extractJSONStrings(somethingtest, false)[0])
                        : somethingtest.startsWith("[")
                            ? JSONParse(
                                extractJSONStrings(
                                    somethingtest
                                        .replaceAll("=", ":")
                                        .replaceAll("[", "{")
                                        .replaceAll("]", "}"),
                                    false
                                )[0]
                            )
                            : undefined;
                    let matchingblock = lastblockname == ""
                        ? undefined
                        : lastblockname == "keep"
                            ? BlockPermutation.resolve("air")
                            : BlockPermutation.resolve(
                                lastblockname,
                                lastblockstates
                            ); /*
  console.warn(JSONStringify({coordinatesa, coordinatesb, firstblockname, firstblocknameindex, reststringaftercoordinates, firstblockstates, lastblockname, somethingtest, lastblockstates, matchingblock}))*/

                    try {
                        srun(() => {
                            let a = player.dimension.fillBlocks(
                                new BlockVolume(coordinatesa, coordinatesb),
                                BlockPermutation.resolve(
                                    firstblockname,
                                    firstblockstates
                                ),
                                {
                                    blockFilter: {
                                        includePermutations: [matchingblock],
                                    },
                                }
                            );
                            player.sendMessageB(
                                `${a.getCapacity() == 0 ? "§c" : ""}${a} blocks filled`
                            );
                        });
                    } catch (e) {
                        player.sendError("§c" + e + e.stack, true);
                    }
                    //            try{system.run(()=>{player.dimension.fillBlocks(evaluateCoordinates(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[0][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[1][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[2][0], player.location, player.getRotation()), evaluateCoordinates(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[3][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[4][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0], player.location, player.getRotation()), BlockPermutation.resolve(switchTestB.split(" ").slice(1).join(" ").slice(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5].index+Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0].indexOf(" ")+1).split(" ")[0], extractJSONStrings(switchTestB.split(" ").slice(1).join(" ").slice(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5].index+Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0].indexOf(" ")).split(" ").slice(1).join(" "), false)[0]), {matchingBlock: BlockPermutation.resolve(getParametersFromString(switchTestB.split(" ").slice(1).join(" ").slice(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5].index+Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0].indexOf(" ")+1)).results[2], extractJSONStrings(switchTestB.split(" ").slice(1).join(" ").slice(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5].index+Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0].indexOf(" ")).split(" ").slice(1).join(" "), false)[1])}); }); }catch(e){player.sendError("§c" + e + e.stack, true)}
                }
                break;
            case !!switchTest.match(/^ifill$/):
                {
                    eventData.cancel = true;
                    if (switchTestB.trim().split(" ").length == 1) {
                        player.sendMessageB(`itfill command format: 
${command.dp}ifill <from: x y z> <to: x y z> <tileName: Block> <blockStates: block states> <ifillMode: replace|fill|cube|keep|walls|hollow|outline|pillars§c|floor|ceilling|diamond|hourglass§r> <replaceTileName: Block> [replaceBlockStates: block states] [clearContainers: boolean]
${command.dp}ifill <from: x y z> <to: x y z> <tileName: Block> <blockStates: block states> <ifillMode: replace|fill|cube|keep|walls|hollow|outline|pillars§c|floor|ceilling|diamond|hourglass§r> <reaplceTileName: Block> [clearContainers: boolean]
${command.dp}ifill <from: x y z> <to: x y z> <tileName: Block> <blockStates: block states> [ifillMode: replace|fill|cube|keep|walls|hollow|outline|pillars§c|floor|ceilling|diamond|hourglass§r] [clearContainers: boolean]
${command.dp}ifill <from: x y z> <to: x y z> <tileName: Block> <blockStates: block states> [clearContainers: boolean]
${command.dp}ifill <from: x y z> <to: x y z> <tileName: Block> <ifillMode: replace|fill|cube|keep|walls|hollow|outline|pillars§c|floor|ceilling|diamond|hourglass§r> <replaceTileName: Block> [replaceBlockStates: block states] [clearContainers: boolean]
${command.dp}ifill <from: x y z> <to: x y z> <tileName: Block> <ifillMode: replace|fill|cube|keep|walls|hollow|outline|pillars§c|floor|ceilling|diamond|hourglass§r> <reaplceTileName: Block> [clearContainers: boolean]
${command.dp}ifill <from: x y z> <to: x y z> <tileName: Block> [ifillMode: replace|fill|cube|keep|walls|hollow|outline|pillars§c|floor|ceilling|diamond|hourglass§r] [clearContainers: boolean]
${command.dp}ifill <from: x y z> <to: x y z> <tileName: Block> [clearContainers: boolean]
${command.dp}ifill <from: x y z> <to: x y z> <skygridSize: float> <tileName: Block> <blockStates: block states> <mode: skygrid|inverseskygrid> <replaceTileName: Block> [replaceBlockStates: block states] [clearContainers: boolean]
${command.dp}ifill <from: x y z> <to: x y z> <skygridSize: float> <tileName: Block> <blockStates: block states> <mode: skygrid|inverseskygrid> <reaplceTileName: Block> [clearContainers: boolean]
${command.dp}ifill <from: x y z> <to: x y z> <skygridSize: float> <tileName: Block> <blockStates: block states> <mode: skygrid|inverseskygrid> [clearContainers: boolean]
${command.dp}ifill <from: x y z> <to: x y z> <skygridSize: float> <tileName: Block> <blockStates: block states> <mode: skygrid|inverseskygrid> [clearContainers: boolean]
${command.dp}ifill <from: x y z> <to: x y z> <skygridSize: float> <tileName: Block> <mode: skygrid|inverseskygrid> <replaceTileName: Block> [replaceBlockStates: block states] [clearContainers: boolean]
${command.dp}ifill <from: x y z> <to: x y z> <skygridSize: float> <tileName: Block> <mode: skygrid|inverseskygrid> <reaplceTileName: Block> [clearContainers: boolean]
${command.dp}ifill <from: x y z> <to: x y z> <skygridSize: float> <tileName: Block> <mode: skygrid|inverseskygrid> [clearContainers: boolean]
${command.dp}ifill <from: x y z> <to: x y z> <tileName: Block> [clearContainers: boolean]
${command.dp}ifill <from: x y z> <to: x y z> clear [clearContainers: boolean]
${command.dp}ifill <from: x y z> <to: x y z> drain
${command.dp}ifill <center: x y z> <radius: float> <axis: {x}|{y}|{z}|{xy}|{yz}|{xz}|{xyz}> <tileName: Block> <blockStates: block states> circle [replaceTileName: Block] [replaceBlockStates: block states] [clearContainers: boolean]
${command.dp}ifill <center: x y z> <radius: float> <axis: {x}|{y}|{z}|{xy}|{yz}|{xz}|{xyz}> <tileName: Block> <blockStates: block states> circle [replaceTileName: Block] [clearContainers: boolean]
${command.dp}ifill <center: x y z> <radius: float> <axis: {x}|{y}|{z}|{xy}|{yz}|{xz}|{xyz}> <tileName: Block> <blockStates: block states> circle [clearContainers: boolean]
${command.dp}ifill <center: x y z> <radius: float> <axis: {x}|{y}|{z}|{xy}|{yz}|{xz}|{xyz}> <tileName: Block> circle [replaceTileName: Block] [replaceBlockStates: block states] [clearContainers: boolean]
${command.dp}ifill <center: x y z> <radius: float> <axis: {x}|{y}|{z}|{xy}|{yz}|{xz}|{xyz}> <tileName: Block> circle [replaceTileName: Block] [clearContainers: boolean]
${command.dp}ifill <center: x y z> <radius: float> <axis: {x}|{y}|{z}|{xy}|{yz}|{xz}|{xyz}> <tileName: Block> circle [clearContainers: boolean]
${command.dp}ifill <center: x y z> <radius: float> <tileName: Block> <blockStates: block states> <mode: {circlex}|{circley}|{circlez}|{circlexy}|{circleyz}|{circlexyz}|{sphere}|{semisphere}> <replaceTileName: Block> [replaceBlockStates: block states] [clearContainers: boolean]
${command.dp}ifill <center: x y z> <radius: float> <tileName: Block> <blockStates: block states> <mode: {circlex}|{circley}|{circlez}|{circlexy}|{circleyz}|{circlexyz}|{sphere}|{semisphere}> <replaceTileName: Block> [clearContainers: boolean]
${command.dp}ifill <center: x y z> <radius: float> <tileName: Block> <blockStates: block states> <mode: {circlex}|{circley}|{circlez}|{circlexy}|{circleyz}|{circlexyz}|{sphere}|{semisphere}> [clearContainers: boolean]
${command.dp}ifill <center: x y z> <radius: float> <tileName: Block> <mode: {circlex}|{circley}|{circlez}|{circlexy}|{circleyz}|{circlexyz}|{sphere}|{semisphere}> <replaceTileName: Block> [replaceBlockStates: block states] [clearContainers: boolean]
${command.dp}ifill <center: x y z> <radius: float> <tileName: Block> <mode: {circlex}|{circley}|{circlez}|{circlexy}|{circleyz}|{circlexyz}|{sphere}|{semisphere}> <replaceTileName: Block> [clearContainers: boolean]
${command.dp}ifill <center: x y z> <radius: float> <tileName: Block> <mode: {circlex}|{circley}|{circlez}|{circlexy}|{circleyz}|{circlexyz}|{sphere}|{semisphere}> [clearContainers: boolean]
${command.dp}ifill <center: x y z> <radius: float> <thickness: float> <tileName: Block> <blockStates: block states> <mode: hollowsphere|dome> <replaceTileName: Block> [replaceBlockStates: block states] [clearContainers: boolean]
${command.dp}ifill <center: x y z> <radius: float> <thickness: float> <tileName: Block> <blockStates: block states> <mode: hollowsphere|dome> <replaceTileName: Block> [clearContainers: boolean]
${command.dp}ifill <center: x y z> <radius: float> <thickness: float> <tileName: Block> <blockStates: block states> <mode: hollowsphere|dome> [clearContainers: boolean]
${command.dp}ifill <center: x y z> <radius: float> <thickness: float> <tileName: Block> <mode: hollowsphere|dome> <replaceTileName: Block> [replaceBlockStates: block states] [clearContainers: boolean]
${command.dp}ifill <center: x y z> <radius: float> <thickness: float> <tileName: Block> <mode: hollowsphere|dome> <replaceTileName: Block> [clearContainers: boolean]
${command.dp}ifill <center: x y z> <radius: float> <thickness: float> <tileName: Block> <mode: hollowsphere|dome> [clearContainers: boolean]
${command.dp}ifill <center: x y z> <radius: float> <length: float> <tileName: Block> <blockStates: block states> <mode: cylinderx|cylindery|cylinderz|cylinderxy|cylinderyz|cylinderxz|cylinderxyz> <replaceTileName: Block> [replaceBlockStates: block states] [clearContainers: boolean]
${command.dp}ifill <center: x y z> <radius: float> <length: float> <tileName: Block> <blockStates: block states> <mode: cylinderx|cylindery|cylinderz|cylinderxy|cylinderyz|cylinderxz|cylinderxyz> <replaceTileName: Block> [clearContainers: boolean]
${command.dp}ifill <center: x y z> <radius: float> <length: float> <tileName: Block> <blockStates: block states> <mode: cylinderx|cylindery|cylinderz|cylinderxy|cylinderyz|cylinderxz|cylinderxyz> [clearContainers: boolean]
${command.dp}ifill <center: x y z> <radius: float> <length: float> <tileName: Block> <mode: cylinderx|cylindery|cylinderz|cylinderxy|cylinderyz|cylinderxz|cylinderxyz> <replaceTileName: Block> [replaceBlockStates: block states] [clearContainers: boolean]
${command.dp}ifill <center: x y z> <radius: float> <length: float> <tileName: Block> <mode: cylinderx|cylindery|cylinderz|cylinderxy|cylinderyz|cylinderxz|cylinderxyz> <replaceTileName: Block> [clearContainers: boolean]
${command.dp}ifill <center: x y z> <radius: float> <length: float> <tileName: Block> <mode: cylinderx|cylindery|cylinderz|cylinderxy|cylinderyz|cylinderxz|cylinderxyz> [clearContainers: boolean]
${command.dp}ifill <center: x y z> <radius: float> <length: float> <axis: {x}|{y}|{z}|{xy}|{yz}|{xz}|{xyz}> <tileName: Block> <blockStates: block states> <mode: tunnel|cylinder> [replaceTileName: Block] [replaceBlockStates: block states] [clearContainers: boolean]
${command.dp}ifill <center: x y z> <radius: float> <length: float> <axis: {x}|{y}|{z}|{xy}|{yz}|{xz}|{xyz}> <tileName: Block> <blockStates: block states> <mode: tunnel|cylinder> [replaceTileName: Block] [clearContainers: boolean]
${command.dp}ifill <center: x y z> <radius: float> <length: float> <axis: {x}|{y}|{z}|{xy}|{yz}|{xz}|{xyz}> <tileName: Block> <blockStates: block states> <mode: tunnel|cylinder> [clearContainers: boolean]
${command.dp}ifill <center: x y z> <radius: float> <length: float> <axis: {x}|{y}|{z}|{xy}|{yz}|{xz}|{xyz}> <tileName: Block> <mode: tunnel|cylinder> [replaceTileName: Block] [replaceBlockStates: block states] [clearContainers: boolean]
${command.dp}ifill <center: x y z> <radius: float> <length: float> <axis: {x}|{y}|{z}|{xy}|{yz}|{xz}|{xyz}> <tileName: Block> <mode: tunnel|cylinder> [replaceTileName: Block] [clearContainers: boolean]
${command.dp}ifill <center: x y z> <radius: float> <length: float> <axis: {x}|{y}|{z}|{xy}|{yz}|{xz}|{xyz}> <tileName: Block> <mode: tunnel|cylinder> [clearContainers: boolean]
${command.dp}ifill <center: x y z> <radius: x y z> <offset: x y z> <length: float> <tileName: Block> <blockStates: block states> hollowovoid [replaceTileName: Block] [replaceBlockStates: block states] [clearContainers: boolean]
${command.dp}ifill <center: x y z> <radius: x y z> <offset: x y z> <length: float> <tileName: Block> <blockStates: block states> hollowovoid [replaceTileName: Block] [clearContainers: boolean]
${command.dp}ifill <center: x y z> <radius: x y z> <offset: x y z> <length: float> <tileName: Block> <blockStates: block states> hollowovoid [clearContainers: boolean]
${command.dp}ifill <center: x y z> <radius: x y z> <offset: x y z> <length: float> <tileName: Block> hollowovoid [replaceTileName: Block] [replaceBlockStates: block states] [clearContainers: boolean]
${command.dp}ifill <center: x y z> <radius: x y z> <offset: x y z> <length: float> <tileName: Block> hollowovoid [replaceTileName: Block] [clearContainers: boolean]
${command.dp}ifill <center: x y z> <radius: x y z> <offset: x y z> <length: float> <tileName: Block> hollowovoid [clearContainers: boolean]`);
                    } else {
                        let argsa = evaluateParameters(switchTestB, [
                            "presetText",
                            "Vector",
                            "Vector",
                            "Vector",
                            "Vector",
                            "Vector",
                            "Vector",
                            "string",
                            "blockStates",
                            "presetText",
                            "non-booleanString",
                            "blockStates",
                            "neboolean",
                        ]);
                        let argsb = evaluateParameters(switchTestB, [
                            "presetText",
                            "Vector",
                            "Vector",
                            "Vector",
                            "number",
                            "string",
                            "presetText",
                            "blockStates",
                            "presetText",
                            "non-booleanString",
                            "blockStates",
                            "neboolean",
                        ]);
                        let argsd = evaluateParameters(switchTestB, [
                            "presetText",
                            "Vector",
                            "Vector",
                            "Vector",
                            "number",
                            "string",
                            "blockStates",
                            "presetText",
                            "non-booleanString",
                            "blockStates",
                            "neboolean",
                        ]);
                        let argsf = evaluateParameters(switchTestB, [
                            "presetText",
                            "Vector",
                            "Vector",
                            "Vector",
                            "number",
                            "number",
                            "string",
                            "blockStates",
                            "presetText",
                            "non-booleanString",
                            "blockStates",
                            "neboolean",
                        ]);
                        let argsh = evaluateParameters(switchTestB, [
                            "presetText",
                            "Vector",
                            "Vector",
                            "Vector",
                            "number",
                            "number",
                            "string",
                            "string",
                            "blockStates",
                            "presetText",
                            "non-booleanString",
                            "blockStates",
                            "neboolean",
                        ]);
                        let argsj = evaluateParameters(switchTestB, [
                            "presetText",
                            "Vector",
                            "Vector",
                            "Vector",
                            "Vector",
                            "Vector",
                            "Vector",
                            "Vector",
                            "Vector",
                            "Vector",
                            "number",
                            "string",
                            "blockStates",
                            "presetText",
                            "non-booleanString",
                            "blockStates",
                            "neboolean",
                        ]);
                        let argsl = evaluateParameters(switchTestB, [
                            "presetText",
                            "Vector",
                            "Vector",
                            "Vector",
                            "Vector",
                            "Vector",
                            "Vector",
                            "Vector",
                            "Vector",
                            "Vector",
                            "string",
                            "blockStates",
                            "presetText",
                            "non-booleanString",
                            "blockStates",
                            "neboolean",
                        ]);
                        let argsn = evaluateParameters(switchTestB, [
                            "presetText",
                            "Vector",
                            "Vector",
                            "Vector",
                            "Vector",
                            "Vector",
                            "Vector",
                            "number",
                            "string",
                            "blockStates",
                            "presetText",
                            "non-booleanString",
                            "blockStates",
                            "neboolean",
                        ]);
                        //console.warn(argsh.args)
                        let args = argsa.args;
                        let argsc = argsb.args;
                        let argse = argsd.args;
                        let argsg = argsf.args;
                        let argsi = argsh.args;
                        let argsk = argsj.args;
                        let argsm = argsl.args;
                        let argso = argsn.args;
                        let argsaextra = argsa.extra;
                        let argsbextra = argsb.extra;
                        let argsdextra = argsd.extra;
                        let argsfextra = argsf.extra;
                        let argshextra = argsh.extra;
                        let argsjextra = argsj.extra;
                        let argslextra = argsl.extra;
                        let argsnextra = argsn.extra;
                        //console.warn(JSONStringify(args), JSONStringify(argsaextra))
                        let center = evaluateCoordinates(
                            argsc[1],
                            argsc[2],
                            argsc[3],
                            roundVector3ToMiddleOfBlock(player.location),
                            player.getRotation()
                        );
                        let radius = argsc[4];
                        let axis = argsc[5];
                        let cfirstblockname = argsc[6];
                        let cfirstblockstates = argsc[7];
                        let cmode = argsc[8] as string;
                        let clastblockname = argsc[9];
                        let clastblockstates = argsc[10];
                        let creplacemode = argsc[11] ?? false;
                        let ccfirstblockname = argse[5];
                        let ccfirstblockstates = argse[6];
                        let ccmode = argse[7] as string;
                        let cclastblockname = argse[8];
                        let cclastblockstates = argse[9];
                        let ccreplacemode = argse[10] ?? false;
                        let thickness = argsg[5];
                        let hsfirstblockname = argsg[6];
                        let hsfirstblockstates = argsg[7];
                        let hsmode = argsg[8] as string;
                        let hslastblockname = argsg[9];
                        let hslastblockstates = argsg[10];
                        let hsreplacemode = argsg[11] ?? false;
                        let taxis = argsi[6];
                        let tfirstblockname = argsi[7];
                        let tfirstblockstates = argsi[8];
                        let tmode = argsi[9] as string;
                        let tlastblockname = argsi[10];
                        let tlastblockstates = argsi[11];
                        let treplacemode = argsi[12] ?? false;
                        let sgskygridsize = argso[7];
                        let sgfirstblockname = argso[8];
                        let sgfirstblockstates = argso[9];
                        let sgmode = argso[10] as string;
                        let sglastblockname = argso[11];
                        let sglastblockstates = argso[12];
                        let sgreplacemode = argso[13] ?? false;
                        let circlemode = false;
                        new Date(Date.now()).getMilliseconds();
                        let ccirclemode = false;
                        let hspheremode = false;
                        let tunnelmode = false;
                        let ovoidmode = false;
                        let hovoidmode = false;
                        let skygridmode = false;
                        if (["circle"].includes(
                            fillmodetypeenum[argsc[8] ??
                            "undefined"?.toLowerCase()?.trim()]
                        )) {
                            circlemode = true;
                        }
                        if ([
                            "circlex",
                            "circley",
                            "circlez",
                            "circlexy",
                            "circleyz",
                            "circlexz",
                            "circlexyz",
                            "sphere",
                            "semisphere",
                        ].includes(
                            fillmodetypeenum[argse[7] ??
                            "undefined"?.toLowerCase()?.trim()]
                        )) {
                            ccirclemode = true;
                        }
                        if ([
                            "hollowsphere",
                            "cylinderx",
                            "cylindery",
                            "cylinderz",
                            "cylinderxy",
                            "cylinderyz",
                            "cylinderxz",
                            "cylinderxyz",
                            "dome",
                        ].includes(
                            fillmodetypeenum[argsg[8] ??
                            "undefined"?.toLowerCase()?.trim()]
                        )) {
                            hspheremode = true;
                        }
                        if (["tunnel", "cylinder"].includes(
                            fillmodetypeenum[argsi[9] ??
                            "undefined"?.toLowerCase()?.trim()]
                        )) {
                            tunnelmode = true;
                        }
                        if (["ovoid"].includes(
                            fillmodetypeenum[argsm[12] ??
                            "undefined"?.toLowerCase()?.trim()]
                        )) {
                            ovoidmode = true;
                        }
                        if (["hollowovoid"].includes(
                            fillmodetypeenum[argsk[13] ??
                            "undefined"?.toLowerCase()?.trim()]
                        )) {
                            hovoidmode = true;
                        }
                        if (["skygrid", "inverseskygrid"].includes(
                            fillmodetypeenum[argso[10] ??
                            "undefined"?.toLowerCase()?.trim()]
                        )) {
                            skygridmode = true;
                        }
                        let coordinatesa: Vector3; /*
            console.warn(circlemode, ccirclemode, hspheremode)*/

                        if (!circlemode &&
                            !ccirclemode &&
                            !hspheremode &&
                            !tunnelmode) {
                            coordinatesa = evaluateCoordinates(
                                args[1],
                                args[2],
                                args[3],
                                roundVector3ToMiddleOfBlock(player.location),
                                player.getRotation()
                            );
                        }
                        let coordinatesb: Vector3;
                        if (!circlemode &&
                            !ccirclemode &&
                            !hspheremode &&
                            !tunnelmode) {
                            coordinatesb = evaluateCoordinates(
                                args[4],
                                args[5],
                                args[6],
                                roundVector3ToMiddleOfBlock(player.location),
                                player.getRotation()
                            );
                        }
                        let horadi: Vector3;
                        let hooffset: Vector3;
                        let hothickness = argsk[10];
                        let hofirstblockname = argsk[11];
                        let hofirstblockstates = argsk[12];
                        let homode = argsk[13] as string;
                        let holastblockname = argsk[14];
                        let holastblockstates = argsk[15];
                        let horeplacemode = argsk[16] ?? false;
                        if (hovoidmode) {
                            horadi = evaluateCoordinates(
                                argsk[4],
                                argsk[5],
                                argsk[6],
                                roundVector3ToMiddleOfBlock(player.location),
                                player.getRotation()
                            );
                            hooffset = evaluateCoordinates(
                                argsk[7],
                                argsk[8],
                                argsk[9],
                                roundVector3ToMiddleOfBlock(player.location),
                                player.getRotation()
                            );
                        }
                        let oradi: Vector3;
                        let ooffset: Vector3;
                        let ofirstblockname = argsm[10];
                        let ofirstblockstates = argsm[11];
                        let omode = argsm[12] as string;
                        let olastblockname = argsm[13];
                        let olastblockstates = argsm[14];
                        let oreplacemode = argsm[15] ?? false;
                        if (ovoidmode) {
                            oradi = evaluateCoordinates(
                                argsm[4],
                                argsm[5],
                                argsm[6],
                                roundVector3ToMiddleOfBlock(player.location),
                                player.getRotation()
                            );
                            ooffset = evaluateCoordinates(
                                argsm[7],
                                argsm[8],
                                argsm[9],
                                roundVector3ToMiddleOfBlock(player.location),
                                player.getRotation()
                            );
                        }
                        let firstblockname = args[7];
                        let firstblockstates = args[8];
                        let mode = args[9] as string;
                        let lastblockname = args[10];
                        let lastblockstates = args[11];
                        let replacemode = args[12] ?? false;
                        let matchingblock = (
                            (lastblockname ?? "") == ""
                                ? [undefined, undefined]
                                : lastblockname == "keep" || mode == "keep"
                                    ? ["air"]
                                    : [
                                        BlockTypes.get(lastblockname).id,
                                        lastblockstates,
                                    ]
                        ) as [
                                string,
                                { [id: string]: string | number | boolean; }
                            ];
                        let cmatchingblock = (
                            (clastblockname ?? "") == ""
                                ? [undefined, undefined]
                                : clastblockname == "keep"
                                    ? ["air"]
                                    : [clastblockname, clastblockstates]
                        ) as [
                                string,
                                { [id: string]: string | number | boolean; }
                            ];
                        let ccmatchingblock = (
                            (cclastblockname ?? "") == ""
                                ? [undefined, undefined]
                                : cclastblockname == "keep"
                                    ? ["air"]
                                    : [cclastblockname, cclastblockstates]
                        ) as [
                                string,
                                { [id: string]: string | number | boolean; }
                            ];
                        let hsmatchingblock = (
                            (hslastblockname ?? "") == ""
                                ? [undefined, undefined]
                                : hslastblockname == "keep"
                                    ? ["air"]
                                    : [hslastblockname, hslastblockstates]
                        ) as [
                                string,
                                { [id: string]: string | number | boolean; }
                            ];
                        let tmatchingblock = (
                            (tlastblockname ?? "") == ""
                                ? [undefined, undefined]
                                : tlastblockname == "keep"
                                    ? ["air"]
                                    : [tlastblockname, tlastblockstates]
                        ) as [
                                string,
                                { [id: string]: string | number | boolean; }
                            ];
                        let omatchingblock = (
                            (olastblockname ?? "") == ""
                                ? [undefined, undefined]
                                : olastblockname == "keep"
                                    ? ["air"]
                                    : [olastblockname, olastblockstates]
                        ) as [
                                string,
                                { [id: string]: string | number | boolean; }
                            ];
                        let homatchingblock = (
                            (holastblockname ?? "") == ""
                                ? [undefined, undefined]
                                : holastblockname == "keep"
                                    ? ["air"]
                                    : [holastblockname, holastblockstates]
                        ) as [
                                string,
                                { [id: string]: string | number | boolean; }
                            ];
                        let sgmatchingblock = (
                            (sglastblockname ?? "") == ""
                                ? [undefined, undefined]
                                : sglastblockname == "keep"
                                    ? ["air"]
                                    : [sglastblockname, sglastblockstates]
                        ) as [
                                string,
                                { [id: string]: string | number | boolean; }
                            ]; /*
            console.warn(JSONStringify({coordinatesa, coordinatesb, firstblockname, firstblocknameindex, reststringaftercoordinates, firstblockstates, lastblockname, somethingtest, lastblockstates, matchingblock}))*/

                        switch (fillmodetypeenum[skygridmode
                            ? sgmode
                            : hovoidmode
                                ? homode
                                : ovoidmode
                                    ? omode
                                    : tunnelmode
                                        ? tmode
                                        : hspheremode
                                            ? hsmode
                                            : circlemode
                                                ? cmode
                                                : ccirclemode
                                                    ? ccmode
                                                    : mode ?? ""]) {
                            case "":
                                system.run(() => {
                                    let ta: Entity;
                                    try {
                                        let location = {
                                            x: (coordinatesa.x +
                                                coordinatesb.x) /
                                                2,
                                            y: (coordinatesa.y +
                                                coordinatesb.y) /
                                                2,
                                            z: (coordinatesa.z +
                                                coordinatesb.z) /
                                                2,
                                        };
                                        player.dimension.runCommand(
                                            "summon andexdb:tickingarea_6 itwalls " +
                                            vTStr(location)
                                        );
                                        ta = player.dimension
                                            .getEntitiesAtBlockLocation(
                                                location
                                            )
                                            .find(
                                                (v) => v.typeId ==
                                                    "andexdb:tickingarea_6"
                                            );
                                        system.runTimeout(() => {
                                            try {
                                                let startTime = Date.now();
                                                if (replacemode) {
                                                    clearAllContainerBlocks(
                                                        scanForContainerBlocks(
                                                            coordinatesa,
                                                            coordinatesb,
                                                            player.dimension,
                                                            "Block"
                                                        ) as Block[]
                                                    );
                                                }
                                                let a = fillBlocksH(
                                                    coordinatesa,
                                                    coordinatesb,
                                                    player.dimension,
                                                    firstblockname,
                                                    firstblockstates,
                                                    {
                                                        matchingBlock: matchingblock[0],
                                                        matchingBlockStates: matchingblock[1],
                                                    }
                                                );
                                                let endTime = Date.now();
                                                player.sendMessageB(
                                                    `${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`
                                                );
                                            } catch (e) {
                                                player.sendError(
                                                    "§c" + e + e.stack,
                                                    true
                                                );
                                            } finally {
                                                ta?.remove();
                                            }
                                        }, 2);
                                    } catch (e) {
                                        player.sendError(
                                            "§c" + e + e.stack,
                                            true
                                        );
                                    }
                                });
                                break;
                            case "replace":
                                system.run(() => {
                                    let ta: Entity;
                                    try {
                                        let location = {
                                            x: (coordinatesa.x +
                                                coordinatesb.x) /
                                                2,
                                            y: (coordinatesa.y +
                                                coordinatesb.y) /
                                                2,
                                            z: (coordinatesa.z +
                                                coordinatesb.z) /
                                                2,
                                        };
                                        player.dimension.runCommand(
                                            "summon andexdb:tickingarea_6 itwalls " +
                                            vTStr(location)
                                        );
                                        ta = player.dimension
                                            .getEntitiesAtBlockLocation(
                                                location
                                            )
                                            .find(
                                                (v) => v.typeId ==
                                                    "andexdb:tickingarea_6"
                                            );
                                        system.runTimeout(() => {
                                            try {
                                                let startTime = Date.now();
                                                if (replacemode) {
                                                    clearAllContainerBlocks(
                                                        scanForContainerBlocks(
                                                            coordinatesa,
                                                            coordinatesb,
                                                            player.dimension,
                                                            "Block"
                                                        ) as Block[]
                                                    );
                                                }
                                                let a = fillBlocksH(
                                                    coordinatesa,
                                                    coordinatesb,
                                                    player.dimension,
                                                    firstblockname,
                                                    firstblockstates,
                                                    {
                                                        matchingBlock: matchingblock[0],
                                                        matchingBlockStates: matchingblock[1],
                                                    }
                                                );
                                                let endTime = Date.now();
                                                player.sendMessageB(
                                                    `${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`
                                                );
                                            } catch (e) {
                                                player.sendError(
                                                    "§c" + e + e.stack,
                                                    true
                                                );
                                            } finally {
                                                ta?.remove();
                                            }
                                        }, 2);
                                    } catch (e) {
                                        player.sendError(
                                            "§c" + e + e.stack,
                                            true
                                        );
                                    }
                                });
                                break;
                            case "clear":
                                system.run(() => {
                                    try {
                                        let startTime = Date.now();
                                        if (replacemode) {
                                            clearAllContainerBlocks(
                                                scanForContainerBlocks(
                                                    coordinatesa,
                                                    coordinatesb,
                                                    player.dimension,
                                                    "Block"
                                                ) as Block[]
                                            );
                                        }
                                        let a = fillBlocksH(
                                            coordinatesa,
                                            coordinatesb,
                                            player.dimension,
                                            "air"
                                        );
                                        let endTime = Date.now();
                                        player.sendMessageB(
                                            `${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`
                                        );
                                    } catch (e) {
                                        player.sendError(
                                            "§c" + e + e.stack,
                                            true
                                        );
                                    }
                                });
                                break;
                            case "drain":
                                system.run(() => {
                                    try {
                                        let startTime = Date.now();
                                        let a = fillBlocksH(
                                            coordinatesa,
                                            coordinatesb,
                                            player.dimension,
                                            "air",
                                            undefined,
                                            { matchingBlock: "water" }
                                        );
                                        let endTime = Date.now();
                                        player.sendMessageB(
                                            `${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`
                                        );
                                    } catch (e) {
                                        player.sendError(
                                            "§c" + e + e.stack,
                                            true
                                        );
                                    }
                                });
                                break;
                            case "fill":
                                system.run(() => {
                                    try {
                                        let startTime = Date.now();
                                        if (replacemode) {
                                            clearAllContainerBlocks(
                                                scanForContainerBlocks(
                                                    coordinatesa,
                                                    coordinatesb,
                                                    player.dimension,
                                                    "Block"
                                                ) as Block[]
                                            );
                                        }
                                        let a = fillBlocksH(
                                            coordinatesa,
                                            coordinatesb,
                                            player.dimension,
                                            firstblockname,
                                            firstblockstates,
                                            {
                                                matchingBlock: matchingblock[0],
                                                matchingBlockStates: matchingblock[1],
                                            }
                                        );
                                        let endTime = Date.now();
                                        player.sendMessageB(
                                            `${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`
                                        );
                                    } catch (e) {
                                        player.sendError(
                                            "§c" + e + e.stack,
                                            true
                                        );
                                    }
                                });
                                break;
                            case "keep":
                                system.run(() => {
                                    try {
                                        let startTime = Date.now();
                                        let a = fillBlocksH(
                                            coordinatesa,
                                            coordinatesb,
                                            player.dimension,
                                            firstblockname,
                                            firstblockstates,
                                            { matchingBlock: "air" }
                                        );
                                        let endTime = Date.now();
                                        player.sendMessageB(
                                            `${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`
                                        );
                                    } catch (e) {
                                        player.sendError(
                                            "§c" + e + e.stack,
                                            true
                                        );
                                    }
                                });
                                break;
                            case "walls":
                                system.run(() => {
                                    try {
                                        let startTime = Date.now();
                                        let a = fillBlocksHW(
                                            coordinatesa,
                                            coordinatesb,
                                            player.dimension,
                                            firstblockname,
                                            firstblockstates,
                                            {
                                                matchingBlock: matchingblock[0],
                                                matchingBlockStates: matchingblock[1],
                                            },
                                            undefined,
                                            replacemode
                                        );
                                        let endTime = Date.now();
                                        player.sendMessageB(
                                            `${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`
                                        );
                                    } catch (e) {
                                        player.sendError(
                                            "§c" + e + e.stack,
                                            true
                                        );
                                    }
                                });
                                break;
                            case "hollow":
                                system.run(() => {
                                    try {
                                        let startTime = Date.now();
                                        let a = fillBlocksHH(
                                            coordinatesa,
                                            coordinatesb,
                                            player.dimension,
                                            firstblockname,
                                            firstblockstates,
                                            {
                                                matchingBlock: matchingblock[0],
                                                matchingBlockStates: matchingblock[1],
                                            },
                                            undefined,
                                            replacemode
                                        );
                                        let endTime = Date.now();
                                        player.sendMessageB(
                                            `${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`
                                        );
                                    } catch (e) {
                                        player.sendError(
                                            "§c" + e + e.stack,
                                            true
                                        );
                                    }
                                });
                                break;
                            case "outline":
                                system.run(() => {
                                    try {
                                        let startTime = Date.now();
                                        let a = fillBlocksHO(
                                            coordinatesa,
                                            coordinatesb,
                                            player.dimension,
                                            firstblockname,
                                            firstblockstates,
                                            {
                                                matchingBlock: matchingblock[0],
                                                matchingBlockStates: matchingblock[1],
                                            },
                                            undefined,
                                            replacemode
                                        );
                                        let endTime = Date.now();
                                        player.sendMessageB(
                                            `${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`
                                        );
                                    } catch (e) {
                                        player.sendError(
                                            "§c" + e + e.stack,
                                            true
                                        );
                                    }
                                });
                                break;
                            case "pillars":
                                system.run(() => {
                                    try {
                                        let startTime = Date.now();
                                        let a = fillBlocksHP(
                                            coordinatesa,
                                            coordinatesb,
                                            player.dimension,
                                            firstblockname,
                                            firstblockstates,
                                            {
                                                matchingBlock: matchingblock[0],
                                                matchingBlockStates: matchingblock[1],
                                            },
                                            undefined,
                                            replacemode
                                        );
                                        let endTime = Date.now();
                                        player.sendMessageB(
                                            `${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`
                                        );
                                    } catch (e) {
                                        player.sendError(
                                            "§c" + e + e.stack,
                                            true
                                        );
                                    }
                                });
                                break;
                            case "skygrid":
                                system.run(() => {
                                    try {
                                        fillBlocksHSGG(
                                            coordinatesa,
                                            coordinatesb,
                                            sgskygridsize,
                                            player.dimension,
                                            sgfirstblockname,
                                            sgfirstblockstates,
                                            {
                                                matchingBlock: sgmatchingblock[0],
                                                matchingBlockStates: sgmatchingblock[1],
                                                minMSBetweenYields: 5000,
                                            },
                                            undefined,
                                            sgreplacemode,
                                            100
                                        ).then(
                                            (a) => {
                                                player.sendMessageB(
                                                    `${a.counter == 0
                                                        ? "§c"
                                                        : ""}${a.counter} blocks filled in ${a.completionData
                                                        .endTime -
                                                    a.completionData
                                                        .startTime} ms over ${a.completionData
                                                        .endTick -
                                                    a.completionData
                                                        .startTick} tick${a.completionData
                                                        .endTick -
                                                        a.completionData
                                                            .startTick ==
                                                        1
                                                        ? ""
                                                        : "s"}${a.completionData
                                                        .containsUnloadedChunks
                                                        ? "; Some blocks were not generated because they were in unloaded chunks. "
                                                        : ""}`
                                                );
                                            },
                                            (e) => {
                                                player.sendError(
                                                    "§c" + e + e.stack,
                                                    true
                                                );
                                            }
                                        );
                                    } catch (e) {
                                        player.sendError(
                                            "§c" + e + e.stack,
                                            true
                                        );
                                    }
                                });
                                break;
                            case "inverseskygrid":
                                system.run(() => {
                                    try {
                                        fillBlocksHISGG(
                                            coordinatesa,
                                            coordinatesb,
                                            sgskygridsize,
                                            player.dimension,
                                            sgfirstblockname,
                                            sgfirstblockstates,
                                            {
                                                matchingBlock: sgmatchingblock[0],
                                                matchingBlockStates: sgmatchingblock[1],
                                                minMSBetweenYields: 5000,
                                            },
                                            undefined,
                                            sgreplacemode,
                                            100
                                        ).then(
                                            (a) => {
                                                player.sendMessageB(
                                                    `${a.counter == 0
                                                        ? "§c"
                                                        : ""}${a.counter} blocks filled in ${a.completionData
                                                        .endTime -
                                                    a.completionData
                                                        .startTime} ms over ${a.completionData
                                                        .endTick -
                                                    a.completionData
                                                        .startTick} tick${a.completionData
                                                        .endTick -
                                                        a.completionData
                                                            .startTick ==
                                                        1
                                                        ? ""
                                                        : "s"}${a.completionData
                                                        .containsUnloadedChunks
                                                        ? "; Some blocks were not generated because they were in unloaded chunks. "
                                                        : ""}`
                                                );
                                            },
                                            (e) => {
                                                player.sendError(
                                                    "§c" + e + e.stack,
                                                    true
                                                );
                                            }
                                        );
                                    } catch (e) {
                                        player.sendError(
                                            "§c" + e + e.stack,
                                            true
                                        );
                                    }
                                });
                                break;
                            case "tunnel":
                                player.sendMessageB("§eComing Soon! ");
                                break;
                            case "floor":
                                player.sendMessageB("§eComing Soon! ");
                                break;
                            case "ceilling":
                                player.sendMessageB("§eComing Soon! ");
                                break;
                            case "diamond":
                                player.sendMessageB("§eComing Soon! ");
                                break;
                            case "hollowovoid":
                                system.run(() => {
                                    try {
                                        fillBlocksHHOG(
                                            center,
                                            vTV3(
                                                Vector3Utils.subtract(
                                                    horadi,
                                                    {
                                                        x: -0.5,
                                                        y: -0.5,
                                                        z: -0.5,
                                                    }
                                                )
                                            ),
                                            hooffset,
                                            hothickness,
                                            player.dimension,
                                            hofirstblockname,
                                            hofirstblockstates,
                                            {
                                                matchingBlock: homatchingblock[0],
                                                matchingBlockStates: homatchingblock[1],
                                                minMSBetweenYields: 5000,
                                            },
                                            undefined,
                                            horeplacemode,
                                            100
                                        ).then(
                                            (a) => {
                                                player.sendMessageB(
                                                    `${a.counter == 0
                                                        ? "§c"
                                                        : ""}${a.counter} blocks filled in ${a.completionData
                                                        .endTime -
                                                    a.completionData
                                                        .startTime} ms over ${a.completionData
                                                        .endTick -
                                                    a.completionData
                                                        .startTick} tick${a.completionData
                                                        .endTick -
                                                        a.completionData
                                                            .startTick ==
                                                        1
                                                        ? ""
                                                        : "s"}${a.completionData
                                                        .containsUnloadedChunks
                                                        ? "; Some blocks were not generated because they were in unloaded chunks. "
                                                        : ""}`
                                                );
                                            },
                                            (e) => {
                                                player.sendError(
                                                    "§c" + e + e.stack,
                                                    true
                                                );
                                            }
                                        );
                                    } catch (e) {
                                        player.sendError(
                                            "§c" + e + e.stack,
                                            true
                                        );
                                    }
                                });
                                break;
                            case "ovoid":
                                system.run(() => {
                                    try {
                                        fillBlocksHOG(
                                            center,
                                            vTV3(
                                                Vector3Utils.subtract(
                                                    oradi,
                                                    {
                                                        x: -0.5,
                                                        y: -0.5,
                                                        z: -0.5,
                                                    }
                                                )
                                            ),
                                            ooffset,
                                            player.dimension,
                                            ofirstblockname,
                                            ofirstblockstates,
                                            {
                                                matchingBlock: omatchingblock[0],
                                                matchingBlockStates: omatchingblock[1],
                                                minMSBetweenYields: 5000,
                                            },
                                            undefined,
                                            oreplacemode,
                                            100
                                        ).then(
                                            (a) => {
                                                player.sendMessageB(
                                                    `${a.counter == 0
                                                        ? "§c"
                                                        : ""}${a.counter} blocks filled in ${a.completionData
                                                        .endTime -
                                                    a.completionData
                                                        .startTime} ms over ${a.completionData
                                                        .endTick -
                                                    a.completionData
                                                        .startTick} tick${a.completionData
                                                        .endTick -
                                                        a.completionData
                                                            .startTick ==
                                                        1
                                                        ? ""
                                                        : "s"}${a.completionData
                                                        .containsUnloadedChunks
                                                        ? "; Some blocks were not generated because they were in unloaded chunks. "
                                                        : ""}`
                                                );
                                            },
                                            (e) => {
                                                player.sendError(
                                                    "§c" + e + e.stack,
                                                    true
                                                );
                                            }
                                        );
                                    } catch (e) {
                                        player.sendError(
                                            "§c" + e + e.stack,
                                            true
                                        );
                                    }
                                });
                                break;
                            case "hollowsphere":
                                system.run(() => {
                                    try {
                                        fillBlocksHHSG(
                                            center,
                                            radius - 0.5,
                                            thickness,
                                            player.dimension,
                                            hsfirstblockname,
                                            hsfirstblockstates,
                                            {
                                                matchingBlock: hsmatchingblock[0],
                                                matchingBlockStates: hsmatchingblock[1],
                                                minMSBetweenYields: 5000,
                                            },
                                            undefined,
                                            hsreplacemode,
                                            100
                                        ).then(
                                            (a) => {
                                                player.sendMessageB(
                                                    `${a.counter == 0
                                                        ? "§c"
                                                        : ""}${a.counter} blocks filled in ${a.completionData
                                                        .endTime -
                                                    a.completionData
                                                        .startTime} ms over ${a.completionData
                                                        .endTick -
                                                    a.completionData
                                                        .startTick} tick${a.completionData
                                                        .endTick -
                                                        a.completionData
                                                            .startTick ==
                                                        1
                                                        ? ""
                                                        : "s"}${a.completionData
                                                        .containsUnloadedChunks
                                                        ? "; Some blocks were not generated because they were in unloaded chunks. "
                                                        : ""}`
                                                );
                                            },
                                            (e) => {
                                                player.sendError(
                                                    "§c" + e + e.stack,
                                                    true
                                                );
                                            }
                                        );
                                    } catch (e) {
                                        player.sendError(
                                            "§c" + e + e.stack,
                                            true
                                        );
                                    }
                                });
                                break;
                            case "dome":
                                system.run(() => {
                                    try {
                                        fillBlocksHDG(
                                            center,
                                            radius - 0.5,
                                            thickness,
                                            player.dimension,
                                            hsfirstblockname,
                                            hsfirstblockstates,
                                            {
                                                matchingBlock: hsmatchingblock[0],
                                                matchingBlockStates: hsmatchingblock[1],
                                                minMSBetweenYields: 5000,
                                            },
                                            undefined,
                                            hsreplacemode,
                                            100
                                        ).then(
                                            (a) => {
                                                player.sendMessageB(
                                                    `${a.counter == 0
                                                        ? "§c"
                                                        : ""}${a.counter} blocks filled in ${a.completionData
                                                        .endTime -
                                                    a.completionData
                                                        .startTime} ms over ${a.completionData
                                                        .endTick -
                                                    a.completionData
                                                        .startTick} tick${a.completionData
                                                        .endTick -
                                                        a.completionData
                                                            .startTick ==
                                                        1
                                                        ? ""
                                                        : "s"}${a.completionData
                                                        .containsUnloadedChunks
                                                        ? "; Some blocks were not generated because they were in unloaded chunks. "
                                                        : ""}`
                                                );
                                            },
                                            (e) => {
                                                player.sendError(
                                                    "§c" + e + e.stack,
                                                    true
                                                );
                                            }
                                        );
                                    } catch (e) {
                                        player.sendError(
                                            "§c" + e + e.stack,
                                            true
                                        );
                                    }
                                });
                                break;
                            case "sphere":
                                system.run(() => {
                                    try {
                                        fillBlocksHSG(
                                            center,
                                            radius - 0.5,
                                            player.dimension,
                                            ccfirstblockname,
                                            ccfirstblockstates,
                                            {
                                                matchingBlock: ccmatchingblock[0],
                                                matchingBlockStates: ccmatchingblock[1],
                                                minMSBetweenYields: 5000,
                                            },
                                            undefined,
                                            ccreplacemode,
                                            100
                                        ).then(
                                            (a) => {
                                                player.sendMessageB(
                                                    `${a.counter == 0
                                                        ? "§c"
                                                        : ""}${a.counter} blocks filled in ${a.completionData
                                                        .endTime -
                                                    a.completionData
                                                        .startTime} ms over ${a.completionData
                                                        .endTick -
                                                    a.completionData
                                                        .startTick} tick${a.completionData
                                                        .endTick -
                                                        a.completionData
                                                            .startTick ==
                                                        1
                                                        ? ""
                                                        : "s"}`
                                                );
                                            },
                                            (e) => {
                                                player.sendError(
                                                    "§c" + e + e.stack,
                                                    true
                                                );
                                            }
                                        );
                                    } catch (e) {
                                        player.sendError(
                                            "§c" + e + e.stack,
                                            true
                                        );
                                    }
                                });
                                break;
                            case "semisphere":
                                system.run(() => {
                                    try {
                                        fillBlocksHSSG(
                                            center,
                                            radius - 0.5,
                                            player.dimension,
                                            ccfirstblockname,
                                            ccfirstblockstates,
                                            {
                                                matchingBlock: ccmatchingblock[0],
                                                matchingBlockStates: ccmatchingblock[1],
                                                minMSBetweenYields: 5000,
                                            },
                                            undefined,
                                            ccreplacemode,
                                            100
                                        ).then(
                                            (a) => {
                                                player.sendMessageB(
                                                    `${a.counter == 0
                                                        ? "§c"
                                                        : ""}${a.counter} blocks filled in ${a.completionData
                                                        .endTime -
                                                    a.completionData
                                                        .startTime} ms over ${a.completionData
                                                        .endTick -
                                                    a.completionData
                                                        .startTick} tick${a.completionData
                                                        .endTick -
                                                        a.completionData
                                                            .startTick ==
                                                        1
                                                        ? ""
                                                        : "s"}`
                                                );
                                            },
                                            (e) => {
                                                player.sendError(
                                                    "§c" + e + e.stack,
                                                    true
                                                );
                                            }
                                        );
                                    } catch (e) {
                                        player.sendError(
                                            "§c" + e + e.stack,
                                            true
                                        );
                                    }
                                });
                                break;
                            case "circle":
                                system.run(() => {
                                    try {
                                        let startTime = Date.now();
                                        let a = fillBlocksHC(
                                            center,
                                            radius,
                                            player.dimension,
                                            axis,
                                            cfirstblockname,
                                            cfirstblockstates,
                                            {
                                                matchingBlock: cmatchingblock[0],
                                                matchingBlockStates: cmatchingblock[1],
                                            },
                                            undefined,
                                            creplacemode
                                        );
                                        let endTime = Date.now();
                                        player.sendMessageB(
                                            `${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`
                                        );
                                    } catch (e) {
                                        player.sendError(
                                            "§c" + e + e.stack,
                                            true
                                        );
                                    }
                                });
                                break;
                            case "circlex":
                                system.run(() => {
                                    try {
                                        let startTime = Date.now();
                                        let a = fillBlocksHC(
                                            center,
                                            radius,
                                            player.dimension,
                                            "x",
                                            ccfirstblockname,
                                            ccfirstblockstates,
                                            {
                                                matchingBlock: ccmatchingblock[0],
                                                matchingBlockStates: ccmatchingblock[1],
                                            },
                                            undefined,
                                            ccreplacemode
                                        );
                                        let endTime = Date.now();
                                        player.sendMessageB(
                                            `${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`
                                        );
                                    } catch (e) {
                                        player.sendError(
                                            "§c" + e + e.stack,
                                            true
                                        );
                                    }
                                });
                                break;
                            case "circley":
                                system.run(() => {
                                    try {
                                        let startTime = Date.now();
                                        let a = fillBlocksHC(
                                            center,
                                            radius,
                                            player.dimension,
                                            "y",
                                            ccfirstblockname,
                                            ccfirstblockstates,
                                            {
                                                matchingBlock: ccmatchingblock[0],
                                                matchingBlockStates: ccmatchingblock[1],
                                            },
                                            undefined,
                                            ccreplacemode
                                        );
                                        let endTime = Date.now();
                                        player.sendMessageB(
                                            `${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`
                                        );
                                    } catch (e) {
                                        player.sendError(
                                            "§c" + e + e.stack,
                                            true
                                        );
                                    }
                                });
                                break;
                            case "circlez":
                                system.run(() => {
                                    try {
                                        let startTime = Date.now();
                                        let a = fillBlocksHC(
                                            center,
                                            radius,
                                            player.dimension,
                                            "z",
                                            ccfirstblockname,
                                            ccfirstblockstates,
                                            {
                                                matchingBlock: ccmatchingblock[0],
                                                matchingBlockStates: ccmatchingblock[1],
                                            },
                                            undefined,
                                            ccreplacemode
                                        );
                                        let endTime = Date.now();
                                        player.sendMessageB(
                                            `${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`
                                        );
                                    } catch (e) {
                                        player.sendError(
                                            "§c" + e + e.stack,
                                            true
                                        );
                                    }
                                });
                                break;
                            case "circlexy":
                                system.run(() => {
                                    try {
                                        let startTime = Date.now();
                                        let a = fillBlocksHC(
                                            center,
                                            radius,
                                            player.dimension,
                                            "xy",
                                            ccfirstblockname,
                                            ccfirstblockstates,
                                            {
                                                matchingBlock: ccmatchingblock[0],
                                                matchingBlockStates: ccmatchingblock[1],
                                            },
                                            undefined,
                                            ccreplacemode
                                        );
                                        let endTime = Date.now();
                                        player.sendMessageB(
                                            `${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`
                                        );
                                    } catch (e) {
                                        player.sendError(
                                            "§c" + e + e.stack,
                                            true
                                        );
                                    }
                                });
                                break;
                            case "circleyz":
                                system.run(() => {
                                    try {
                                        let startTime = Date.now();
                                        let a = fillBlocksHC(
                                            center,
                                            radius,
                                            player.dimension,
                                            "yz",
                                            ccfirstblockname,
                                            ccfirstblockstates,
                                            {
                                                matchingBlock: ccmatchingblock[0],
                                                matchingBlockStates: ccmatchingblock[1],
                                            },
                                            undefined,
                                            ccreplacemode
                                        );
                                        let endTime = Date.now();
                                        player.sendMessageB(
                                            `${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`
                                        );
                                    } catch (e) {
                                        player.sendError(
                                            "§c" + e + e.stack,
                                            true
                                        );
                                    }
                                });
                                break;
                            case "circlexz":
                                system.run(() => {
                                    try {
                                        let startTime = Date.now();
                                        let a = fillBlocksHC(
                                            center,
                                            radius,
                                            player.dimension,
                                            "xz",
                                            ccfirstblockname,
                                            ccfirstblockstates,
                                            {
                                                matchingBlock: ccmatchingblock[0],
                                                matchingBlockStates: ccmatchingblock[1],
                                            },
                                            undefined,
                                            ccreplacemode
                                        );
                                        let endTime = Date.now();
                                        player.sendMessageB(
                                            `${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`
                                        );
                                    } catch (e) {
                                        player.sendError(
                                            "§c" + e + e.stack,
                                            true
                                        );
                                    }
                                });
                                break;
                            case "circlexyz":
                                system.run(() => {
                                    try {
                                        let startTime = Date.now();
                                        let a = fillBlocksHC(
                                            center,
                                            radius,
                                            player.dimension,
                                            "xyz",
                                            ccfirstblockname,
                                            ccfirstblockstates,
                                            {
                                                matchingBlock: ccmatchingblock[0],
                                                matchingBlockStates: ccmatchingblock[1],
                                            },
                                            undefined,
                                            ccreplacemode
                                        );
                                        let endTime = Date.now();
                                        player.sendMessageB(
                                            `${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`
                                        );
                                    } catch (e) {
                                        player.sendError(
                                            "§c" + e + e.stack,
                                            true
                                        );
                                    }
                                });
                                break;
                            case "cylinder":
                                system.run(() => {
                                    try {
                                        let startTime = Date.now();
                                        let a = fillBlocksHT(
                                            center,
                                            radius,
                                            thickness,
                                            taxis,
                                            player.dimension,
                                            tfirstblockname,
                                            tfirstblockstates,
                                            {
                                                matchingBlock: tmatchingblock[0],
                                                matchingBlockStates: tmatchingblock[1],
                                            },
                                            undefined,
                                            treplacemode
                                        );
                                        let endTime = Date.now();
                                        player.sendMessageB(
                                            `${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`
                                        );
                                    } catch (e) {
                                        player.sendError(
                                            "§c" + e + e.stack,
                                            true
                                        );
                                    }
                                });
                                break;
                            case "cylinderx":
                                system.run(() => {
                                    try {
                                        let startTime = Date.now();
                                        let a = fillBlocksHT(
                                            center,
                                            radius,
                                            thickness,
                                            "x",
                                            player.dimension,
                                            hsfirstblockname,
                                            hsfirstblockstates,
                                            {
                                                matchingBlock: hsmatchingblock[0],
                                                matchingBlockStates: hsmatchingblock[1],
                                            },
                                            undefined,
                                            hsreplacemode
                                        );
                                        let endTime = Date.now();
                                        player.sendMessageB(
                                            `${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`
                                        );
                                    } catch (e) {
                                        player.sendError(
                                            "§c" + e + e.stack,
                                            true
                                        );
                                    }
                                });
                                break;
                            case "cylindery":
                                system.run(() => {
                                    try {
                                        let startTime = Date.now();
                                        let a = fillBlocksHT(
                                            center,
                                            radius,
                                            thickness,
                                            "y",
                                            player.dimension,
                                            hsfirstblockname,
                                            hsfirstblockstates,
                                            {
                                                matchingBlock: hsmatchingblock[0],
                                                matchingBlockStates: hsmatchingblock[1],
                                            },
                                            undefined,
                                            hsreplacemode
                                        );
                                        let endTime = Date.now();
                                        player.sendMessageB(
                                            `${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`
                                        );
                                    } catch (e) {
                                        player.sendError(
                                            "§c" + e + e.stack,
                                            true
                                        );
                                    }
                                });
                                break;
                            case "cylinderz":
                                system.run(() => {
                                    try {
                                        let startTime = Date.now();
                                        let a = fillBlocksHT(
                                            center,
                                            radius,
                                            thickness,
                                            "z",
                                            player.dimension,
                                            hsfirstblockname,
                                            hsfirstblockstates,
                                            {
                                                matchingBlock: hsmatchingblock[0],
                                                matchingBlockStates: hsmatchingblock[1],
                                            },
                                            undefined,
                                            hsreplacemode
                                        );
                                        let endTime = Date.now();
                                        player.sendMessageB(
                                            `${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`
                                        );
                                    } catch (e) {
                                        player.sendError(
                                            "§c" + e + e.stack,
                                            true
                                        );
                                    }
                                });
                                break;
                            case "cylinderxy":
                                system.run(() => {
                                    try {
                                        let startTime = Date.now();
                                        let a = fillBlocksHT(
                                            center,
                                            radius,
                                            thickness,
                                            "x",
                                            player.dimension,
                                            hsfirstblockname,
                                            hsfirstblockstates,
                                            {
                                                matchingBlock: hsmatchingblock[0],
                                                matchingBlockStates: hsmatchingblock[1],
                                            },
                                            undefined,
                                            hsreplacemode
                                        );
                                        let endTime = Date.now();
                                        player.sendMessageB(
                                            `${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`
                                        );
                                    } catch (e) {
                                        player.sendError(
                                            "§c" + e + e.stack,
                                            true
                                        );
                                    }
                                });
                                break;
                            case "cylinderyz":
                                system.run(() => {
                                    try {
                                        let startTime = Date.now();
                                        let a = fillBlocksHT(
                                            center,
                                            radius,
                                            thickness,
                                            "y",
                                            player.dimension,
                                            hsfirstblockname,
                                            hsfirstblockstates,
                                            {
                                                matchingBlock: hsmatchingblock[0],
                                                matchingBlockStates: hsmatchingblock[1],
                                            },
                                            undefined,
                                            hsreplacemode
                                        );
                                        let endTime = Date.now();
                                        player.sendMessageB(
                                            `${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`
                                        );
                                    } catch (e) {
                                        player.sendError(
                                            "§c" + e + e.stack,
                                            true
                                        );
                                    }
                                });
                                break;
                            case "cylinderxz":
                                system.run(() => {
                                    try {
                                        let startTime = Date.now();
                                        let a = fillBlocksHT(
                                            center,
                                            radius,
                                            thickness,
                                            "z",
                                            player.dimension,
                                            hsfirstblockname,
                                            hsfirstblockstates,
                                            {
                                                matchingBlock: hsmatchingblock[0],
                                                matchingBlockStates: hsmatchingblock[1],
                                            },
                                            undefined,
                                            hsreplacemode
                                        );
                                        let endTime = Date.now();
                                        player.sendMessageB(
                                            `${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`
                                        );
                                    } catch (e) {
                                        player.sendError(
                                            "§c" + e + e.stack,
                                            true
                                        );
                                    }
                                });
                                break;
                            case "cylinderxyz":
                                system.run(() => {
                                    try {
                                        let startTime = Date.now();
                                        let a = fillBlocksHT(
                                            center,
                                            radius,
                                            thickness,
                                            "z",
                                            player.dimension,
                                            hsfirstblockname,
                                            hsfirstblockstates,
                                            {
                                                matchingBlock: hsmatchingblock[0],
                                                matchingBlockStates: hsmatchingblock[1],
                                            },
                                            undefined,
                                            hsreplacemode
                                        );
                                        let endTime = Date.now();
                                        player.sendMessageB(
                                            `${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`
                                        );
                                    } catch (e) {
                                        player.sendError(
                                            "§c" + e + e.stack,
                                            true
                                        );
                                    }
                                });
                                break;
                            case "hourglass":
                                player.sendMessageB("§eComing Soon! ");
                                break;
                            case "cube":
                                system.run(() => {
                                    try {
                                        let startTime = Date.now();
                                        if (replacemode) {
                                            clearAllContainerBlocks(
                                                scanForContainerBlocks(
                                                    coordinatesa,
                                                    coordinatesb,
                                                    player.dimension,
                                                    "Block"
                                                ) as Block[]
                                            );
                                        }
                                        let a = fillBlocksH(
                                            coordinatesa,
                                            coordinatesb,
                                            player.dimension,
                                            firstblockname,
                                            firstblockstates,
                                            {
                                                matchingBlock: matchingblock[0],
                                                matchingBlockStates: matchingblock[1],
                                            }
                                        );
                                        let endTime = Date.now();
                                        player.sendMessageB(
                                            `${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`
                                        );
                                    } catch (e) {
                                        player.sendError(
                                            "§c" + e + e.stack,
                                            true
                                        );
                                    }
                                });
                                break;
                            default:
                        }
                    }
                    //            try{system.run(()=>{player.dimension.fillBlocks(evaluateCoordinates(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[0][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[1][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[2][0], player.location, player.getRotation()), evaluateCoordinates(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[3][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[4][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0], player.location, player.getRotation()), BlockPermutation.resolve(switchTestB.split(" ").slice(1).join(" ").slice(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5].index+Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0].indexOf(" ")+1).split(" ")[0], extractJSONStrings(switchTestB.split(" ").slice(1).join(" ").slice(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5].index+Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0].indexOf(" ")).split(" ").slice(1).join(" "), false)[0]), {matchingBlock: BlockPermutation.resolve(getParametersFromString(switchTestB.split(" ").slice(1).join(" ").slice(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5].index+Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0].indexOf(" ")+1)).results[2], extractJSONStrings(switchTestB.split(" ").slice(1).join(" ").slice(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5].index+Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0].indexOf(" ")).split(" ").slice(1).join(" "), false)[1])}); }); }catch(e){player.sendError("§c" + e + e.stack, true)}
                }
                break;
            case !!switchTest.match(/^itfill$/):
                {
                    eventData.cancel = true;
                    eventData.cancel = true;
                    if (switchTestB.trim().split(" ").length == 1) {
                        player.sendMessageB(`itfill command format: 
${command.dp}itfill <from: x y z> <to: x y z> <tileName: Block> <blockStates: block states> <ifillMode: replace|fill|cube|keep|walls|hollow|outline|pillars§c|floor|ceilling|diamond|hourglass§r> <replaceTileName: Block> [replaceBlockStates: block states] [clearContainers: boolean]
${command.dp}itfill <from: x y z> <to: x y z> <tileName: Block> <blockStates: block states> <ifillMode: replace|fill|cube|keep|walls|hollow|outline|pillars§c|floor|ceilling|diamond|hourglass§r> <reaplceTileName: Block> [clearContainers: boolean]
${command.dp}itfill <from: x y z> <to: x y z> <tileName: Block> <blockStates: block states> [ifillMode: replace|fill|cube|keep|walls|hollow|outline|pillars§c|floor|ceilling|diamond|hourglass§r] [clearContainers: boolean]
${command.dp}itfill <from: x y z> <to: x y z> <tileName: Block> <blockStates: block states> [clearContainers: boolean]
${command.dp}itfill <from: x y z> <to: x y z> <tileName: Block> <ifillMode: replace|fill|cube|keep|walls|hollow|outline|pillars§c|floor|ceilling|diamond|hourglass§r> <replaceTileName: Block> [replaceBlockStates: block states] [clearContainers: boolean]
${command.dp}itfill <from: x y z> <to: x y z> <tileName: Block> <ifillMode: replace|fill|cube|keep|walls|hollow|outline|pillars§c|floor|ceilling|diamond|hourglass§r> <reaplceTileName: Block> [clearContainers: boolean]
${command.dp}itfill <from: x y z> <to: x y z> <tileName: Block> [ifillMode: replace|fill|cube|keep|walls|hollow|outline|pillars§c|floor|ceilling|diamond|hourglass§r] [clearContainers: boolean]
${command.dp}itfill <from: x y z> <to: x y z> <tileName: Block> [clearContainers: boolean]
${command.dp}itfill <from: x y z> <to: x y z> <skygridSize: float> <tileName: Block> <blockStates: block states> <mode: skygrid|inverseskygrid> <replaceTileName: Block> [replaceBlockStates: block states] [clearContainers: boolean]
${command.dp}itfill <from: x y z> <to: x y z> <skygridSize: float> <tileName: Block> <blockStates: block states> <mode: skygrid|inverseskygrid> <reaplceTileName: Block> [clearContainers: boolean]
${command.dp}itfill <from: x y z> <to: x y z> <skygridSize: float> <tileName: Block> <blockStates: block states> <mode: skygrid|inverseskygrid> [clearContainers: boolean]
${command.dp}itfill <from: x y z> <to: x y z> <skygridSize: float> <tileName: Block> <blockStates: block states> <mode: skygrid|inverseskygrid> [clearContainers: boolean]
${command.dp}itfill <from: x y z> <to: x y z> <skygridSize: float> <tileName: Block> <mode: skygrid|inverseskygrid> <replaceTileName: Block> [replaceBlockStates: block states] [clearContainers: boolean]
${command.dp}itfill <from: x y z> <to: x y z> <skygridSize: float> <tileName: Block> <mode: skygrid|inverseskygrid> <reaplceTileName: Block> [clearContainers: boolean]
${command.dp}itfill <from: x y z> <to: x y z> <skygridSize: float> <tileName: Block> <mode: skygrid|inverseskygrid> [clearContainers: boolean]
${command.dp}itfill <from: x y z> <to: x y z> <tileName: Block> [clearContainers: boolean]
${command.dp}itfill <from: x y z> <to: x y z> clear [clearContainers: boolean]
${command.dp}itfill <from: x y z> <to: x y z> drain
${command.dp}itfill <center: x y z> <radius: float> <axis: {x}|{y}|{z}|{xy}|{yz}|{xz}|{xyz}> <tileName: Block> <blockStates: block states> circle [replaceTileName: Block] [replaceBlockStates: block states] [clearContainers: boolean]
${command.dp}itfill <center: x y z> <radius: float> <axis: {x}|{y}|{z}|{xy}|{yz}|{xz}|{xyz}> <tileName: Block> <blockStates: block states> circle [replaceTileName: Block] [clearContainers: boolean]
${command.dp}itfill <center: x y z> <radius: float> <axis: {x}|{y}|{z}|{xy}|{yz}|{xz}|{xyz}> <tileName: Block> <blockStates: block states> circle [clearContainers: boolean]
${command.dp}itfill <center: x y z> <radius: float> <axis: {x}|{y}|{z}|{xy}|{yz}|{xz}|{xyz}> <tileName: Block> circle [replaceTileName: Block] [replaceBlockStates: block states] [clearContainers: boolean]
${command.dp}itfill <center: x y z> <radius: float> <axis: {x}|{y}|{z}|{xy}|{yz}|{xz}|{xyz}> <tileName: Block> circle [replaceTileName: Block] [clearContainers: boolean]
${command.dp}itfill <center: x y z> <radius: float> <axis: {x}|{y}|{z}|{xy}|{yz}|{xz}|{xyz}> <tileName: Block> circle [clearContainers: boolean]
${command.dp}itfill <center: x y z> <radius: float> <tileName: Block> <blockStates: block states> <mode: {circlex}|{circley}|{circlez}|{circlexy}|{circleyz}|{circlexyz}|{sphere}|{semisphere}> <replaceTileName: Block> [replaceBlockStates: block states] [clearContainers: boolean]
${command.dp}itfill <center: x y z> <radius: float> <tileName: Block> <blockStates: block states> <mode: {circlex}|{circley}|{circlez}|{circlexy}|{circleyz}|{circlexyz}|{sphere}|{semisphere}> <replaceTileName: Block> [clearContainers: boolean]
${command.dp}itfill <center: x y z> <radius: float> <tileName: Block> <blockStates: block states> <mode: {circlex}|{circley}|{circlez}|{circlexy}|{circleyz}|{circlexyz}|{sphere}|{semisphere}> [clearContainers: boolean]
${command.dp}itfill <center: x y z> <radius: float> <tileName: Block> <mode: {circlex}|{circley}|{circlez}|{circlexy}|{circleyz}|{circlexyz}|{sphere}|{semisphere}> <replaceTileName: Block> [replaceBlockStates: block states] [clearContainers: boolean]
${command.dp}itfill <center: x y z> <radius: float> <tileName: Block> <mode: {circlex}|{circley}|{circlez}|{circlexy}|{circleyz}|{circlexyz}|{sphere}|{semisphere}> <replaceTileName: Block> [clearContainers: boolean]
${command.dp}itfill <center: x y z> <radius: float> <tileName: Block> <mode: {circlex}|{circley}|{circlez}|{circlexy}|{circleyz}|{circlexyz}|{sphere}|{semisphere}> [clearContainers: boolean]
${command.dp}itfill <center: x y z> <radius: float> <thickness: float> <tileName: Block> <blockStates: block states> <mode: hollowsphere|dome> <replaceTileName: Block> [replaceBlockStates: block states] [clearContainers: boolean]
${command.dp}itfill <center: x y z> <radius: float> <thickness: float> <tileName: Block> <blockStates: block states> <mode: hollowsphere|dome> <replaceTileName: Block> [clearContainers: boolean]
${command.dp}itfill <center: x y z> <radius: float> <thickness: float> <tileName: Block> <blockStates: block states> <mode: hollowsphere|dome> [clearContainers: boolean]
${command.dp}itfill <center: x y z> <radius: float> <thickness: float> <tileName: Block> <mode: hollowsphere|dome> <replaceTileName: Block> [replaceBlockStates: block states] [clearContainers: boolean]
${command.dp}itfill <center: x y z> <radius: float> <thickness: float> <tileName: Block> <mode: hollowsphere|dome> <replaceTileName: Block> [clearContainers: boolean]
${command.dp}itfill <center: x y z> <radius: float> <thickness: float> <tileName: Block> <mode: hollowsphere|dome> [clearContainers: boolean]
${command.dp}itfill <center: x y z> <radius: float> <length: float> <tileName: Block> <blockStates: block states> <mode: cylinderx|cylindery|cylinderz|cylinderxy|cylinderyz|cylinderxz|cylinderxyz> <replaceTileName: Block> [replaceBlockStates: block states] [clearContainers: boolean]
${command.dp}itfill <center: x y z> <radius: float> <length: float> <tileName: Block> <blockStates: block states> <mode: cylinderx|cylindery|cylinderz|cylinderxy|cylinderyz|cylinderxz|cylinderxyz> <replaceTileName: Block> [clearContainers: boolean]
${command.dp}itfill <center: x y z> <radius: float> <length: float> <tileName: Block> <blockStates: block states> <mode: cylinderx|cylindery|cylinderz|cylinderxy|cylinderyz|cylinderxz|cylinderxyz> [clearContainers: boolean]
${command.dp}itfill <center: x y z> <radius: float> <length: float> <tileName: Block> <mode: cylinderx|cylindery|cylinderz|cylinderxy|cylinderyz|cylinderxz|cylinderxyz> <replaceTileName: Block> [replaceBlockStates: block states] [clearContainers: boolean]
${command.dp}itfill <center: x y z> <radius: float> <length: float> <tileName: Block> <mode: cylinderx|cylindery|cylinderz|cylinderxy|cylinderyz|cylinderxz|cylinderxyz> <replaceTileName: Block> [clearContainers: boolean]
${command.dp}itfill <center: x y z> <radius: float> <length: float> <tileName: Block> <mode: cylinderx|cylindery|cylinderz|cylinderxy|cylinderyz|cylinderxz|cylinderxyz> [clearContainers: boolean]
${command.dp}itfill <center: x y z> <radius: float> <length: float> <axis: {x}|{y}|{z}|{xy}|{yz}|{xz}|{xyz}> <tileName: Block> <blockStates: block states> <mode: tunnel|cylinder> [replaceTileName: Block] [replaceBlockStates: block states] [clearContainers: boolean]
${command.dp}itfill <center: x y z> <radius: float> <length: float> <axis: {x}|{y}|{z}|{xy}|{yz}|{xz}|{xyz}> <tileName: Block> <blockStates: block states> <mode: tunnel|cylinder> [replaceTileName: Block] [clearContainers: boolean]
${command.dp}itfill <center: x y z> <radius: float> <length: float> <axis: {x}|{y}|{z}|{xy}|{yz}|{xz}|{xyz}> <tileName: Block> <blockStates: block states> <mode: tunnel|cylinder> [clearContainers: boolean]
${command.dp}itfill <center: x y z> <radius: float> <length: float> <axis: {x}|{y}|{z}|{xy}|{yz}|{xz}|{xyz}> <tileName: Block> <mode: tunnel|cylinder> [replaceTileName: Block] [replaceBlockStates: block states] [clearContainers: boolean]
${command.dp}itfill <center: x y z> <radius: float> <length: float> <axis: {x}|{y}|{z}|{xy}|{yz}|{xz}|{xyz}> <tileName: Block> <mode: tunnel|cylinder> [replaceTileName: Block] [clearContainers: boolean]
${command.dp}itfill <center: x y z> <radius: float> <length: float> <axis: {x}|{y}|{z}|{xy}|{yz}|{xz}|{xyz}> <tileName: Block> <mode: tunnel|cylinder> [clearContainers: boolean]
${command.dp}itfill <center: x y z> <radius: x y z> <offset: x y z> <length: float> <tileName: Block> <blockStates: block states> hollowovoid [replaceTileName: Block] [replaceBlockStates: block states] [clearContainers: boolean]
${command.dp}itfill <center: x y z> <radius: x y z> <offset: x y z> <length: float> <tileName: Block> <blockStates: block states> hollowovoid [replaceTileName: Block] [clearContainers: boolean]
${command.dp}itfill <center: x y z> <radius: x y z> <offset: x y z> <length: float> <tileName: Block> <blockStates: block states> hollowovoid [clearContainers: boolean]
${command.dp}itfill <center: x y z> <radius: x y z> <offset: x y z> <length: float> <tileName: Block> hollowovoid [replaceTileName: Block] [replaceBlockStates: block states] [clearContainers: boolean]
${command.dp}itfill <center: x y z> <radius: x y z> <offset: x y z> <length: float> <tileName: Block> hollowovoid [replaceTileName: Block] [clearContainers: boolean]
${command.dp}itfill <center: x y z> <radius: x y z> <offset: x y z> <length: float> <tileName: Block> hollowovoid [clearContainers: boolean]`);
                    } else {
                        let argsa = evaluateParameters(switchTestB, [
                            "presetText",
                            "Vector",
                            "Vector",
                            "Vector",
                            "Vector",
                            "Vector",
                            "Vector",
                            "string",
                            "blockStates",
                            "presetText",
                            "non-booleanString",
                            "blockStates",
                            "neboolean",
                        ]);
                        let argsb = evaluateParameters(switchTestB, [
                            "presetText",
                            "Vector",
                            "Vector",
                            "Vector",
                            "number",
                            "string",
                            "presetText",
                            "blockStates",
                            "presetText",
                            "non-booleanString",
                            "blockStates",
                            "neboolean",
                        ]);
                        let argsd = evaluateParameters(switchTestB, [
                            "presetText",
                            "Vector",
                            "Vector",
                            "Vector",
                            "number",
                            "string",
                            "blockStates",
                            "presetText",
                            "non-booleanString",
                            "blockStates",
                            "neboolean",
                        ]);
                        let argsf = evaluateParameters(switchTestB, [
                            "presetText",
                            "Vector",
                            "Vector",
                            "Vector",
                            "number",
                            "number",
                            "string",
                            "blockStates",
                            "presetText",
                            "non-booleanString",
                            "blockStates",
                            "neboolean",
                        ]);
                        let argsh = evaluateParameters(switchTestB, [
                            "presetText",
                            "Vector",
                            "Vector",
                            "Vector",
                            "number",
                            "number",
                            "string",
                            "string",
                            "blockStates",
                            "presetText",
                            "non-booleanString",
                            "blockStates",
                            "neboolean",
                        ]);
                        let argsj = evaluateParameters(switchTestB, [
                            "presetText",
                            "Vector",
                            "Vector",
                            "Vector",
                            "Vector",
                            "Vector",
                            "Vector",
                            "Vector",
                            "Vector",
                            "Vector",
                            "number",
                            "string",
                            "blockStates",
                            "presetText",
                            "non-booleanString",
                            "blockStates",
                            "neboolean",
                        ]);
                        let argsl = evaluateParameters(switchTestB, [
                            "presetText",
                            "Vector",
                            "Vector",
                            "Vector",
                            "Vector",
                            "Vector",
                            "Vector",
                            "Vector",
                            "Vector",
                            "Vector",
                            "string",
                            "blockStates",
                            "presetText",
                            "non-booleanString",
                            "blockStates",
                            "neboolean",
                        ]);
                        let argsn = evaluateParameters(switchTestB, [
                            "presetText",
                            "Vector",
                            "Vector",
                            "Vector",
                            "Vector",
                            "Vector",
                            "Vector",
                            "number",
                            "string",
                            "blockStates",
                            "presetText",
                            "non-booleanString",
                            "blockStates",
                            "neboolean",
                        ]);
                        //console.warn(argsh.args)
                        let args = argsa.args;
                        let argsc = argsb.args;
                        let argse = argsd.args;
                        let argsg = argsf.args;
                        let argsi = argsh.args;
                        let argsk = argsj.args;
                        let argsm = argsl.args;
                        let argso = argsn.args;
                        let argsaextra = argsa.extra;
                        let argsbextra = argsb.extra;
                        let argsdextra = argsd.extra;
                        let argsfextra = argsf.extra;
                        let argshextra = argsh.extra;
                        let argsjextra = argsj.extra;
                        let argslextra = argsl.extra;
                        let argsnextra = argsn.extra;
                        //console.warn(JSONStringify(args), JSONStringify(argsaextra))
                        let center = evaluateCoordinates(
                            argsc[1],
                            argsc[2],
                            argsc[3],
                            roundVector3ToMiddleOfBlock(player.location),
                            player.getRotation()
                        );
                        let radius = argsc[4];
                        let axis = argsc[5];
                        let cfirstblockname = argsc[6];
                        let cfirstblockstates = argsc[7];
                        let cmode = argsc[8] as string;
                        let clastblockname = argsc[9];
                        let clastblockstates = argsc[10];
                        let creplacemode = argsc[11] ?? false;
                        let ccfirstblockname = argse[5];
                        let ccfirstblockstates = argse[6];
                        let ccmode = argse[7] as string;
                        let cclastblockname = argse[8];
                        let cclastblockstates = argse[9];
                        let ccreplacemode = argse[10] ?? false;
                        let thickness = argsg[5];
                        let hsfirstblockname = argsg[6];
                        let hsfirstblockstates = argsg[7];
                        let hsmode = argsg[8] as string;
                        let hslastblockname = argsg[9];
                        let hslastblockstates = argsg[10];
                        let hsreplacemode = argsg[11] ?? false;
                        let taxis = argsi[6];
                        let tfirstblockname = argsi[7];
                        let tfirstblockstates = argsi[8];
                        let tmode = argsi[9] as string;
                        let tlastblockname = argsi[10];
                        let tlastblockstates = argsi[11];
                        let treplacemode = argsi[12] ?? false;
                        let sgskygridsize = argso[7];
                        let sgfirstblockname = argso[8];
                        let sgfirstblockstates = argso[9];
                        let sgmode = argso[10] as string;
                        let sglastblockname = argso[11];
                        let sglastblockstates = argso[12];
                        let sgreplacemode = argso[13] ?? false;
                        let circlemode = false;
                        new Date(Date.now()).getMilliseconds();
                        let ccirclemode = false;
                        let hspheremode = false;
                        let tunnelmode = false;
                        let ovoidmode = false;
                        let hovoidmode = false;
                        let skygridmode = false;
                        if (["circle"].includes(
                            fillmodetypeenum[argsc[8] ??
                            "undefined"?.toLowerCase()?.trim()]
                        )) {
                            circlemode = true;
                        }
                        if ([
                            "circlex",
                            "circley",
                            "circlez",
                            "circlexy",
                            "circleyz",
                            "circlexz",
                            "circlexyz",
                            "sphere",
                            "semisphere",
                        ].includes(
                            fillmodetypeenum[argse[7] ??
                            "undefined"?.toLowerCase()?.trim()]
                        )) {
                            ccirclemode = true;
                        }
                        if ([
                            "hollowsphere",
                            "cylinderx",
                            "cylindery",
                            "cylinderz",
                            "cylinderxy",
                            "cylinderyz",
                            "cylinderxz",
                            "cylinderxyz",
                            "dome",
                        ].includes(
                            fillmodetypeenum[argsg[8] ??
                            "undefined"?.toLowerCase()?.trim()]
                        )) {
                            hspheremode = true;
                        }
                        if (["tunnel", "cylinder"].includes(
                            fillmodetypeenum[argsi[9] ??
                            "undefined"?.toLowerCase()?.trim()]
                        )) {
                            tunnelmode = true;
                        }
                        if (["ovoid"].includes(
                            fillmodetypeenum[argsm[12] ??
                            "undefined"?.toLowerCase()?.trim()]
                        )) {
                            ovoidmode = true;
                        }
                        if (["hollowovoid"].includes(
                            fillmodetypeenum[argsk[13] ??
                            "undefined"?.toLowerCase()?.trim()]
                        )) {
                            hovoidmode = true;
                        }
                        if (["skygrid", "inverseskygrid"].includes(
                            fillmodetypeenum[argso[10] ??
                            "undefined"?.toLowerCase()?.trim()]
                        )) {
                            skygridmode = true;
                        }
                        let coordinatesa: Vector3; /*
            console.warn(circlemode, ccirclemode, hspheremode)*/

                        if (!circlemode &&
                            !ccirclemode &&
                            !hspheremode &&
                            !tunnelmode) {
                            coordinatesa = evaluateCoordinates(
                                args[1],
                                args[2],
                                args[3],
                                roundVector3ToMiddleOfBlock(player.location),
                                player.getRotation()
                            );
                        }
                        let coordinatesb: Vector3;
                        if (!circlemode &&
                            !ccirclemode &&
                            !hspheremode &&
                            !tunnelmode) {
                            coordinatesb = evaluateCoordinates(
                                args[4],
                                args[5],
                                args[6],
                                roundVector3ToMiddleOfBlock(player.location),
                                player.getRotation()
                            );
                        }
                        let horadi: Vector3;
                        let hooffset: Vector3;
                        let hothickness = argsk[10];
                        let hofirstblockname = argsk[11];
                        let hofirstblockstates = argsk[12];
                        let homode = argsk[13] as string;
                        let holastblockname = argsk[14];
                        let holastblockstates = argsk[15];
                        let horeplacemode = argsk[16] ?? false;
                        if (hovoidmode) {
                            horadi = evaluateCoordinates(
                                argsk[4],
                                argsk[5],
                                argsk[6],
                                roundVector3ToMiddleOfBlock(player.location),
                                player.getRotation()
                            );
                            hooffset = evaluateCoordinates(
                                argsk[7],
                                argsk[8],
                                argsk[9],
                                roundVector3ToMiddleOfBlock(player.location),
                                player.getRotation()
                            );
                        }
                        let oradi: Vector3;
                        let ooffset: Vector3;
                        let ofirstblockname = argsm[10];
                        let ofirstblockstates = argsm[11];
                        let omode = argsm[12] as string;
                        let olastblockname = argsm[13];
                        let olastblockstates = argsm[14];
                        let oreplacemode = argsm[15] ?? false;
                        if (ovoidmode) {
                            oradi = evaluateCoordinates(
                                argsm[4],
                                argsm[5],
                                argsm[6],
                                roundVector3ToMiddleOfBlock(player.location),
                                player.getRotation()
                            );
                            ooffset = evaluateCoordinates(
                                argsm[7],
                                argsm[8],
                                argsm[9],
                                roundVector3ToMiddleOfBlock(player.location),
                                player.getRotation()
                            );
                        }
                        let firstblockname = args[7];
                        let firstblockstates = args[8];
                        let mode = args[9] as string;
                        let lastblockname = args[10];
                        let lastblockstates = args[11];
                        let replacemode = args[12] ?? false;
                        let matchingblock = (
                            (lastblockname ?? "") == ""
                                ? [undefined, undefined]
                                : lastblockname == "keep" || mode == "keep"
                                    ? ["air"]
                                    : [
                                        BlockTypes.get(lastblockname).id,
                                        lastblockstates,
                                    ]
                        ) as [
                                string,
                                { [id: string]: string | number | boolean; }
                            ];
                        let cmatchingblock = (
                            (clastblockname ?? "") == ""
                                ? [undefined, undefined]
                                : clastblockname == "keep"
                                    ? ["air"]
                                    : [clastblockname, clastblockstates]
                        ) as [
                                string,
                                { [id: string]: string | number | boolean; }
                            ];
                        let ccmatchingblock = (
                            (cclastblockname ?? "") == ""
                                ? [undefined, undefined]
                                : cclastblockname == "keep"
                                    ? ["air"]
                                    : [cclastblockname, cclastblockstates]
                        ) as [
                                string,
                                { [id: string]: string | number | boolean; }
                            ];
                        let hsmatchingblock = (
                            (hslastblockname ?? "") == ""
                                ? [undefined, undefined]
                                : hslastblockname == "keep"
                                    ? ["air"]
                                    : [hslastblockname, hslastblockstates]
                        ) as [
                                string,
                                { [id: string]: string | number | boolean; }
                            ];
                        let tmatchingblock = (
                            (tlastblockname ?? "") == ""
                                ? [undefined, undefined]
                                : tlastblockname == "keep"
                                    ? ["air"]
                                    : [tlastblockname, tlastblockstates]
                        ) as [
                                string,
                                { [id: string]: string | number | boolean; }
                            ];
                        let omatchingblock = (
                            (olastblockname ?? "") == ""
                                ? [undefined, undefined]
                                : olastblockname == "keep"
                                    ? ["air"]
                                    : [olastblockname, olastblockstates]
                        ) as [
                                string,
                                { [id: string]: string | number | boolean; }
                            ];
                        let homatchingblock = (
                            (holastblockname ?? "") == ""
                                ? [undefined, undefined]
                                : holastblockname == "keep"
                                    ? ["air"]
                                    : [holastblockname, holastblockstates]
                        ) as [
                                string,
                                { [id: string]: string | number | boolean; }
                            ];
                        let sgmatchingblock = (
                            (sglastblockname ?? "") == ""
                                ? [undefined, undefined]
                                : sglastblockname == "keep"
                                    ? ["air"]
                                    : [sglastblockname, sglastblockstates]
                        ) as [
                                string,
                                { [id: string]: string | number | boolean; }
                            ]; /*
            console.warn(JSONStringify({coordinatesa, coordinatesb, firstblockname, firstblocknameindex, reststringaftercoordinates, firstblockstates, lastblockname, somethingtest, lastblockstates, matchingblock}))*/

                        switch (fillmodetypeenum[skygridmode
                            ? sgmode
                            : hovoidmode
                                ? homode
                                : ovoidmode
                                    ? omode
                                    : tunnelmode
                                        ? tmode
                                        : hspheremode
                                            ? hsmode
                                            : circlemode
                                                ? cmode
                                                : ccirclemode
                                                    ? ccmode
                                                    : mode ?? ""]) {
                            case "":
                                system.run(() => {
                                    let ta: Entity;
                                    try {
                                        let location = {
                                            x: (coordinatesa.x +
                                                coordinatesb.x) /
                                                2,
                                            y: (coordinatesa.y +
                                                coordinatesb.y) /
                                                2,
                                            z: (coordinatesa.z +
                                                coordinatesb.z) /
                                                2,
                                        };
                                        player.dimension.runCommand(
                                            "summon andexdb:tickingarea_6 itwalls " +
                                            vTStr(location)
                                        );
                                        ta = player.dimension
                                            .getEntitiesAtBlockLocation(
                                                location
                                            )
                                            .find(
                                                (v) => v.typeId ==
                                                    "andexdb:tickingarea_6"
                                            );
                                        system.runTimeout(() => {
                                            try {
                                                let startTime = Date.now();
                                                if (replacemode) {
                                                    clearAllContainerBlocks(
                                                        scanForContainerBlocks(
                                                            coordinatesa,
                                                            coordinatesb,
                                                            player.dimension,
                                                            "Block"
                                                        ) as Block[]
                                                    );
                                                }
                                                let a = fillBlocksH(
                                                    coordinatesa,
                                                    coordinatesb,
                                                    player.dimension,
                                                    firstblockname,
                                                    firstblockstates,
                                                    {
                                                        matchingBlock: matchingblock[0],
                                                        matchingBlockStates: matchingblock[1],
                                                    }
                                                );
                                                let endTime = Date.now();
                                                player.sendMessageB(
                                                    `${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`
                                                );
                                            } catch (e) {
                                                player.sendError(
                                                    "§c" + e + e.stack,
                                                    true
                                                );
                                            } finally {
                                                ta?.remove();
                                            }
                                        }, 2);
                                    } catch (e) {
                                        player.sendError(
                                            "§c" + e + e.stack,
                                            true
                                        );
                                    }
                                });
                                break;
                            case "replace":
                                system.run(() => {
                                    let ta: Entity;
                                    try {
                                        let location = {
                                            x: (coordinatesa.x +
                                                coordinatesb.x) /
                                                2,
                                            y: (coordinatesa.y +
                                                coordinatesb.y) /
                                                2,
                                            z: (coordinatesa.z +
                                                coordinatesb.z) /
                                                2,
                                        };
                                        player.dimension.runCommand(
                                            "summon andexdb:tickingarea_6 itwalls " +
                                            vTStr(location)
                                        );
                                        ta = player.dimension
                                            .getEntitiesAtBlockLocation(
                                                location
                                            )
                                            .find(
                                                (v) => v.typeId ==
                                                    "andexdb:tickingarea_6"
                                            );
                                        system.runTimeout(() => {
                                            try {
                                                let startTime = Date.now();
                                                if (replacemode) {
                                                    clearAllContainerBlocks(
                                                        scanForContainerBlocks(
                                                            coordinatesa,
                                                            coordinatesb,
                                                            player.dimension,
                                                            "Block"
                                                        ) as Block[]
                                                    );
                                                }
                                                let a = fillBlocksH(
                                                    coordinatesa,
                                                    coordinatesb,
                                                    player.dimension,
                                                    firstblockname,
                                                    firstblockstates,
                                                    {
                                                        matchingBlock: matchingblock[0],
                                                        matchingBlockStates: matchingblock[1],
                                                    }
                                                );
                                                let endTime = Date.now();
                                                player.sendMessageB(
                                                    `${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`
                                                );
                                            } catch (e) {
                                                player.sendError(
                                                    "§c" + e + e.stack,
                                                    true
                                                );
                                            } finally {
                                                ta?.remove();
                                            }
                                        }, 2);
                                    } catch (e) {
                                        player.sendError(
                                            "§c" + e + e.stack,
                                            true
                                        );
                                    }
                                });
                                break;
                            case "clear":
                                system.run(() => {
                                    let ta: Entity[];
                                    try {
                                        generateTickingAreaFillCoordinatesC(
                                            player.location,
                                            (() => {
                                                let a = new CompoundBlockVolume();
                                                a.pushVolume({
                                                    volume: new BlockVolume(
                                                        coordinatesa,
                                                        coordinatesb
                                                    ),
                                                });
                                                return a;
                                            })(),
                                            player.dimension
                                        ).then((tac) => {
                                            ta = tac;
                                            try {
                                                let startTime = Date.now();
                                                if (replacemode) {
                                                    clearAllContainerBlocks(
                                                        scanForContainerBlocks(
                                                            coordinatesa,
                                                            coordinatesb,
                                                            player.dimension,
                                                            "Block"
                                                        ) as Block[]
                                                    );
                                                }
                                                let a = fillBlocksH(
                                                    coordinatesa,
                                                    coordinatesb,
                                                    player.dimension,
                                                    "air"
                                                );
                                                let endTime = Date.now();
                                                player.sendMessageB(
                                                    `${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`
                                                );
                                            } catch (e) {
                                                player.sendError(
                                                    "§c" + e + e.stack,
                                                    true
                                                );
                                            } finally {
                                                tac.forEach((tab) => tab?.remove()
                                                );
                                            }
                                        });
                                    } catch (e) {
                                        player.sendError(
                                            "§c" + e + e.stack,
                                            true
                                        );
                                    }
                                });
                                break;
                            case "drain":
                                system.run(() => {
                                    let ta: Entity[];
                                    try {
                                        generateTickingAreaFillCoordinatesC(
                                            player.location,
                                            (() => {
                                                let a = new CompoundBlockVolume();
                                                a.pushVolume({
                                                    volume: new BlockVolume(
                                                        coordinatesa,
                                                        coordinatesb
                                                    ),
                                                });
                                                return a;
                                            })(),
                                            player.dimension
                                        ).then((tac) => {
                                            ta = tac;
                                            try {
                                                let startTime = Date.now();
                                                let a = fillBlocksH(
                                                    coordinatesa,
                                                    coordinatesb,
                                                    player.dimension,
                                                    "air",
                                                    undefined,
                                                    { matchingBlock: "water" }
                                                );
                                                let endTime = Date.now();
                                                player.sendMessageB(
                                                    `${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`
                                                );
                                            } catch (e) {
                                                player.sendError(
                                                    "§c" + e + e.stack,
                                                    true
                                                );
                                            } finally {
                                                tac.forEach((tab) => tab?.remove()
                                                );
                                            }
                                        });
                                    } catch (e) {
                                        player.sendError(
                                            "§c" + e + e.stack,
                                            true
                                        );
                                    }
                                });
                                break;
                            case "fill":
                                system.run(() => {
                                    let ta: Entity[];
                                    try {
                                        generateTickingAreaFillCoordinatesC(
                                            player.location,
                                            (() => {
                                                let a = new CompoundBlockVolume();
                                                a.pushVolume({
                                                    volume: new BlockVolume(
                                                        coordinatesa,
                                                        coordinatesb
                                                    ),
                                                });
                                                return a;
                                            })(),
                                            player.dimension
                                        ).then((tac) => {
                                            ta = tac;
                                            try {
                                                let startTime = Date.now();
                                                if (replacemode) {
                                                    clearAllContainerBlocks(
                                                        scanForContainerBlocks(
                                                            coordinatesa,
                                                            coordinatesb,
                                                            player.dimension,
                                                            "Block"
                                                        ) as Block[]
                                                    );
                                                }
                                                let a = fillBlocksH(
                                                    coordinatesa,
                                                    coordinatesb,
                                                    player.dimension,
                                                    firstblockname,
                                                    firstblockstates,
                                                    {
                                                        matchingBlock: matchingblock[0],
                                                        matchingBlockStates: matchingblock[1],
                                                    }
                                                );
                                                let endTime = Date.now();
                                                player.sendMessageB(
                                                    `${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`
                                                );
                                            } catch (e) {
                                                player.sendError(
                                                    "§c" + e + e.stack,
                                                    true
                                                );
                                            } finally {
                                                tac.forEach((tab) => tab?.remove()
                                                );
                                            }
                                        });
                                    } catch (e) {
                                        player.sendError(
                                            "§c" + e + e.stack,
                                            true
                                        );
                                    }
                                });
                                break;
                            case "keep":
                                system.run(() => {
                                    let ta: Entity[];
                                    try {
                                        generateTickingAreaFillCoordinatesC(
                                            player.location,
                                            (() => {
                                                let a = new CompoundBlockVolume();
                                                a.pushVolume({
                                                    volume: new BlockVolume(
                                                        coordinatesa,
                                                        coordinatesb
                                                    ),
                                                });
                                                return a;
                                            })(),
                                            player.dimension
                                        ).then((tac) => {
                                            ta = tac;
                                            try {
                                                let startTime = Date.now();
                                                let a = fillBlocksH(
                                                    coordinatesa,
                                                    coordinatesb,
                                                    player.dimension,
                                                    firstblockname,
                                                    firstblockstates,
                                                    { matchingBlock: "air" }
                                                );
                                                let endTime = Date.now();
                                                player.sendMessageB(
                                                    `${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`
                                                );
                                            } catch (e) {
                                                player.sendError(
                                                    "§c" + e + e.stack,
                                                    true
                                                );
                                            } finally {
                                                tac.forEach((tab) => tab?.remove()
                                                );
                                            }
                                        });
                                    } catch (e) {
                                        player.sendError(
                                            "§c" + e + e.stack,
                                            true
                                        );
                                    }
                                });
                                break;
                            case "walls":
                                system.run(() => {
                                    let ta: Entity[];
                                    try {
                                        generateTickingAreaFillCoordinatesC(
                                            player.location,
                                            (() => {
                                                let a = new CompoundBlockVolume();
                                                a.pushVolume({
                                                    volume: new BlockVolume(
                                                        coordinatesa,
                                                        coordinatesb
                                                    ),
                                                });
                                                return a;
                                            })(),
                                            player.dimension
                                        ).then((tac) => {
                                            ta = tac;
                                            try {
                                                let startTime = Date.now();
                                                let a = fillBlocksHW(
                                                    coordinatesa,
                                                    coordinatesb,
                                                    player.dimension,
                                                    firstblockname,
                                                    firstblockstates,
                                                    {
                                                        matchingBlock: matchingblock[0],
                                                        matchingBlockStates: matchingblock[1],
                                                    },
                                                    undefined,
                                                    replacemode
                                                );
                                                let endTime = Date.now();
                                                player.sendMessageB(
                                                    `${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`
                                                );
                                            } catch (e) {
                                                player.sendError(
                                                    "§c" + e + e.stack,
                                                    true
                                                );
                                            } finally {
                                                tac.forEach((tab) => tab?.remove()
                                                );
                                            }
                                        });
                                    } catch (e) {
                                        player.sendError(
                                            "§c" + e + e.stack,
                                            true
                                        );
                                    }
                                });
                                break;
                            case "hollow":
                                system.run(() => {
                                    let ta: Entity[];
                                    try {
                                        generateTickingAreaFillCoordinatesC(
                                            player.location,
                                            (() => {
                                                let a = new CompoundBlockVolume();
                                                a.pushVolume({
                                                    volume: new BlockVolume(
                                                        coordinatesa,
                                                        coordinatesb
                                                    ),
                                                });
                                                return a;
                                            })(),
                                            player.dimension
                                        ).then((tac) => {
                                            ta = tac;
                                            try {
                                                let startTime = Date.now();
                                                let a = fillBlocksHH(
                                                    coordinatesa,
                                                    coordinatesb,
                                                    player.dimension,
                                                    firstblockname,
                                                    firstblockstates,
                                                    {
                                                        matchingBlock: matchingblock[0],
                                                        matchingBlockStates: matchingblock[1],
                                                    },
                                                    undefined,
                                                    replacemode
                                                );
                                                let endTime = Date.now();
                                                player.sendMessageB(
                                                    `${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`
                                                );
                                            } catch (e) {
                                                player.sendError(
                                                    "§c" + e + e.stack,
                                                    true
                                                );
                                            } finally {
                                                tac.forEach((tab) => tab?.remove()
                                                );
                                            }
                                        });
                                    } catch (e) {
                                        player.sendError(
                                            "§c" + e + e.stack,
                                            true
                                        );
                                    }
                                });
                                break;
                            case "outline":
                                system.run(() => {
                                    let ta: Entity[];
                                    try {
                                        generateTickingAreaFillCoordinatesC(
                                            player.location,
                                            (() => {
                                                let a = new CompoundBlockVolume();
                                                a.pushVolume({
                                                    volume: new BlockVolume(
                                                        coordinatesa,
                                                        coordinatesb
                                                    ),
                                                });
                                                return a;
                                            })(),
                                            player.dimension
                                        ).then((tac) => {
                                            ta = tac;
                                            try {
                                                let startTime = Date.now();
                                                let a = fillBlocksHO(
                                                    coordinatesa,
                                                    coordinatesb,
                                                    player.dimension,
                                                    firstblockname,
                                                    firstblockstates,
                                                    {
                                                        matchingBlock: matchingblock[0],
                                                        matchingBlockStates: matchingblock[1],
                                                    },
                                                    undefined,
                                                    replacemode
                                                );
                                                let endTime = Date.now();
                                                player.sendMessageB(
                                                    `${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`
                                                );
                                            } catch (e) {
                                                player.sendError(
                                                    "§c" + e + e.stack,
                                                    true
                                                );
                                            } finally {
                                                tac.forEach((tab) => tab?.remove()
                                                );
                                            }
                                        });
                                    } catch (e) {
                                        player.sendError(
                                            "§c" + e + e.stack,
                                            true
                                        );
                                    }
                                });
                                break;
                            case "pillars":
                                system.run(() => {
                                    let ta: Entity[];
                                    try {
                                        generateTickingAreaFillCoordinatesC(
                                            player.location,
                                            (() => {
                                                let a = new CompoundBlockVolume();
                                                a.pushVolume({
                                                    volume: new BlockVolume(
                                                        coordinatesa,
                                                        coordinatesb
                                                    ),
                                                });
                                                return a;
                                            })(),
                                            player.dimension
                                        ).then((tac) => {
                                            ta = tac;
                                            try {
                                                let startTime = Date.now();
                                                let a = fillBlocksHP(
                                                    coordinatesa,
                                                    coordinatesb,
                                                    player.dimension,
                                                    firstblockname,
                                                    firstblockstates,
                                                    {
                                                        matchingBlock: matchingblock[0],
                                                        matchingBlockStates: matchingblock[1],
                                                    },
                                                    undefined,
                                                    replacemode
                                                );
                                                let endTime = Date.now();
                                                player.sendMessageB(
                                                    `${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`
                                                );
                                            } catch (e) {
                                                player.sendError(
                                                    "§c" + e + e.stack,
                                                    true
                                                );
                                            } finally {
                                                tac.forEach((tab) => tab?.remove()
                                                );
                                            }
                                        });
                                    } catch (e) {
                                        player.sendError(
                                            "§c" + e + e.stack,
                                            true
                                        );
                                    }
                                });
                                break;
                            case "skygrid":
                                system.run(() => {
                                    let ta: Entity[];
                                    try {
                                        generateTickingAreaFillCoordinatesC(
                                            player.location,
                                            (() => {
                                                let a = new CompoundBlockVolume();
                                                a.pushVolume({
                                                    volume: new BlockVolume(
                                                        coordinatesa,
                                                        coordinatesb
                                                    ),
                                                });
                                                return a;
                                            })(),
                                            player.dimension
                                        ).then((tac) => {
                                            ta = tac;
                                            try {
                                                fillBlocksHSGG(
                                                    coordinatesa,
                                                    coordinatesb,
                                                    sgskygridsize,
                                                    player.dimension,
                                                    sgfirstblockname,
                                                    sgfirstblockstates,
                                                    {
                                                        matchingBlock: sgmatchingblock[0],
                                                        matchingBlockStates: sgmatchingblock[1],
                                                        minMSBetweenYields: 5000,
                                                    },
                                                    undefined,
                                                    sgreplacemode,
                                                    100
                                                ).then(
                                                    (a) => {
                                                        player.sendMessageB(
                                                            `${a.counter == 0
                                                                ? "§c"
                                                                : ""}${a.counter} blocks filled in ${a.completionData
                                                                .endTime -
                                                            a.completionData
                                                                .startTime} ms over ${a.completionData
                                                                .endTick -
                                                            a.completionData
                                                                .startTick} tick${a.completionData
                                                                .endTick -
                                                                a
                                                                    .completionData
                                                                    .startTick ==
                                                                1
                                                                ? ""
                                                                : "s"}${a.completionData
                                                                .containsUnloadedChunks
                                                                ? "; Some blocks were not generated because they were in unloaded chunks. "
                                                                : ""}`
                                                        );
                                                    },
                                                    (e) => {
                                                        player.sendError(
                                                            "§c" + e + e.stack,
                                                            true
                                                        );
                                                    }
                                                );
                                            } catch (e) {
                                                player.sendError(
                                                    "§c" + e + e.stack,
                                                    true
                                                );
                                            } finally {
                                                tac.forEach((tab) => tab?.remove()
                                                );
                                            }
                                        });
                                    } catch (e) {
                                        player.sendError(
                                            "§c" + e + e.stack,
                                            true
                                        );
                                    }
                                });
                                break;
                            case "inverseskygrid":
                                system.run(() => {
                                    let ta: Entity[];
                                    try {
                                        generateTickingAreaFillCoordinatesC(
                                            player.location,
                                            (() => {
                                                let a = new CompoundBlockVolume();
                                                a.pushVolume({
                                                    volume: new BlockVolume(
                                                        coordinatesa,
                                                        coordinatesb
                                                    ),
                                                });
                                                return a;
                                            })(),
                                            player.dimension
                                        ).then((tac) => {
                                            ta = tac;
                                            try {
                                                fillBlocksHISGG(
                                                    coordinatesa,
                                                    coordinatesb,
                                                    sgskygridsize,
                                                    player.dimension,
                                                    sgfirstblockname,
                                                    sgfirstblockstates,
                                                    {
                                                        matchingBlock: sgmatchingblock[0],
                                                        matchingBlockStates: sgmatchingblock[1],
                                                        minMSBetweenYields: 5000,
                                                    },
                                                    undefined,
                                                    sgreplacemode,
                                                    100
                                                ).then(
                                                    (a) => {
                                                        player.sendMessageB(
                                                            `${a.counter == 0
                                                                ? "§c"
                                                                : ""}${a.counter} blocks filled in ${a.completionData
                                                                .endTime -
                                                            a.completionData
                                                                .startTime} ms over ${a.completionData
                                                                .endTick -
                                                            a.completionData
                                                                .startTick} tick${a.completionData
                                                                .endTick -
                                                                a
                                                                    .completionData
                                                                    .startTick ==
                                                                1
                                                                ? ""
                                                                : "s"}${a.completionData
                                                                .containsUnloadedChunks
                                                                ? "; Some blocks were not generated because they were in unloaded chunks. "
                                                                : ""}`
                                                        );
                                                    },
                                                    (e) => {
                                                        player.sendError(
                                                            "§c" + e + e.stack,
                                                            true
                                                        );
                                                    }
                                                );
                                            } catch (e) {
                                                player.sendError(
                                                    "§c" + e + e.stack,
                                                    true
                                                );
                                            } finally {
                                                tac.forEach((tab) => tab?.remove()
                                                );
                                            }
                                        });
                                    } catch (e) {
                                        player.sendError(
                                            "§c" + e + e.stack,
                                            true
                                        );
                                    }
                                });
                                break;
                            case "tunnel":
                                player.sendMessageB("§eComing Soon! ");
                                break;
                            case "floor":
                                player.sendMessageB("§eComing Soon! ");
                                break;
                            case "ceilling":
                                player.sendMessageB("§eComing Soon! ");
                                break;
                            case "diamond":
                                player.sendMessageB("§eComing Soon! ");
                                break;
                            case "hollowovoid":
                                system.run(() => {
                                    let ta: Entity[];
                                    try {
                                        generateTickingAreaFillCoordinatesC(
                                            player.location,
                                            (() => {
                                                let a = new CompoundBlockVolume();
                                                a.pushVolume({
                                                    volume: new BlockVolume(
                                                        Vector3Utils.subtract(
                                                            center,
                                                            Object.assign(
                                                                Vector3Utils.scale(
                                                                    VECTOR3_ONE,
                                                                    50
                                                                ),
                                                                { y: 0 }
                                                            )
                                                        ),
                                                        Vector3Utils.add(
                                                            center,
                                                            Object.assign(
                                                                Vector3Utils.scale(
                                                                    VECTOR3_ONE,
                                                                    50
                                                                ),
                                                                { y: 0 }
                                                            )
                                                        )
                                                    ),
                                                });
                                                return a;
                                            })(),
                                            player.dimension
                                        ).then((tac) => {
                                            ta = tac;
                                            try {
                                                fillBlocksHHOG(
                                                    center,
                                                    vTV3(
                                                        Vector3Utils.subtract(
                                                            horadi,
                                                            {
                                                                x: -0.5,
                                                                y: -0.5,
                                                                z: -0.5,
                                                            }
                                                        )
                                                    ),
                                                    hooffset,
                                                    hothickness,
                                                    player.dimension,
                                                    hofirstblockname,
                                                    hofirstblockstates,
                                                    {
                                                        matchingBlock: homatchingblock[0],
                                                        matchingBlockStates: homatchingblock[1],
                                                        minMSBetweenYields: 5000,
                                                    },
                                                    undefined,
                                                    horeplacemode,
                                                    100
                                                ).then(
                                                    (a) => {
                                                        player.sendMessageB(
                                                            `${a.counter == 0
                                                                ? "§c"
                                                                : ""}${a.counter} blocks filled in ${a.completionData
                                                                .endTime -
                                                            a.completionData
                                                                .startTime} ms over ${a.completionData
                                                                .endTick -
                                                            a.completionData
                                                                .startTick} tick${a.completionData
                                                                .endTick -
                                                                a
                                                                    .completionData
                                                                    .startTick ==
                                                                1
                                                                ? ""
                                                                : "s"}${a.completionData
                                                                .containsUnloadedChunks
                                                                ? "; Some blocks were not generated because they were in unloaded chunks. "
                                                                : ""}`
                                                        );
                                                    },
                                                    (e) => {
                                                        player.sendError(
                                                            "§c" + e + e.stack,
                                                            true
                                                        );
                                                    }
                                                );
                                            } catch (e) {
                                                player.sendError(
                                                    "§c" + e + e.stack,
                                                    true
                                                );
                                            } finally {
                                                tac.forEach((tab) => tab?.remove()
                                                );
                                            }
                                        });
                                    } catch (e) {
                                        player.sendError(
                                            "§c" + e + e.stack,
                                            true
                                        );
                                    }
                                });
                                break;
                            case "ovoid":
                                system.run(() => {
                                    let ta: Entity[];
                                    try {
                                        generateTickingAreaFillCoordinatesC(
                                            player.location,
                                            (() => {
                                                let a = new CompoundBlockVolume();
                                                a.pushVolume({
                                                    volume: new BlockVolume(
                                                        Vector3Utils.subtract(
                                                            center,
                                                            Object.assign(
                                                                Vector3Utils.scale(
                                                                    VECTOR3_ONE,
                                                                    50
                                                                ),
                                                                { y: 0 }
                                                            )
                                                        ),
                                                        Vector3Utils.add(
                                                            center,
                                                            Object.assign(
                                                                Vector3Utils.scale(
                                                                    VECTOR3_ONE,
                                                                    50
                                                                ),
                                                                { y: 0 }
                                                            )
                                                        )
                                                    ),
                                                });
                                                return a;
                                            })(),
                                            player.dimension
                                        ).then((tac) => {
                                            ta = tac;
                                            try {
                                                fillBlocksHOG(
                                                    center,
                                                    vTV3(
                                                        Vector3Utils.subtract(
                                                            oradi,
                                                            {
                                                                x: -0.5,
                                                                y: -0.5,
                                                                z: -0.5,
                                                            }
                                                        )
                                                    ),
                                                    ooffset,
                                                    player.dimension,
                                                    ofirstblockname,
                                                    ofirstblockstates,
                                                    {
                                                        matchingBlock: omatchingblock[0],
                                                        matchingBlockStates: omatchingblock[1],
                                                        minMSBetweenYields: 5000,
                                                    },
                                                    undefined,
                                                    oreplacemode,
                                                    100
                                                ).then(
                                                    (a) => {
                                                        player.sendMessageB(
                                                            `${a.counter == 0
                                                                ? "§c"
                                                                : ""}${a.counter} blocks filled in ${a.completionData
                                                                .endTime -
                                                            a.completionData
                                                                .startTime} ms over ${a.completionData
                                                                .endTick -
                                                            a.completionData
                                                                .startTick} tick${a.completionData
                                                                .endTick -
                                                                a
                                                                    .completionData
                                                                    .startTick ==
                                                                1
                                                                ? ""
                                                                : "s"}${a.completionData
                                                                .containsUnloadedChunks
                                                                ? "; Some blocks were not generated because they were in unloaded chunks. "
                                                                : ""}`
                                                        );
                                                    },
                                                    (e) => {
                                                        player.sendError(
                                                            "§c" + e + e.stack,
                                                            true
                                                        );
                                                    }
                                                );
                                            } catch (e) {
                                                player.sendError(
                                                    "§c" + e + e.stack,
                                                    true
                                                );
                                            } finally {
                                                tac.forEach((tab) => tab?.remove()
                                                );
                                            }
                                        });
                                    } catch (e) {
                                        player.sendError(
                                            "§c" + e + e.stack,
                                            true
                                        );
                                    }
                                });
                                break;
                            case "hollowsphere":
                                system.run(() => {
                                    let ta: Entity[];
                                    try {
                                        generateTickingAreaFillCoordinatesC(
                                            player.location,
                                            (() => {
                                                let a = new CompoundBlockVolume();
                                                a.pushVolume({
                                                    volume: new BlockVolume(
                                                        Vector3Utils.subtract(
                                                            center,
                                                            Object.assign(
                                                                Vector3Utils.scale(
                                                                    VECTOR3_ONE,
                                                                    50
                                                                ),
                                                                { y: 0 }
                                                            )
                                                        ),
                                                        Vector3Utils.add(
                                                            center,
                                                            Object.assign(
                                                                Vector3Utils.scale(
                                                                    VECTOR3_ONE,
                                                                    50
                                                                ),
                                                                { y: 0 }
                                                            )
                                                        )
                                                    ),
                                                });
                                                return a;
                                            })(),
                                            player.dimension
                                        ).then((tac) => {
                                            ta = tac;
                                            try {
                                                fillBlocksHHSG(
                                                    center,
                                                    radius - 0.5,
                                                    thickness,
                                                    player.dimension,
                                                    hsfirstblockname,
                                                    hsfirstblockstates,
                                                    {
                                                        matchingBlock: hsmatchingblock[0],
                                                        matchingBlockStates: hsmatchingblock[1],
                                                        minMSBetweenYields: 5000,
                                                    },
                                                    undefined,
                                                    hsreplacemode,
                                                    100
                                                ).then(
                                                    (a) => {
                                                        player.sendMessageB(
                                                            `${a.counter == 0
                                                                ? "§c"
                                                                : ""}${a.counter} blocks filled in ${a.completionData
                                                                .endTime -
                                                            a.completionData
                                                                .startTime} ms over ${a.completionData
                                                                .endTick -
                                                            a.completionData
                                                                .startTick} tick${a.completionData
                                                                .endTick -
                                                                a
                                                                    .completionData
                                                                    .startTick ==
                                                                1
                                                                ? ""
                                                                : "s"}${a.completionData
                                                                .containsUnloadedChunks
                                                                ? "; Some blocks were not generated because they were in unloaded chunks. "
                                                                : ""}`
                                                        );
                                                    },
                                                    (e) => {
                                                        player.sendError(
                                                            "§c" + e + e.stack,
                                                            true
                                                        );
                                                    }
                                                );
                                            } catch (e) {
                                                player.sendError(
                                                    "§c" + e + e.stack,
                                                    true
                                                );
                                            } finally {
                                                tac.forEach((tab) => tab?.remove()
                                                );
                                            }
                                        });
                                    } catch (e) {
                                        player.sendError(
                                            "§c" + e + e.stack,
                                            true
                                        );
                                    }
                                });
                                break;
                            case "dome":
                                system.run(() => {
                                    let ta: Entity[];
                                    try {
                                        generateTickingAreaFillCoordinatesC(
                                            player.location,
                                            (() => {
                                                let a = new CompoundBlockVolume();
                                                a.pushVolume({
                                                    volume: new BlockVolume(
                                                        Vector3Utils.subtract(
                                                            center,
                                                            Object.assign(
                                                                Vector3Utils.scale(
                                                                    VECTOR3_ONE,
                                                                    50
                                                                ),
                                                                { y: 0 }
                                                            )
                                                        ),
                                                        Vector3Utils.add(
                                                            center,
                                                            Object.assign(
                                                                Vector3Utils.scale(
                                                                    VECTOR3_ONE,
                                                                    50
                                                                ),
                                                                { y: 0 }
                                                            )
                                                        )
                                                    ),
                                                });
                                                return a;
                                            })(),
                                            player.dimension
                                        ).then((tac) => {
                                            ta = tac;
                                            try {
                                                fillBlocksHDG(
                                                    center,
                                                    radius - 0.5,
                                                    thickness,
                                                    player.dimension,
                                                    hsfirstblockname,
                                                    hsfirstblockstates,
                                                    {
                                                        matchingBlock: hsmatchingblock[0],
                                                        matchingBlockStates: hsmatchingblock[1],
                                                        minMSBetweenYields: 5000,
                                                    },
                                                    undefined,
                                                    hsreplacemode,
                                                    100
                                                ).then(
                                                    (a) => {
                                                        player.sendMessageB(
                                                            `${a.counter == 0
                                                                ? "§c"
                                                                : ""}${a.counter} blocks filled in ${a.completionData
                                                                .endTime -
                                                            a.completionData
                                                                .startTime} ms over ${a.completionData
                                                                .endTick -
                                                            a.completionData
                                                                .startTick} tick${a.completionData
                                                                .endTick -
                                                                a
                                                                    .completionData
                                                                    .startTick ==
                                                                1
                                                                ? ""
                                                                : "s"}${a.completionData
                                                                .containsUnloadedChunks
                                                                ? "; Some blocks were not generated because they were in unloaded chunks. "
                                                                : ""}`
                                                        );
                                                    },
                                                    (e) => {
                                                        player.sendError(
                                                            "§c" + e + e.stack,
                                                            true
                                                        );
                                                    }
                                                );
                                            } catch (e) {
                                                player.sendError(
                                                    "§c" + e + e.stack,
                                                    true
                                                );
                                            } finally {
                                                tac.forEach((tab) => tab?.remove()
                                                );
                                            }
                                        });
                                    } catch (e) {
                                        player.sendError(
                                            "§c" + e + e.stack,
                                            true
                                        );
                                    }
                                });
                                break;
                            case "sphere":
                                system.run(() => {
                                    let ta: Entity[];
                                    try {
                                        generateTickingAreaFillCoordinatesC(
                                            player.location,
                                            (() => {
                                                let a = new CompoundBlockVolume();
                                                a.pushVolume({
                                                    volume: new BlockVolume(
                                                        Vector3Utils.subtract(
                                                            center,
                                                            Object.assign(
                                                                Vector3Utils.scale(
                                                                    VECTOR3_ONE,
                                                                    50
                                                                ),
                                                                { y: 0 }
                                                            )
                                                        ),
                                                        Vector3Utils.add(
                                                            center,
                                                            Object.assign(
                                                                Vector3Utils.scale(
                                                                    VECTOR3_ONE,
                                                                    50
                                                                ),
                                                                { y: 0 }
                                                            )
                                                        )
                                                    ),
                                                });
                                                return a;
                                            })(),
                                            player.dimension
                                        ).then((tac) => {
                                            ta = tac;
                                            try {
                                                fillBlocksHSG(
                                                    center,
                                                    radius - 0.5,
                                                    player.dimension,
                                                    ccfirstblockname,
                                                    ccfirstblockstates,
                                                    {
                                                        matchingBlock: ccmatchingblock[0],
                                                        matchingBlockStates: ccmatchingblock[1],
                                                        minMSBetweenYields: 5000,
                                                    },
                                                    undefined,
                                                    ccreplacemode,
                                                    100
                                                ).then(
                                                    (a) => {
                                                        player.sendMessageB(
                                                            `${a.counter == 0
                                                                ? "§c"
                                                                : ""}${a.counter} blocks filled in ${a.completionData
                                                                .endTime -
                                                            a.completionData
                                                                .startTime} ms over ${a.completionData
                                                                .endTick -
                                                            a.completionData
                                                                .startTick} tick${a.completionData
                                                                .endTick -
                                                                a
                                                                    .completionData
                                                                    .startTick ==
                                                                1
                                                                ? ""
                                                                : "s"}`
                                                        );
                                                    },
                                                    (e) => {
                                                        player.sendError(
                                                            "§c" + e + e.stack,
                                                            true
                                                        );
                                                    }
                                                );
                                            } catch (e) {
                                                player.sendError(
                                                    "§c" + e + e.stack,
                                                    true
                                                );
                                            } finally {
                                                tac.forEach((tab) => tab?.remove()
                                                );
                                            }
                                        });
                                    } catch (e) {
                                        player.sendError(
                                            "§c" + e + e.stack,
                                            true
                                        );
                                    }
                                });
                                break;
                            case "semisphere":
                                system.run(() => {
                                    let ta: Entity[];
                                    try {
                                        generateTickingAreaFillCoordinatesC(
                                            player.location,
                                            (() => {
                                                let a = new CompoundBlockVolume();
                                                a.pushVolume({
                                                    volume: new BlockVolume(
                                                        Vector3Utils.subtract(
                                                            center,
                                                            Object.assign(
                                                                Vector3Utils.scale(
                                                                    VECTOR3_ONE,
                                                                    50
                                                                ),
                                                                { y: 0 }
                                                            )
                                                        ),
                                                        Vector3Utils.add(
                                                            center,
                                                            Object.assign(
                                                                Vector3Utils.scale(
                                                                    VECTOR3_ONE,
                                                                    50
                                                                ),
                                                                { y: 0 }
                                                            )
                                                        )
                                                    ),
                                                });
                                                return a;
                                            })(),
                                            player.dimension
                                        ).then((tac) => {
                                            ta = tac;
                                            try {
                                                fillBlocksHSSG(
                                                    center,
                                                    radius - 0.5,
                                                    player.dimension,
                                                    ccfirstblockname,
                                                    ccfirstblockstates,
                                                    {
                                                        matchingBlock: ccmatchingblock[0],
                                                        matchingBlockStates: ccmatchingblock[1],
                                                        minMSBetweenYields: 5000,
                                                    },
                                                    undefined,
                                                    ccreplacemode,
                                                    100
                                                ).then(
                                                    (a) => {
                                                        player.sendMessageB(
                                                            `${a.counter == 0
                                                                ? "§c"
                                                                : ""}${a.counter} blocks filled in ${a.completionData
                                                                .endTime -
                                                            a.completionData
                                                                .startTime} ms over ${a.completionData
                                                                .endTick -
                                                            a.completionData
                                                                .startTick} tick${a.completionData
                                                                .endTick -
                                                                a
                                                                    .completionData
                                                                    .startTick ==
                                                                1
                                                                ? ""
                                                                : "s"}`
                                                        );
                                                    },
                                                    (e) => {
                                                        player.sendError(
                                                            "§c" + e + e.stack,
                                                            true
                                                        );
                                                    }
                                                );
                                            } catch (e) {
                                                player.sendError(
                                                    "§c" + e + e.stack,
                                                    true
                                                );
                                            } finally {
                                                tac.forEach((tab) => tab?.remove()
                                                );
                                            }
                                        });
                                    } catch (e) {
                                        player.sendError(
                                            "§c" + e + e.stack,
                                            true
                                        );
                                    }
                                });
                                break;
                            case "circle":
                                system.run(() => {
                                    let ta: Entity[];
                                    try {
                                        generateTickingAreaFillCoordinatesC(
                                            player.location,
                                            (() => {
                                                let a = new CompoundBlockVolume();
                                                a.pushVolume({
                                                    volume: new BlockVolume(
                                                        Vector3Utils.subtract(
                                                            center,
                                                            Object.assign(
                                                                Vector3Utils.scale(
                                                                    VECTOR3_ONE,
                                                                    50
                                                                ),
                                                                { y: 0 }
                                                            )
                                                        ),
                                                        Vector3Utils.add(
                                                            center,
                                                            Object.assign(
                                                                Vector3Utils.scale(
                                                                    VECTOR3_ONE,
                                                                    50
                                                                ),
                                                                { y: 0 }
                                                            )
                                                        )
                                                    ),
                                                });
                                                return a;
                                            })(),
                                            player.dimension
                                        ).then((tac) => {
                                            ta = tac;
                                            try {
                                                let startTime = Date.now();
                                                let a = fillBlocksHC(
                                                    center,
                                                    radius,
                                                    player.dimension,
                                                    axis,
                                                    cfirstblockname,
                                                    cfirstblockstates,
                                                    {
                                                        matchingBlock: cmatchingblock[0],
                                                        matchingBlockStates: cmatchingblock[1],
                                                    },
                                                    undefined,
                                                    creplacemode
                                                );
                                                let endTime = Date.now();
                                                player.sendMessageB(
                                                    `${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`
                                                );
                                            } catch (e) {
                                                player.sendError(
                                                    "§c" + e + e.stack,
                                                    true
                                                );
                                            } finally {
                                                tac.forEach((tab) => tab?.remove()
                                                );
                                            }
                                        });
                                    } catch (e) {
                                        player.sendError(
                                            "§c" + e + e.stack,
                                            true
                                        );
                                    }
                                });
                                break;
                            case "circlex":
                                system.run(() => {
                                    let ta: Entity[];
                                    try {
                                        generateTickingAreaFillCoordinatesC(
                                            player.location,
                                            (() => {
                                                let a = new CompoundBlockVolume();
                                                a.pushVolume({
                                                    volume: new BlockVolume(
                                                        Vector3Utils.subtract(
                                                            center,
                                                            Object.assign(
                                                                Vector3Utils.scale(
                                                                    VECTOR3_ONE,
                                                                    50
                                                                ),
                                                                { y: 0 }
                                                            )
                                                        ),
                                                        Vector3Utils.add(
                                                            center,
                                                            Object.assign(
                                                                Vector3Utils.scale(
                                                                    VECTOR3_ONE,
                                                                    50
                                                                ),
                                                                { y: 0 }
                                                            )
                                                        )
                                                    ),
                                                });
                                                return a;
                                            })(),
                                            player.dimension
                                        ).then((tac) => {
                                            ta = tac;
                                            try {
                                                let startTime = Date.now();
                                                let a = fillBlocksHC(
                                                    center,
                                                    radius,
                                                    player.dimension,
                                                    "x",
                                                    ccfirstblockname,
                                                    ccfirstblockstates,
                                                    {
                                                        matchingBlock: ccmatchingblock[0],
                                                        matchingBlockStates: ccmatchingblock[1],
                                                    },
                                                    undefined,
                                                    ccreplacemode
                                                );
                                                let endTime = Date.now();
                                                player.sendMessageB(
                                                    `${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`
                                                );
                                            } catch (e) {
                                                player.sendError(
                                                    "§c" + e + e.stack,
                                                    true
                                                );
                                            } finally {
                                                tac.forEach((tab) => tab?.remove()
                                                );
                                            }
                                        });
                                    } catch (e) {
                                        player.sendError(
                                            "§c" + e + e.stack,
                                            true
                                        );
                                    }
                                });
                                break;
                            case "circley":
                                system.run(() => {
                                    let ta: Entity[];
                                    try {
                                        generateTickingAreaFillCoordinatesC(
                                            player.location,
                                            (() => {
                                                let a = new CompoundBlockVolume();
                                                a.pushVolume({
                                                    volume: new BlockVolume(
                                                        Vector3Utils.subtract(
                                                            center,
                                                            Object.assign(
                                                                Vector3Utils.scale(
                                                                    VECTOR3_ONE,
                                                                    50
                                                                ),
                                                                { y: 0 }
                                                            )
                                                        ),
                                                        Vector3Utils.add(
                                                            center,
                                                            Object.assign(
                                                                Vector3Utils.scale(
                                                                    VECTOR3_ONE,
                                                                    50
                                                                ),
                                                                { y: 0 }
                                                            )
                                                        )
                                                    ),
                                                });
                                                return a;
                                            })(),
                                            player.dimension
                                        ).then((tac) => {
                                            ta = tac;
                                            try {
                                                let startTime = Date.now();
                                                let a = fillBlocksHC(
                                                    center,
                                                    radius,
                                                    player.dimension,
                                                    "y",
                                                    ccfirstblockname,
                                                    ccfirstblockstates,
                                                    {
                                                        matchingBlock: ccmatchingblock[0],
                                                        matchingBlockStates: ccmatchingblock[1],
                                                    },
                                                    undefined,
                                                    ccreplacemode
                                                );
                                                let endTime = Date.now();
                                                player.sendMessageB(
                                                    `${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`
                                                );
                                            } catch (e) {
                                                player.sendError(
                                                    "§c" + e + e.stack,
                                                    true
                                                );
                                            } finally {
                                                tac.forEach((tab) => tab?.remove()
                                                );
                                            }
                                        });
                                    } catch (e) {
                                        player.sendError(
                                            "§c" + e + e.stack,
                                            true
                                        );
                                    }
                                });
                                break;
                            case "circlez":
                                system.run(() => {
                                    let ta: Entity[];
                                    try {
                                        generateTickingAreaFillCoordinatesC(
                                            player.location,
                                            (() => {
                                                let a = new CompoundBlockVolume();
                                                a.pushVolume({
                                                    volume: new BlockVolume(
                                                        Vector3Utils.subtract(
                                                            center,
                                                            Object.assign(
                                                                Vector3Utils.scale(
                                                                    VECTOR3_ONE,
                                                                    50
                                                                ),
                                                                { y: 0 }
                                                            )
                                                        ),
                                                        Vector3Utils.add(
                                                            center,
                                                            Object.assign(
                                                                Vector3Utils.scale(
                                                                    VECTOR3_ONE,
                                                                    50
                                                                ),
                                                                { y: 0 }
                                                            )
                                                        )
                                                    ),
                                                });
                                                return a;
                                            })(),
                                            player.dimension
                                        ).then((tac) => {
                                            ta = tac;
                                            try {
                                                let startTime = Date.now();
                                                let a = fillBlocksHC(
                                                    center,
                                                    radius,
                                                    player.dimension,
                                                    "z",
                                                    ccfirstblockname,
                                                    ccfirstblockstates,
                                                    {
                                                        matchingBlock: ccmatchingblock[0],
                                                        matchingBlockStates: ccmatchingblock[1],
                                                    },
                                                    undefined,
                                                    ccreplacemode
                                                );
                                                let endTime = Date.now();
                                                player.sendMessageB(
                                                    `${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`
                                                );
                                            } catch (e) {
                                                player.sendError(
                                                    "§c" + e + e.stack,
                                                    true
                                                );
                                            } finally {
                                                tac.forEach((tab) => tab?.remove()
                                                );
                                            }
                                        });
                                    } catch (e) {
                                        player.sendError(
                                            "§c" + e + e.stack,
                                            true
                                        );
                                    }
                                });
                                break;
                            case "circlexy":
                                system.run(() => {
                                    let ta: Entity[];
                                    try {
                                        generateTickingAreaFillCoordinatesC(
                                            player.location,
                                            (() => {
                                                let a = new CompoundBlockVolume();
                                                a.pushVolume({
                                                    volume: new BlockVolume(
                                                        Vector3Utils.subtract(
                                                            center,
                                                            Object.assign(
                                                                Vector3Utils.scale(
                                                                    VECTOR3_ONE,
                                                                    50
                                                                ),
                                                                { y: 0 }
                                                            )
                                                        ),
                                                        Vector3Utils.add(
                                                            center,
                                                            Object.assign(
                                                                Vector3Utils.scale(
                                                                    VECTOR3_ONE,
                                                                    50
                                                                ),
                                                                { y: 0 }
                                                            )
                                                        )
                                                    ),
                                                });
                                                return a;
                                            })(),
                                            player.dimension
                                        ).then((tac) => {
                                            ta = tac;
                                            try {
                                                let startTime = Date.now();
                                                let a = fillBlocksHC(
                                                    center,
                                                    radius,
                                                    player.dimension,
                                                    "xy",
                                                    ccfirstblockname,
                                                    ccfirstblockstates,
                                                    {
                                                        matchingBlock: ccmatchingblock[0],
                                                        matchingBlockStates: ccmatchingblock[1],
                                                    },
                                                    undefined,
                                                    ccreplacemode
                                                );
                                                let endTime = Date.now();
                                                player.sendMessageB(
                                                    `${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`
                                                );
                                            } catch (e) {
                                                player.sendError(
                                                    "§c" + e + e.stack,
                                                    true
                                                );
                                            } finally {
                                                tac.forEach((tab) => tab?.remove()
                                                );
                                            }
                                        });
                                    } catch (e) {
                                        player.sendError(
                                            "§c" + e + e.stack,
                                            true
                                        );
                                    }
                                });
                                break;
                            case "circleyz":
                                system.run(() => {
                                    let ta: Entity[];
                                    try {
                                        generateTickingAreaFillCoordinatesC(
                                            player.location,
                                            (() => {
                                                let a = new CompoundBlockVolume();
                                                a.pushVolume({
                                                    volume: new BlockVolume(
                                                        Vector3Utils.subtract(
                                                            center,
                                                            Object.assign(
                                                                Vector3Utils.scale(
                                                                    VECTOR3_ONE,
                                                                    50
                                                                ),
                                                                { y: 0 }
                                                            )
                                                        ),
                                                        Vector3Utils.add(
                                                            center,
                                                            Object.assign(
                                                                Vector3Utils.scale(
                                                                    VECTOR3_ONE,
                                                                    50
                                                                ),
                                                                { y: 0 }
                                                            )
                                                        )
                                                    ),
                                                });
                                                return a;
                                            })(),
                                            player.dimension
                                        ).then((tac) => {
                                            ta = tac;
                                            try {
                                                let startTime = Date.now();
                                                let a = fillBlocksHC(
                                                    center,
                                                    radius,
                                                    player.dimension,
                                                    "yz",
                                                    ccfirstblockname,
                                                    ccfirstblockstates,
                                                    {
                                                        matchingBlock: ccmatchingblock[0],
                                                        matchingBlockStates: ccmatchingblock[1],
                                                    },
                                                    undefined,
                                                    ccreplacemode
                                                );
                                                let endTime = Date.now();
                                                player.sendMessageB(
                                                    `${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`
                                                );
                                            } catch (e) {
                                                player.sendError(
                                                    "§c" + e + e.stack,
                                                    true
                                                );
                                            } finally {
                                                tac.forEach((tab) => tab?.remove()
                                                );
                                            }
                                        });
                                    } catch (e) {
                                        player.sendError(
                                            "§c" + e + e.stack,
                                            true
                                        );
                                    }
                                });
                                break;
                            case "circlexz":
                                system.run(() => {
                                    let ta: Entity[];
                                    try {
                                        generateTickingAreaFillCoordinatesC(
                                            player.location,
                                            (() => {
                                                let a = new CompoundBlockVolume();
                                                a.pushVolume({
                                                    volume: new BlockVolume(
                                                        Vector3Utils.subtract(
                                                            center,
                                                            Object.assign(
                                                                Vector3Utils.scale(
                                                                    VECTOR3_ONE,
                                                                    50
                                                                ),
                                                                { y: 0 }
                                                            )
                                                        ),
                                                        Vector3Utils.add(
                                                            center,
                                                            Object.assign(
                                                                Vector3Utils.scale(
                                                                    VECTOR3_ONE,
                                                                    50
                                                                ),
                                                                { y: 0 }
                                                            )
                                                        )
                                                    ),
                                                });
                                                return a;
                                            })(),
                                            player.dimension
                                        ).then((tac) => {
                                            ta = tac;
                                            try {
                                                let startTime = Date.now();
                                                let a = fillBlocksHC(
                                                    center,
                                                    radius,
                                                    player.dimension,
                                                    "xz",
                                                    ccfirstblockname,
                                                    ccfirstblockstates,
                                                    {
                                                        matchingBlock: ccmatchingblock[0],
                                                        matchingBlockStates: ccmatchingblock[1],
                                                    },
                                                    undefined,
                                                    ccreplacemode
                                                );
                                                let endTime = Date.now();
                                                player.sendMessageB(
                                                    `${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`
                                                );
                                            } catch (e) {
                                                player.sendError(
                                                    "§c" + e + e.stack,
                                                    true
                                                );
                                            } finally {
                                                tac.forEach((tab) => tab?.remove()
                                                );
                                            }
                                        });
                                    } catch (e) {
                                        player.sendError(
                                            "§c" + e + e.stack,
                                            true
                                        );
                                    }
                                });
                                break;
                            case "circlexyz":
                                system.run(() => {
                                    let ta: Entity[];
                                    try {
                                        generateTickingAreaFillCoordinatesC(
                                            player.location,
                                            (() => {
                                                let a = new CompoundBlockVolume();
                                                a.pushVolume({
                                                    volume: new BlockVolume(
                                                        Vector3Utils.subtract(
                                                            center,
                                                            Object.assign(
                                                                Vector3Utils.scale(
                                                                    VECTOR3_ONE,
                                                                    50
                                                                ),
                                                                { y: 0 }
                                                            )
                                                        ),
                                                        Vector3Utils.add(
                                                            center,
                                                            Object.assign(
                                                                Vector3Utils.scale(
                                                                    VECTOR3_ONE,
                                                                    50
                                                                ),
                                                                { y: 0 }
                                                            )
                                                        )
                                                    ),
                                                });
                                                return a;
                                            })(),
                                            player.dimension
                                        ).then((tac) => {
                                            ta = tac;
                                            try {
                                                let startTime = Date.now();
                                                let a = fillBlocksHC(
                                                    center,
                                                    radius,
                                                    player.dimension,
                                                    "xyz",
                                                    ccfirstblockname,
                                                    ccfirstblockstates,
                                                    {
                                                        matchingBlock: ccmatchingblock[0],
                                                        matchingBlockStates: ccmatchingblock[1],
                                                    },
                                                    undefined,
                                                    ccreplacemode
                                                );
                                                let endTime = Date.now();
                                                player.sendMessageB(
                                                    `${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`
                                                );
                                            } catch (e) {
                                                player.sendError(
                                                    "§c" + e + e.stack,
                                                    true
                                                );
                                            } finally {
                                                tac.forEach((tab) => tab?.remove()
                                                );
                                            }
                                        });
                                    } catch (e) {
                                        player.sendError(
                                            "§c" + e + e.stack,
                                            true
                                        );
                                    }
                                });
                                break;
                            case "cylinder":
                                system.run(() => {
                                    let ta: Entity[];
                                    try {
                                        generateTickingAreaFillCoordinatesC(
                                            player.location,
                                            (() => {
                                                let a = new CompoundBlockVolume();
                                                a.pushVolume({
                                                    volume: new BlockVolume(
                                                        Vector3Utils.subtract(
                                                            center,
                                                            Object.assign(
                                                                Vector3Utils.scale(
                                                                    VECTOR3_ONE,
                                                                    50
                                                                ),
                                                                { y: 0 }
                                                            )
                                                        ),
                                                        Vector3Utils.add(
                                                            center,
                                                            Object.assign(
                                                                Vector3Utils.scale(
                                                                    VECTOR3_ONE,
                                                                    50
                                                                ),
                                                                { y: 0 }
                                                            )
                                                        )
                                                    ),
                                                });
                                                return a;
                                            })(),
                                            player.dimension
                                        ).then((tac) => {
                                            ta = tac;
                                            try {
                                                let startTime = Date.now();
                                                let a = fillBlocksHT(
                                                    center,
                                                    radius,
                                                    thickness,
                                                    taxis,
                                                    player.dimension,
                                                    tfirstblockname,
                                                    tfirstblockstates,
                                                    {
                                                        matchingBlock: tmatchingblock[0],
                                                        matchingBlockStates: tmatchingblock[1],
                                                    },
                                                    undefined,
                                                    treplacemode
                                                );
                                                let endTime = Date.now();
                                                player.sendMessageB(
                                                    `${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`
                                                );
                                            } catch (e) {
                                                player.sendError(
                                                    "§c" + e + e.stack,
                                                    true
                                                );
                                            } finally {
                                                tac.forEach((tab) => tab?.remove()
                                                );
                                            }
                                        });
                                    } catch (e) {
                                        player.sendError(
                                            "§c" + e + e.stack,
                                            true
                                        );
                                    }
                                });
                                break;
                            case "cylinderx":
                                system.run(() => {
                                    let ta: Entity[];
                                    try {
                                        generateTickingAreaFillCoordinatesC(
                                            player.location,
                                            (() => {
                                                let a = new CompoundBlockVolume();
                                                a.pushVolume({
                                                    volume: new BlockVolume(
                                                        Vector3Utils.subtract(
                                                            center,
                                                            Object.assign(
                                                                Vector3Utils.scale(
                                                                    VECTOR3_ONE,
                                                                    50
                                                                ),
                                                                { y: 0 }
                                                            )
                                                        ),
                                                        Vector3Utils.add(
                                                            center,
                                                            Object.assign(
                                                                Vector3Utils.scale(
                                                                    VECTOR3_ONE,
                                                                    50
                                                                ),
                                                                { y: 0 }
                                                            )
                                                        )
                                                    ),
                                                });
                                                return a;
                                            })(),
                                            player.dimension
                                        ).then((tac) => {
                                            ta = tac;
                                            try {
                                                let startTime = Date.now();
                                                let a = fillBlocksHT(
                                                    center,
                                                    radius,
                                                    thickness,
                                                    "x",
                                                    player.dimension,
                                                    hsfirstblockname,
                                                    hsfirstblockstates,
                                                    {
                                                        matchingBlock: hsmatchingblock[0],
                                                        matchingBlockStates: hsmatchingblock[1],
                                                    },
                                                    undefined,
                                                    hsreplacemode
                                                );
                                                let endTime = Date.now();
                                                player.sendMessageB(
                                                    `${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`
                                                );
                                            } catch (e) {
                                                player.sendError(
                                                    "§c" + e + e.stack,
                                                    true
                                                );
                                            } finally {
                                                tac.forEach((tab) => tab?.remove()
                                                );
                                            }
                                        });
                                    } catch (e) {
                                        player.sendError(
                                            "§c" + e + e.stack,
                                            true
                                        );
                                    }
                                });
                                break;
                            case "cylindery":
                                system.run(() => {
                                    let ta: Entity[];
                                    try {
                                        generateTickingAreaFillCoordinatesC(
                                            player.location,
                                            (() => {
                                                let a = new CompoundBlockVolume();
                                                a.pushVolume({
                                                    volume: new BlockVolume(
                                                        Vector3Utils.subtract(
                                                            center,
                                                            Object.assign(
                                                                Vector3Utils.scale(
                                                                    VECTOR3_ONE,
                                                                    50
                                                                ),
                                                                { y: 0 }
                                                            )
                                                        ),
                                                        Vector3Utils.add(
                                                            center,
                                                            Object.assign(
                                                                Vector3Utils.scale(
                                                                    VECTOR3_ONE,
                                                                    50
                                                                ),
                                                                { y: 0 }
                                                            )
                                                        )
                                                    ),
                                                });
                                                return a;
                                            })(),
                                            player.dimension
                                        ).then((tac) => {
                                            ta = tac;
                                            try {
                                                let startTime = Date.now();
                                                let a = fillBlocksHT(
                                                    center,
                                                    radius,
                                                    thickness,
                                                    "y",
                                                    player.dimension,
                                                    hsfirstblockname,
                                                    hsfirstblockstates,
                                                    {
                                                        matchingBlock: hsmatchingblock[0],
                                                        matchingBlockStates: hsmatchingblock[1],
                                                    },
                                                    undefined,
                                                    hsreplacemode
                                                );
                                                let endTime = Date.now();
                                                player.sendMessageB(
                                                    `${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`
                                                );
                                            } catch (e) {
                                                player.sendError(
                                                    "§c" + e + e.stack,
                                                    true
                                                );
                                            } finally {
                                                tac.forEach((tab) => tab?.remove()
                                                );
                                            }
                                        });
                                    } catch (e) {
                                        player.sendError(
                                            "§c" + e + e.stack,
                                            true
                                        );
                                    }
                                });
                                break;
                            case "cylinderz":
                                system.run(() => {
                                    let ta: Entity[];
                                    try {
                                        generateTickingAreaFillCoordinatesC(
                                            player.location,
                                            (() => {
                                                let a = new CompoundBlockVolume();
                                                a.pushVolume({
                                                    volume: new BlockVolume(
                                                        Vector3Utils.subtract(
                                                            center,
                                                            Object.assign(
                                                                Vector3Utils.scale(
                                                                    VECTOR3_ONE,
                                                                    50
                                                                ),
                                                                { y: 0 }
                                                            )
                                                        ),
                                                        Vector3Utils.add(
                                                            center,
                                                            Object.assign(
                                                                Vector3Utils.scale(
                                                                    VECTOR3_ONE,
                                                                    50
                                                                ),
                                                                { y: 0 }
                                                            )
                                                        )
                                                    ),
                                                });
                                                return a;
                                            })(),
                                            player.dimension
                                        ).then((tac) => {
                                            ta = tac;
                                            try {
                                                let startTime = Date.now();
                                                let a = fillBlocksHT(
                                                    center,
                                                    radius,
                                                    thickness,
                                                    "z",
                                                    player.dimension,
                                                    hsfirstblockname,
                                                    hsfirstblockstates,
                                                    {
                                                        matchingBlock: hsmatchingblock[0],
                                                        matchingBlockStates: hsmatchingblock[1],
                                                    },
                                                    undefined,
                                                    hsreplacemode
                                                );
                                                let endTime = Date.now();
                                                player.sendMessageB(
                                                    `${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`
                                                );
                                            } catch (e) {
                                                player.sendError(
                                                    "§c" + e + e.stack,
                                                    true
                                                );
                                            } finally {
                                                tac.forEach((tab) => tab?.remove()
                                                );
                                            }
                                        });
                                    } catch (e) {
                                        player.sendError(
                                            "§c" + e + e.stack,
                                            true
                                        );
                                    }
                                });
                                break;
                            case "cylinderxy":
                                system.run(() => {
                                    let ta: Entity[];
                                    try {
                                        generateTickingAreaFillCoordinatesC(
                                            player.location,
                                            (() => {
                                                let a = new CompoundBlockVolume();
                                                a.pushVolume({
                                                    volume: new BlockVolume(
                                                        Vector3Utils.subtract(
                                                            center,
                                                            Object.assign(
                                                                Vector3Utils.scale(
                                                                    VECTOR3_ONE,
                                                                    50
                                                                ),
                                                                { y: 0 }
                                                            )
                                                        ),
                                                        Vector3Utils.add(
                                                            center,
                                                            Object.assign(
                                                                Vector3Utils.scale(
                                                                    VECTOR3_ONE,
                                                                    50
                                                                ),
                                                                { y: 0 }
                                                            )
                                                        )
                                                    ),
                                                });
                                                return a;
                                            })(),
                                            player.dimension
                                        ).then((tac) => {
                                            ta = tac;
                                            try {
                                                let startTime = Date.now();
                                                let a = fillBlocksHT(
                                                    center,
                                                    radius,
                                                    thickness,
                                                    "x",
                                                    player.dimension,
                                                    hsfirstblockname,
                                                    hsfirstblockstates,
                                                    {
                                                        matchingBlock: hsmatchingblock[0],
                                                        matchingBlockStates: hsmatchingblock[1],
                                                    },
                                                    undefined,
                                                    hsreplacemode
                                                );
                                                let endTime = Date.now();
                                                player.sendMessageB(
                                                    `${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`
                                                );
                                            } catch (e) {
                                                player.sendError(
                                                    "§c" + e + e.stack,
                                                    true
                                                );
                                            } finally {
                                                tac.forEach((tab) => tab?.remove()
                                                );
                                            }
                                        });
                                    } catch (e) {
                                        player.sendError(
                                            "§c" + e + e.stack,
                                            true
                                        );
                                    }
                                });
                                break;
                            case "cylinderyz":
                                system.run(() => {
                                    let ta: Entity[];
                                    try {
                                        generateTickingAreaFillCoordinatesC(
                                            player.location,
                                            (() => {
                                                let a = new CompoundBlockVolume();
                                                a.pushVolume({
                                                    volume: new BlockVolume(
                                                        Vector3Utils.subtract(
                                                            center,
                                                            Object.assign(
                                                                Vector3Utils.scale(
                                                                    VECTOR3_ONE,
                                                                    50
                                                                ),
                                                                { y: 0 }
                                                            )
                                                        ),
                                                        Vector3Utils.add(
                                                            center,
                                                            Object.assign(
                                                                Vector3Utils.scale(
                                                                    VECTOR3_ONE,
                                                                    50
                                                                ),
                                                                { y: 0 }
                                                            )
                                                        )
                                                    ),
                                                });
                                                return a;
                                            })(),
                                            player.dimension
                                        ).then((tac) => {
                                            ta = tac;
                                            try {
                                                let startTime = Date.now();
                                                let a = fillBlocksHT(
                                                    center,
                                                    radius,
                                                    thickness,
                                                    "y",
                                                    player.dimension,
                                                    hsfirstblockname,
                                                    hsfirstblockstates,
                                                    {
                                                        matchingBlock: hsmatchingblock[0],
                                                        matchingBlockStates: hsmatchingblock[1],
                                                    },
                                                    undefined,
                                                    hsreplacemode
                                                );
                                                let endTime = Date.now();
                                                player.sendMessageB(
                                                    `${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`
                                                );
                                            } catch (e) {
                                                player.sendError(
                                                    "§c" + e + e.stack,
                                                    true
                                                );
                                            } finally {
                                                tac.forEach((tab) => tab?.remove()
                                                );
                                            }
                                        });
                                    } catch (e) {
                                        player.sendError(
                                            "§c" + e + e.stack,
                                            true
                                        );
                                    }
                                });
                                break;
                            case "cylinderxz":
                                system.run(() => {
                                    let ta: Entity[];
                                    try {
                                        generateTickingAreaFillCoordinatesC(
                                            player.location,
                                            (() => {
                                                let a = new CompoundBlockVolume();
                                                a.pushVolume({
                                                    volume: new BlockVolume(
                                                        Vector3Utils.subtract(
                                                            center,
                                                            Object.assign(
                                                                Vector3Utils.scale(
                                                                    VECTOR3_ONE,
                                                                    50
                                                                ),
                                                                { y: 0 }
                                                            )
                                                        ),
                                                        Vector3Utils.add(
                                                            center,
                                                            Object.assign(
                                                                Vector3Utils.scale(
                                                                    VECTOR3_ONE,
                                                                    50
                                                                ),
                                                                { y: 0 }
                                                            )
                                                        )
                                                    ),
                                                });
                                                return a;
                                            })(),
                                            player.dimension
                                        ).then((tac) => {
                                            ta = tac;
                                            try {
                                                let startTime = Date.now();
                                                let a = fillBlocksHT(
                                                    center,
                                                    radius,
                                                    thickness,
                                                    "z",
                                                    player.dimension,
                                                    hsfirstblockname,
                                                    hsfirstblockstates,
                                                    {
                                                        matchingBlock: hsmatchingblock[0],
                                                        matchingBlockStates: hsmatchingblock[1],
                                                    },
                                                    undefined,
                                                    hsreplacemode
                                                );
                                                let endTime = Date.now();
                                                player.sendMessageB(
                                                    `${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`
                                                );
                                            } catch (e) {
                                                player.sendError(
                                                    "§c" + e + e.stack,
                                                    true
                                                );
                                            } finally {
                                                tac.forEach((tab) => tab?.remove()
                                                );
                                            }
                                        });
                                    } catch (e) {
                                        player.sendError(
                                            "§c" + e + e.stack,
                                            true
                                        );
                                    }
                                });
                                break;
                            case "cylinderxyz":
                                system.run(() => {
                                    let ta: Entity[];
                                    try {
                                        generateTickingAreaFillCoordinatesC(
                                            player.location,
                                            (() => {
                                                let a = new CompoundBlockVolume();
                                                a.pushVolume({
                                                    volume: new BlockVolume(
                                                        Vector3Utils.subtract(
                                                            center,
                                                            Object.assign(
                                                                Vector3Utils.scale(
                                                                    VECTOR3_ONE,
                                                                    50
                                                                ),
                                                                { y: 0 }
                                                            )
                                                        ),
                                                        Vector3Utils.add(
                                                            center,
                                                            Object.assign(
                                                                Vector3Utils.scale(
                                                                    VECTOR3_ONE,
                                                                    50
                                                                ),
                                                                { y: 0 }
                                                            )
                                                        )
                                                    ),
                                                });
                                                return a;
                                            })(),
                                            player.dimension
                                        ).then((tac) => {
                                            ta = tac;
                                            try {
                                                let startTime = Date.now();
                                                let a = fillBlocksHT(
                                                    center,
                                                    radius,
                                                    thickness,
                                                    "z",
                                                    player.dimension,
                                                    hsfirstblockname,
                                                    hsfirstblockstates,
                                                    {
                                                        matchingBlock: hsmatchingblock[0],
                                                        matchingBlockStates: hsmatchingblock[1],
                                                    },
                                                    undefined,
                                                    hsreplacemode
                                                );
                                                let endTime = Date.now();
                                                player.sendMessageB(
                                                    `${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`
                                                );
                                            } catch (e) {
                                                player.sendError(
                                                    "§c" + e + e.stack,
                                                    true
                                                );
                                            } finally {
                                                tac.forEach((tab) => tab?.remove()
                                                );
                                            }
                                        });
                                    } catch (e) {
                                        player.sendError(
                                            "§c" + e + e.stack,
                                            true
                                        );
                                    }
                                });
                                break;
                            case "hourglass":
                                player.sendMessageB("§eComing Soon! ");
                                break;
                            case "cube":
                                system.run(() => {
                                    let ta: Entity[];
                                    try {
                                        generateTickingAreaFillCoordinatesC(
                                            player.location,
                                            (() => {
                                                let a = new CompoundBlockVolume();
                                                a.pushVolume({
                                                    volume: new BlockVolume(
                                                        coordinatesa,
                                                        coordinatesb
                                                    ),
                                                });
                                                return a;
                                            })(),
                                            player.dimension
                                        ).then((tac) => {
                                            ta = tac;
                                            try {
                                                let startTime = Date.now();
                                                if (replacemode) {
                                                    clearAllContainerBlocks(
                                                        scanForContainerBlocks(
                                                            coordinatesa,
                                                            coordinatesb,
                                                            player.dimension,
                                                            "Block"
                                                        ) as Block[]
                                                    );
                                                }
                                                let a = fillBlocksH(
                                                    coordinatesa,
                                                    coordinatesb,
                                                    player.dimension,
                                                    firstblockname,
                                                    firstblockstates,
                                                    {
                                                        matchingBlock: matchingblock[0],
                                                        matchingBlockStates: matchingblock[1],
                                                    }
                                                );
                                                let endTime = Date.now();
                                                player.sendMessageB(
                                                    `${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`
                                                );
                                            } catch (e) {
                                                player.sendError(
                                                    "§c" + e + e.stack,
                                                    true
                                                );
                                            } finally {
                                                tac.forEach((tab) => tab?.remove()
                                                );
                                            }
                                        });
                                    } catch (e) {
                                        player.sendError(
                                            "§c" + e + e.stack,
                                            true
                                        );
                                    }
                                });
                                break;
                            default:
                        }
                    }
                    //            try{system.run(()=>{player.dimension.fillBlocks(evaluateCoordinates(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[0][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[1][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[2][0], player.location, player.getRotation()), evaluateCoordinates(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[3][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[4][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0], player.location, player.getRotation()), BlockPermutation.resolve(switchTestB.split(" ").slice(1).join(" ").slice(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5].index+Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0].indexOf(" ")+1).split(" ")[0], extractJSONStrings(switchTestB.split(" ").slice(1).join(" ").slice(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5].index+Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0].indexOf(" ")).split(" ").slice(1).join(" "), false)[0]), {matchingBlock: BlockPermutation.resolve(getParametersFromString(switchTestB.split(" ").slice(1).join(" ").slice(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5].index+Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0].indexOf(" ")+1)).results[2], extractJSONStrings(switchTestB.split(" ").slice(1).join(" ").slice(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5].index+Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0].indexOf(" ")).split(" ").slice(1).join(" "), false)[1])}); }); }catch(e){player.sendError("§c" + e + e.stack, true)}
                }
                break;
            case !!switchTest.match(/^idtfill$/):
                {
                    eventData.cancel = true;
                    eventData.cancel = true;
                    if (switchTestB.trim().split(" ").length == 1) {
                        player.sendMessageB(`idtfill command format: 
${command.dp}idtfill <from: x y z> <to: x y z> <integrity: float> <tileName: Block> <blockStates: block states> <ifillMode: replace|fill|cube|keep|walls|hollow|outline|pillars§c|floor|ceilling|diamond|hourglass§r> <replaceTileName: Block> [replaceBlockStates: block states] [clearContainers: boolean]
${command.dp}idtfill <from: x y z> <to: x y z> <integrity: float> <tileName: Block> <blockStates: block states> <ifillMode: replace|fill|cube|keep|walls|hollow|outline|pillars§c|floor|ceilling|diamond|hourglass§r> <reaplceTileName: Block> [clearContainers: boolean]
${command.dp}idtfill <from: x y z> <to: x y z> <integrity: float> <tileName: Block> <blockStates: block states> [ifillMode: replace|fill|cube|keep|walls|hollow|outline|pillars§c|floor|ceilling|diamond|hourglass§r] [clearContainers: boolean]
${command.dp}idtfill <from: x y z> <to: x y z> <integrity: float> <tileName: Block> <blockStates: block states> [clearContainers: boolean]
${command.dp}idtfill <from: x y z> <to: x y z> <integrity: float> <tileName: Block> <ifillMode: replace|fill|cube|keep|walls|hollow|outline|pillars§c|floor|ceilling|diamond|hourglass§r> <replaceTileName: Block> [replaceBlockStates: block states] [clearContainers: boolean]
${command.dp}idtfill <from: x y z> <to: x y z> <integrity: float> <tileName: Block> <ifillMode: replace|fill|cube|keep|walls|hollow|outline|pillars§c|floor|ceilling|diamond|hourglass§r> <reaplceTileName: Block> [clearContainers: boolean]
${command.dp}idtfill <from: x y z> <to: x y z> <integrity: float> <tileName: Block> [ifillMode: replace|fill|cube|keep|walls|hollow|outline|pillars§c|floor|ceilling|diamond|hourglass§r] [clearContainers: boolean]
${command.dp}idtfill <from: x y z> <to: x y z> <integrity: float> <tileName: Block> [clearContainers: boolean]
${command.dp}idtfill <from: x y z> <to: x y z> <integrity: float> <skygridSize: float> <tileName: Block> <blockStates: block states> <mode: skygrid|inverseskygrid> <replaceTileName: Block> [replaceBlockStates: block states] [clearContainers: boolean]
${command.dp}idtfill <from: x y z> <to: x y z> <integrity: float> <skygridSize: float> <tileName: Block> <blockStates: block states> <mode: skygrid|inverseskygrid> <reaplceTileName: Block> [clearContainers: boolean]
${command.dp}idtfill <from: x y z> <to: x y z> <integrity: float> <skygridSize: float> <tileName: Block> <blockStates: block states> <mode: skygrid|inverseskygrid> [clearContainers: boolean]
${command.dp}idtfill <from: x y z> <to: x y z> <integrity: float> <skygridSize: float> <tileName: Block> <blockStates: block states> <mode: skygrid|inverseskygrid> [clearContainers: boolean]
${command.dp}idtfill <from: x y z> <to: x y z> <integrity: float> <skygridSize: float> <tileName: Block> <mode: skygrid|inverseskygrid> <replaceTileName: Block> [replaceBlockStates: block states] [clearContainers: boolean]
${command.dp}idtfill <from: x y z> <to: x y z> <integrity: float> <skygridSize: float> <tileName: Block> <mode: skygrid|inverseskygrid> <reaplceTileName: Block> [clearContainers: boolean]
${command.dp}idtfill <from: x y z> <to: x y z> <integrity: float> <skygridSize: float> <tileName: Block> <mode: skygrid|inverseskygrid> [clearContainers: boolean]
${command.dp}idtfill <from: x y z> <to: x y z> <integrity: float> <tileName: Block> [clearContainers: boolean]
${command.dp}idtfill <from: x y z> <to: x y z> <integrity: float> clear [clearContainers: boolean]
${command.dp}idtfill <from: x y z> <to: x y z> <integrity: float> drain
${command.dp}idtfill <center: x y z> <integrity: float> <radius: float> <axis: {x}|{y}|{z}|{xy}|{yz}|{xz}|{xyz}> <tileName: Block> <blockStates: block states> circle [replaceTileName: Block] [replaceBlockStates: block states] [clearContainers: boolean]
${command.dp}idtfill <center: x y z> <integrity: float> <radius: float> <axis: {x}|{y}|{z}|{xy}|{yz}|{xz}|{xyz}> <tileName: Block> <blockStates: block states> circle [replaceTileName: Block] [clearContainers: boolean]
${command.dp}idtfill <center: x y z> <integrity: float> <radius: float> <axis: {x}|{y}|{z}|{xy}|{yz}|{xz}|{xyz}> <tileName: Block> <blockStates: block states> circle [clearContainers: boolean]
${command.dp}idtfill <center: x y z> <integrity: float> <radius: float> <axis: {x}|{y}|{z}|{xy}|{yz}|{xz}|{xyz}> <tileName: Block> circle [replaceTileName: Block] [replaceBlockStates: block states] [clearContainers: boolean]
${command.dp}idtfill <center: x y z> <integrity: float> <radius: float> <axis: {x}|{y}|{z}|{xy}|{yz}|{xz}|{xyz}> <tileName: Block> circle [replaceTileName: Block] [clearContainers: boolean]
${command.dp}idtfill <center: x y z> <integrity: float> <radius: float> <axis: {x}|{y}|{z}|{xy}|{yz}|{xz}|{xyz}> <tileName: Block> circle [clearContainers: boolean]
${command.dp}idtfill <center: x y z> <integrity: float> <radius: float> <tileName: Block> <blockStates: block states> <mode: {circlex}|{circley}|{circlez}|{circlexy}|{circleyz}|{circlexyz}|{sphere}|{semisphere}> <replaceTileName: Block> [replaceBlockStates: block states] [clearContainers: boolean]
${command.dp}idtfill <center: x y z> <integrity: float> <radius: float> <tileName: Block> <blockStates: block states> <mode: {circlex}|{circley}|{circlez}|{circlexy}|{circleyz}|{circlexyz}|{sphere}|{semisphere}> <replaceTileName: Block> [clearContainers: boolean]
${command.dp}idtfill <center: x y z> <integrity: float> <radius: float> <tileName: Block> <blockStates: block states> <mode: {circlex}|{circley}|{circlez}|{circlexy}|{circleyz}|{circlexyz}|{sphere}|{semisphere}> [clearContainers: boolean]
${command.dp}idtfill <center: x y z> <integrity: float> <radius: float> <tileName: Block> <mode: {circlex}|{circley}|{circlez}|{circlexy}|{circleyz}|{circlexyz}|{sphere}|{semisphere}> <replaceTileName: Block> [replaceBlockStates: block states] [clearContainers: boolean]
${command.dp}idtfill <center: x y z> <integrity: float> <radius: float> <tileName: Block> <mode: {circlex}|{circley}|{circlez}|{circlexy}|{circleyz}|{circlexyz}|{sphere}|{semisphere}> <replaceTileName: Block> [clearContainers: boolean]
${command.dp}idtfill <center: x y z> <integrity: float> <radius: float> <tileName: Block> <mode: {circlex}|{circley}|{circlez}|{circlexy}|{circleyz}|{circlexyz}|{sphere}|{semisphere}> [clearContainers: boolean]
${command.dp}idtfill <center: x y z> <integrity: float> <radius: float> <thickness: float> <tileName: Block> <blockStates: block states> <mode: hollowsphere|dome> <replaceTileName: Block> [replaceBlockStates: block states] [clearContainers: boolean]
${command.dp}idtfill <center: x y z> <integrity: float> <radius: float> <thickness: float> <tileName: Block> <blockStates: block states> <mode: hollowsphere|dome> <replaceTileName: Block> [clearContainers: boolean]
${command.dp}idtfill <center: x y z> <integrity: float> <radius: float> <thickness: float> <tileName: Block> <blockStates: block states> <mode: hollowsphere|dome> [clearContainers: boolean]
${command.dp}idtfill <center: x y z> <integrity: float> <radius: float> <thickness: float> <tileName: Block> <mode: hollowsphere|dome> <replaceTileName: Block> [replaceBlockStates: block states] [clearContainers: boolean]
${command.dp}idtfill <center: x y z> <integrity: float> <radius: float> <thickness: float> <tileName: Block> <mode: hollowsphere|dome> <replaceTileName: Block> [clearContainers: boolean]
${command.dp}idtfill <center: x y z> <integrity: float> <radius: float> <thickness: float> <tileName: Block> <mode: hollowsphere|dome> [clearContainers: boolean]
${command.dp}idtfill <center: x y z> <integrity: float> <radius: float> <length: float> <tileName: Block> <blockStates: block states> <mode: cylinderx|cylindery|cylinderz|cylinderxy|cylinderyz|cylinderxz|cylinderxyz> <replaceTileName: Block> [replaceBlockStates: block states] [clearContainers: boolean]
${command.dp}idtfill <center: x y z> <integrity: float> <radius: float> <length: float> <tileName: Block> <blockStates: block states> <mode: cylinderx|cylindery|cylinderz|cylinderxy|cylinderyz|cylinderxz|cylinderxyz> <replaceTileName: Block> [clearContainers: boolean]
${command.dp}idtfill <center: x y z> <integrity: float> <radius: float> <length: float> <tileName: Block> <blockStates: block states> <mode: cylinderx|cylindery|cylinderz|cylinderxy|cylinderyz|cylinderxz|cylinderxyz> [clearContainers: boolean]
${command.dp}idtfill <center: x y z> <integrity: float> <radius: float> <length: float> <tileName: Block> <mode: cylinderx|cylindery|cylinderz|cylinderxy|cylinderyz|cylinderxz|cylinderxyz> <replaceTileName: Block> [replaceBlockStates: block states] [clearContainers: boolean]
${command.dp}idtfill <center: x y z> <integrity: float> <radius: float> <length: float> <tileName: Block> <mode: cylinderx|cylindery|cylinderz|cylinderxy|cylinderyz|cylinderxz|cylinderxyz> <replaceTileName: Block> [clearContainers: boolean]
${command.dp}idtfill <center: x y z> <integrity: float> <radius: float> <length: float> <tileName: Block> <mode: cylinderx|cylindery|cylinderz|cylinderxy|cylinderyz|cylinderxz|cylinderxyz> [clearContainers: boolean]
${command.dp}idtfill <center: x y z> <integrity: float> <radius: float> <length: float> <axis: {x}|{y}|{z}|{xy}|{yz}|{xz}|{xyz}> <tileName: Block> <blockStates: block states> <mode: tunnel|cylinder> [replaceTileName: Block] [replaceBlockStates: block states] [clearContainers: boolean]
${command.dp}idtfill <center: x y z> <integrity: float> <radius: float> <length: float> <axis: {x}|{y}|{z}|{xy}|{yz}|{xz}|{xyz}> <tileName: Block> <blockStates: block states> <mode: tunnel|cylinder> [replaceTileName: Block] [clearContainers: boolean]
${command.dp}idtfill <center: x y z> <integrity: float> <radius: float> <length: float> <axis: {x}|{y}|{z}|{xy}|{yz}|{xz}|{xyz}> <tileName: Block> <blockStates: block states> <mode: tunnel|cylinder> [clearContainers: boolean]
${command.dp}idtfill <center: x y z> <integrity: float> <radius: float> <length: float> <axis: {x}|{y}|{z}|{xy}|{yz}|{xz}|{xyz}> <tileName: Block> <mode: tunnel|cylinder> [replaceTileName: Block] [replaceBlockStates: block states] [clearContainers: boolean]
${command.dp}idtfill <center: x y z> <integrity: float> <radius: float> <length: float> <axis: {x}|{y}|{z}|{xy}|{yz}|{xz}|{xyz}> <tileName: Block> <mode: tunnel|cylinder> [replaceTileName: Block] [clearContainers: boolean]
${command.dp}idtfill <center: x y z> <integrity: float> <radius: float> <length: float> <axis: {x}|{y}|{z}|{xy}|{yz}|{xz}|{xyz}> <tileName: Block> <mode: tunnel|cylinder> [clearContainers: boolean]
${command.dp}idtfill <center: x y z> <radius: x y z> <offset: x y z> <integrity: float> <length: float> <tileName: Block> <blockStates: block states> hollowovoid [replaceTileName: Block] [replaceBlockStates: block states] [clearContainers: boolean]
${command.dp}idtfill <center: x y z> <radius: x y z> <offset: x y z> <integrity: float> <length: float> <tileName: Block> <blockStates: block states> hollowovoid [replaceTileName: Block] [clearContainers: boolean]
${command.dp}idtfill <center: x y z> <radius: x y z> <offset: x y z> <integrity: float> <length: float> <tileName: Block> <blockStates: block states> hollowovoid [clearContainers: boolean]
${command.dp}idtfill <center: x y z> <radius: x y z> <offset: x y z> <integrity: float> <length: float> <tileName: Block> hollowovoid [replaceTileName: Block] [replaceBlockStates: block states] [clearContainers: boolean]
${command.dp}idtfill <center: x y z> <radius: x y z> <offset: x y z> <integrity: float> <length: float> <tileName: Block> hollowovoid [replaceTileName: Block] [clearContainers: boolean]
${command.dp}idtfill <center: x y z> <radius: x y z> <offset: x y z> <integrity: float> <length: float> <tileName: Block> hollowovoid [clearContainers: boolean]`);
                    } else {
                        let argsa = evaluateParameters(switchTestB, [
                            "presetText",
                            "Vector",
                            "Vector",
                            "Vector",
                            "Vector",
                            "Vector",
                            "Vector",
                            "number",
                            "string",
                            "blockStates",
                            "presetText",
                            "non-booleanString",
                            "blockStates",
                            "neboolean",
                        ]);
                        let argsb = evaluateParameters(switchTestB, [
                            "presetText",
                            "Vector",
                            "Vector",
                            "Vector",
                            "number",
                            "number",
                            "string",
                            "presetText",
                            "blockStates",
                            "presetText",
                            "non-booleanString",
                            "blockStates",
                            "neboolean",
                        ]);
                        let argsd = evaluateParameters(switchTestB, [
                            "presetText",
                            "Vector",
                            "Vector",
                            "Vector",
                            "number",
                            "number",
                            "string",
                            "blockStates",
                            "presetText",
                            "non-booleanString",
                            "blockStates",
                            "neboolean",
                        ]);
                        let argsf = evaluateParameters(switchTestB, [
                            "presetText",
                            "Vector",
                            "Vector",
                            "Vector",
                            "number",
                            "number",
                            "number",
                            "string",
                            "blockStates",
                            "presetText",
                            "non-booleanString",
                            "blockStates",
                            "neboolean",
                        ]);
                        let argsh = evaluateParameters(switchTestB, [
                            "presetText",
                            "Vector",
                            "Vector",
                            "Vector",
                            "number",
                            "number",
                            "number",
                            "string",
                            "string",
                            "blockStates",
                            "presetText",
                            "non-booleanString",
                            "blockStates",
                            "neboolean",
                        ]);
                        let argsj = evaluateParameters(switchTestB, [
                            "presetText",
                            "Vector",
                            "Vector",
                            "Vector",
                            "Vector",
                            "Vector",
                            "Vector",
                            "Vector",
                            "Vector",
                            "Vector",
                            "number",
                            "number",
                            "string",
                            "blockStates",
                            "presetText",
                            "non-booleanString",
                            "blockStates",
                            "neboolean",
                        ]);
                        let argsl = evaluateParameters(switchTestB, [
                            "presetText",
                            "Vector",
                            "Vector",
                            "Vector",
                            "Vector",
                            "Vector",
                            "Vector",
                            "Vector",
                            "Vector",
                            "Vector",
                            "number",
                            "string",
                            "blockStates",
                            "presetText",
                            "non-booleanString",
                            "blockStates",
                            "neboolean",
                        ]);
                        let argsn = evaluateParameters(switchTestB, [
                            "presetText",
                            "Vector",
                            "Vector",
                            "Vector",
                            "Vector",
                            "Vector",
                            "Vector",
                            "number",
                            "number",
                            "string",
                            "blockStates",
                            "presetText",
                            "non-booleanString",
                            "blockStates",
                            "neboolean",
                        ]);
                        //console.warn(argsh.args)
                        let args = argsa.args;
                        let argsc = argsb.args;
                        let argse = argsd.args;
                        let argsg = argsf.args;
                        let argsi = argsh.args;
                        let argsk = argsj.args;
                        let argsm = argsl.args;
                        let argso = argsn.args;
                        let argsaextra = argsa.extra;
                        let argsbextra = argsb.extra;
                        let argsdextra = argsd.extra;
                        let argsfextra = argsf.extra;
                        let argshextra = argsh.extra;
                        let argsjextra = argsj.extra;
                        let argslextra = argsl.extra;
                        let argsnextra = argsn.extra;
                        //console.warn(JSONStringify(args), JSONStringify(argsaextra))
                        let center = evaluateCoordinates(
                            argsc[1],
                            argsc[2],
                            argsc[3],
                            roundVector3ToMiddleOfBlock(player.location),
                            player.getRotation()
                        );
                        let cintegrity = argsc[4];
                        let radius = argsc[5];
                        let axis = argsc[6];
                        let cfirstblockname = argsc[7];
                        let cfirstblockstates = argsc[8];
                        let cmode = argsc[9] as string;
                        let clastblockname = argsc[10];
                        let clastblockstates = argsc[11];
                        let creplacemode = argsc[12] ?? false;
                        let ccfirstblockname = argse[6];
                        let ccfirstblockstates = argse[7];
                        let ccmode = argse[8] as string;
                        let cclastblockname = argse[9];
                        let cclastblockstates = argse[10];
                        let ccreplacemode = argse[11] ?? false;
                        let thickness = argsg[6];
                        let hsfirstblockname = argsg[7];
                        let hsfirstblockstates = argsg[8];
                        let hsmode = argsg[9] as string;
                        let hslastblockname = argsg[10];
                        let hslastblockstates = argsg[11];
                        let hsreplacemode = argsg[12] ?? false;
                        let tintegrity = argsi[4];
                        let taxis = argsi[7];
                        let tfirstblockname = argsi[8];
                        let tfirstblockstates = argsi[9];
                        let tmode = argsi[10] as string;
                        let tlastblockname = argsi[11];
                        let tlastblockstates = argsi[12];
                        let treplacemode = argsi[13] ?? false;
                        let sgskygridsize = argso[8];
                        let sgfirstblockname = argso[9];
                        let sgfirstblockstates = argso[10];
                        let sgmode = argso[11] as string;
                        let sglastblockname = argso[12];
                        let sglastblockstates = argso[13];
                        let sgreplacemode = argso[14] ?? false;
                        let circlemode = false;
                        new Date(Date.now()).getMilliseconds();
                        let ccirclemode = false;
                        let hspheremode = false;
                        let tunnelmode = false;
                        let ovoidmode = false;
                        let hovoidmode = false;
                        let skygridmode = false;
                        if (["circle"].includes(
                            fillmodetypeenum[argsc[9] ??
                            "undefined"?.toLowerCase()?.trim()]
                        )) {
                            circlemode = true;
                        }
                        if ([
                            "circlex",
                            "circley",
                            "circlez",
                            "circlexy",
                            "circleyz",
                            "circlexz",
                            "circlexyz",
                            "sphere",
                            "semisphere",
                        ].includes(
                            fillmodetypeenum[argse[8] ??
                            "undefined"?.toLowerCase()?.trim()]
                        )) {
                            ccirclemode = true;
                        }
                        if ([
                            "hollowsphere",
                            "cylinderx",
                            "cylindery",
                            "cylinderz",
                            "cylinderxy",
                            "cylinderyz",
                            "cylinderxz",
                            "cylinderxyz",
                            "dome",
                        ].includes(
                            fillmodetypeenum[argsg[9] ??
                            "undefined"?.toLowerCase()?.trim()]
                        )) {
                            hspheremode = true;
                        }
                        if (["tunnel", "cylinder"].includes(
                            fillmodetypeenum[argsi[10] ??
                            "undefined"?.toLowerCase()?.trim()]
                        )) {
                            tunnelmode = true;
                        }
                        if (["ovoid"].includes(
                            fillmodetypeenum[argsm[13] ??
                            "undefined"?.toLowerCase()?.trim()]
                        )) {
                            ovoidmode = true;
                        }
                        if (["hollowovoid"].includes(
                            fillmodetypeenum[argsk[14] ??
                            "undefined"?.toLowerCase()?.trim()]
                        )) {
                            hovoidmode = true;
                        }
                        if (["skygrid", "inverseskygrid"].includes(
                            fillmodetypeenum[argso[11] ??
                            "undefined"?.toLowerCase()?.trim()]
                        )) {
                            skygridmode = true;
                        }
                        let coordinatesa: Vector3; /*
            console.warn(circlemode, ccirclemode, hspheremode)*/

                        if (!circlemode &&
                            !ccirclemode &&
                            !hspheremode &&
                            !tunnelmode) {
                            coordinatesa = evaluateCoordinates(
                                args[1],
                                args[2],
                                args[3],
                                roundVector3ToMiddleOfBlock(player.location),
                                player.getRotation()
                            );
                        }
                        let coordinatesb: Vector3;
                        if (!circlemode &&
                            !ccirclemode &&
                            !hspheremode &&
                            !tunnelmode) {
                            coordinatesb = evaluateCoordinates(
                                args[4],
                                args[5],
                                args[6],
                                roundVector3ToMiddleOfBlock(player.location),
                                player.getRotation()
                            );
                        }
                        let horadi: Vector3;
                        let hooffset: Vector3;
                        let hointegrity = argsk[10];
                        let hothickness = argsk[11];
                        let hofirstblockname = argsk[12];
                        let hofirstblockstates = argsk[13];
                        let homode = argsk[14] as string;
                        let holastblockname = argsk[15];
                        let holastblockstates = argsk[16];
                        let horeplacemode = argsk[17] ?? false;
                        if (hovoidmode) {
                            horadi = evaluateCoordinates(
                                argsk[4],
                                argsk[5],
                                argsk[6],
                                roundVector3ToMiddleOfBlock(player.location),
                                player.getRotation()
                            );
                            hooffset = evaluateCoordinates(
                                argsk[7],
                                argsk[8],
                                argsk[9],
                                roundVector3ToMiddleOfBlock(player.location),
                                player.getRotation()
                            );
                        }
                        let oradi: Vector3;
                        let ooffset: Vector3;
                        let ointegrity = argsk[10];
                        let ofirstblockname = argsm[11];
                        let ofirstblockstates = argsm[12];
                        let omode = argsm[13] as string;
                        let olastblockname = argsm[14];
                        let olastblockstates = argsm[15];
                        let oreplacemode = argsm[16] ?? false;
                        if (ovoidmode) {
                            oradi = evaluateCoordinates(
                                argsm[4],
                                argsm[5],
                                argsm[6],
                                roundVector3ToMiddleOfBlock(player.location),
                                player.getRotation()
                            );
                            ooffset = evaluateCoordinates(
                                argsm[7],
                                argsm[8],
                                argsm[9],
                                roundVector3ToMiddleOfBlock(player.location),
                                player.getRotation()
                            );
                        }
                        let integrity = args[7];
                        let firstblockname = args[8];
                        let firstblockstates = args[9];
                        let mode = args[10] as string;
                        let lastblockname = args[11];
                        let lastblockstates = args[12];
                        let replacemode = args[13] ?? false;
                        let matchingblock = (
                            (lastblockname ?? "") == ""
                                ? [undefined, undefined]
                                : lastblockname == "keep" || mode == "keep"
                                    ? ["air"]
                                    : [
                                        BlockTypes.get(lastblockname).id,
                                        lastblockstates,
                                    ]
                        ) as [
                                string,
                                { [id: string]: string | number | boolean; }
                            ];
                        let cmatchingblock = (
                            (clastblockname ?? "") == ""
                                ? [undefined, undefined]
                                : clastblockname == "keep"
                                    ? ["air"]
                                    : [clastblockname, clastblockstates]
                        ) as [
                                string,
                                { [id: string]: string | number | boolean; }
                            ];
                        let ccmatchingblock = (
                            (cclastblockname ?? "") == ""
                                ? [undefined, undefined]
                                : cclastblockname == "keep"
                                    ? ["air"]
                                    : [cclastblockname, cclastblockstates]
                        ) as [
                                string,
                                { [id: string]: string | number | boolean; }
                            ];
                        let hsmatchingblock = (
                            (hslastblockname ?? "") == ""
                                ? [undefined, undefined]
                                : hslastblockname == "keep"
                                    ? ["air"]
                                    : [hslastblockname, hslastblockstates]
                        ) as [
                                string,
                                { [id: string]: string | number | boolean; }
                            ];
                        let tmatchingblock = (
                            (tlastblockname ?? "") == ""
                                ? [undefined, undefined]
                                : tlastblockname == "keep"
                                    ? ["air"]
                                    : [tlastblockname, tlastblockstates]
                        ) as [
                                string,
                                { [id: string]: string | number | boolean; }
                            ];
                        let omatchingblock = (
                            (olastblockname ?? "") == ""
                                ? [undefined, undefined]
                                : olastblockname == "keep"
                                    ? ["air"]
                                    : [olastblockname, olastblockstates]
                        ) as [
                                string,
                                { [id: string]: string | number | boolean; }
                            ];
                        let homatchingblock = (
                            (holastblockname ?? "") == ""
                                ? [undefined, undefined]
                                : holastblockname == "keep"
                                    ? ["air"]
                                    : [holastblockname, holastblockstates]
                        ) as [
                                string,
                                { [id: string]: string | number | boolean; }
                            ];
                        let sgmatchingblock = (
                            (sglastblockname ?? "") == ""
                                ? [undefined, undefined]
                                : sglastblockname == "keep"
                                    ? ["air"]
                                    : [sglastblockname, sglastblockstates]
                        ) as [
                                string,
                                { [id: string]: string | number | boolean; }
                            ];
                        const blocktypes = BlockTypes.getAll(); /*
            console.warn(JSONStringify({coordinatesa, coordinatesb, firstblockname, firstblocknameindex, reststringaftercoordinates, firstblockstates, lastblockname, somethingtest, lastblockstates, matchingblock}))*/

                        switch (fillmodetypeenum[skygridmode
                            ? sgmode
                            : hovoidmode
                                ? homode
                                : ovoidmode
                                    ? omode
                                    : tunnelmode
                                        ? tmode
                                        : hspheremode
                                            ? hsmode
                                            : circlemode
                                                ? cmode
                                                : ccirclemode
                                                    ? ccmode
                                                    : mode ?? ""]) {
                            case "":
                                system.run(() => {
                                    let ta: Entity[];
                                    try {
                                        generateTickingAreaFillCoordinatesC(
                                            player.location,
                                            (() => {
                                                let a = new CompoundBlockVolume();
                                                a.pushVolume({
                                                    volume: new BlockVolume(
                                                        coordinatesa,
                                                        coordinatesb
                                                    ),
                                                });
                                                return a;
                                            })(),
                                            player.dimension
                                        ).then((tac) => {
                                            ta = tac;
                                            try {
                                                fillBlocksHFG(
                                                    coordinatesa,
                                                    coordinatesb,
                                                    player.dimension,
                                                    firstblockname == "random"
                                                        ? () => blocktypes[Math.floor(
                                                            blocktypes.length *
                                                            Math.random()
                                                        )]
                                                        : firstblockname,
                                                    firstblockstates,
                                                    {
                                                        matchingBlock: matchingblock[0],
                                                        matchingBlockStates: matchingblock[1],
                                                        minMSBetweenYields: 5000,
                                                    },
                                                    undefined,
                                                    replacemode,
                                                    integrity
                                                ).then(
                                                    (a) => {
                                                        player.sendMessageB(
                                                            `${a.counter == 0
                                                                ? "§c"
                                                                : ""}${a.counter} blocks filled in ${a.completionData
                                                                .endTime -
                                                            a.completionData
                                                                .startTime} ms over ${a.completionData
                                                                .endTick -
                                                            a.completionData
                                                                .startTick} tick${a.completionData
                                                                .endTick -
                                                                a
                                                                    .completionData
                                                                    .startTick ==
                                                                1
                                                                ? ""
                                                                : "s"}${a.completionData
                                                                .containsUnloadedChunks
                                                                ? "; Some blocks were not generated because they were in unloaded chunks. "
                                                                : ""}`
                                                        );
                                                    },
                                                    (e) => {
                                                        player.sendError(
                                                            "§c" + e + e.stack,
                                                            true
                                                        );
                                                    }
                                                );
                                            } catch (e) {
                                                player.sendError(
                                                    "§c" + e + e.stack,
                                                    true
                                                );
                                            } finally {
                                                tac.forEach((tab) => tab?.remove()
                                                );
                                            }
                                        });
                                    } catch (e) {
                                        player.sendError(
                                            "§c" + e + e.stack,
                                            true
                                        );
                                    }
                                });
                                break;
                            case "replace":
                                system.run(() => {
                                    let ta: Entity[];
                                    try {
                                        generateTickingAreaFillCoordinatesC(
                                            player.location,
                                            (() => {
                                                let a = new CompoundBlockVolume();
                                                a.pushVolume({
                                                    volume: new BlockVolume(
                                                        coordinatesa,
                                                        coordinatesb
                                                    ),
                                                });
                                                return a;
                                            })(),
                                            player.dimension
                                        ).then((tac) => {
                                            ta = tac;
                                            try {
                                                fillBlocksHFG(
                                                    coordinatesa,
                                                    coordinatesb,
                                                    player.dimension,
                                                    firstblockname == "random"
                                                        ? () => blocktypes[Math.floor(
                                                            blocktypes.length *
                                                            Math.random()
                                                        )]
                                                        : firstblockname,
                                                    firstblockstates,
                                                    {
                                                        matchingBlock: matchingblock[0],
                                                        matchingBlockStates: matchingblock[1],
                                                        minMSBetweenYields: 5000,
                                                    },
                                                    undefined,
                                                    args[13] ?? true,
                                                    integrity
                                                ).then(
                                                    (a) => {
                                                        player.sendMessageB(
                                                            `${a.counter == 0
                                                                ? "§c"
                                                                : ""}${a.counter} blocks filled in ${a.completionData
                                                                .endTime -
                                                            a.completionData
                                                                .startTime} ms over ${a.completionData
                                                                .endTick -
                                                            a.completionData
                                                                .startTick} tick${a.completionData
                                                                .endTick -
                                                                a
                                                                    .completionData
                                                                    .startTick ==
                                                                1
                                                                ? ""
                                                                : "s"}${a.completionData
                                                                .containsUnloadedChunks
                                                                ? "; Some blocks were not generated because they were in unloaded chunks. "
                                                                : ""}`
                                                        );
                                                    },
                                                    (e) => {
                                                        player.sendError(
                                                            "§c" + e + e.stack,
                                                            true
                                                        );
                                                    }
                                                );
                                            } catch (e) {
                                                player.sendError(
                                                    "§c" + e + e.stack,
                                                    true
                                                );
                                            } finally {
                                                tac.forEach((tab) => tab?.remove()
                                                );
                                            }
                                        });
                                    } catch (e) {
                                        player.sendError(
                                            "§c" + e + e.stack,
                                            true
                                        );
                                    }
                                });
                                break;
                            case "clear":
                                system.run(() => {
                                    let ta: Entity[];
                                    try {
                                        generateTickingAreaFillCoordinatesC(
                                            player.location,
                                            (() => {
                                                let a = new CompoundBlockVolume();
                                                a.pushVolume({
                                                    volume: new BlockVolume(
                                                        coordinatesa,
                                                        coordinatesb
                                                    ),
                                                });
                                                return a;
                                            })(),
                                            player.dimension
                                        ).then((tac) => {
                                            ta = tac;
                                            try {
                                                let startTime = Date.now();
                                                if (replacemode) {
                                                    clearAllContainerBlocks(
                                                        scanForContainerBlocks(
                                                            coordinatesa,
                                                            coordinatesb,
                                                            player.dimension,
                                                            "Block"
                                                        ) as Block[]
                                                    );
                                                }
                                                let a = fillBlocksH(
                                                    coordinatesa,
                                                    coordinatesb,
                                                    player.dimension,
                                                    "air"
                                                );
                                                let endTime = Date.now();
                                                player.sendMessageB(
                                                    `${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`
                                                );
                                            } catch (e) {
                                                player.sendError(
                                                    "§c" + e + e.stack,
                                                    true
                                                );
                                            } finally {
                                                tac.forEach((tab) => tab?.remove()
                                                );
                                            }
                                        });
                                    } catch (e) {
                                        player.sendError(
                                            "§c" + e + e.stack,
                                            true
                                        );
                                    }
                                });
                                break;
                            case "drain":
                                system.run(() => {
                                    let ta: Entity[];
                                    try {
                                        generateTickingAreaFillCoordinatesC(
                                            player.location,
                                            (() => {
                                                let a = new CompoundBlockVolume();
                                                a.pushVolume({
                                                    volume: new BlockVolume(
                                                        coordinatesa,
                                                        coordinatesb
                                                    ),
                                                });
                                                return a;
                                            })(),
                                            player.dimension
                                        ).then((tac) => {
                                            ta = tac;
                                            try {
                                                let startTime = Date.now();
                                                let a = fillBlocksH(
                                                    coordinatesa,
                                                    coordinatesb,
                                                    player.dimension,
                                                    "air",
                                                    undefined,
                                                    { matchingBlock: "water" }
                                                );
                                                let endTime = Date.now();
                                                player.sendMessageB(
                                                    `${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`
                                                );
                                            } catch (e) {
                                                player.sendError(
                                                    "§c" + e + e.stack,
                                                    true
                                                );
                                            } finally {
                                                tac.forEach((tab) => tab?.remove()
                                                );
                                            }
                                        });
                                    } catch (e) {
                                        player.sendError(
                                            "§c" + e + e.stack,
                                            true
                                        );
                                    }
                                });
                                break;
                            case "fill":
                                system.run(() => {
                                    let ta: Entity[];
                                    try {
                                        generateTickingAreaFillCoordinatesC(
                                            player.location,
                                            (() => {
                                                let a = new CompoundBlockVolume();
                                                a.pushVolume({
                                                    volume: new BlockVolume(
                                                        coordinatesa,
                                                        coordinatesb
                                                    ),
                                                });
                                                return a;
                                            })(),
                                            player.dimension
                                        ).then((tac) => {
                                            ta = tac;
                                            try {
                                                fillBlocksHFG(
                                                    coordinatesa,
                                                    coordinatesb,
                                                    player.dimension,
                                                    firstblockname == "random"
                                                        ? () => blocktypes[Math.floor(
                                                            blocktypes.length *
                                                            Math.random()
                                                        )]
                                                        : firstblockname,
                                                    firstblockstates,
                                                    {
                                                        matchingBlock: matchingblock[0],
                                                        matchingBlockStates: matchingblock[1],
                                                        minMSBetweenYields: 5000,
                                                    },
                                                    undefined,
                                                    replacemode,
                                                    integrity
                                                ).then(
                                                    (a) => {
                                                        player.sendMessageB(
                                                            `${a.counter == 0
                                                                ? "§c"
                                                                : ""}${a.counter} blocks filled in ${a.completionData
                                                                .endTime -
                                                            a.completionData
                                                                .startTime} ms over ${a.completionData
                                                                .endTick -
                                                            a.completionData
                                                                .startTick} tick${a.completionData
                                                                .endTick -
                                                                a
                                                                    .completionData
                                                                    .startTick ==
                                                                1
                                                                ? ""
                                                                : "s"}${a.completionData
                                                                .containsUnloadedChunks
                                                                ? "; Some blocks were not generated because they were in unloaded chunks. "
                                                                : ""}`
                                                        );
                                                    },
                                                    (e) => {
                                                        player.sendError(
                                                            "§c" + e + e.stack,
                                                            true
                                                        );
                                                    }
                                                );
                                            } catch (e) {
                                                player.sendError(
                                                    "§c" + e + e.stack,
                                                    true
                                                );
                                            } finally {
                                                tac.forEach((tab) => tab?.remove()
                                                );
                                            }
                                        });
                                    } catch (e) {
                                        player.sendError(
                                            "§c" + e + e.stack,
                                            true
                                        );
                                    }
                                });
                                break;
                            case "keep":
                                system.run(() => {
                                    let ta: Entity[];
                                    try {
                                        generateTickingAreaFillCoordinatesC(
                                            player.location,
                                            (() => {
                                                let a = new CompoundBlockVolume();
                                                a.pushVolume({
                                                    volume: new BlockVolume(
                                                        coordinatesa,
                                                        coordinatesb
                                                    ),
                                                });
                                                return a;
                                            })(),
                                            player.dimension
                                        ).then((tac) => {
                                            ta = tac;
                                            try {
                                                fillBlocksHFG(
                                                    coordinatesa,
                                                    coordinatesb,
                                                    player.dimension,
                                                    firstblockname == "random"
                                                        ? () => blocktypes[Math.floor(
                                                            blocktypes.length *
                                                            Math.random()
                                                        )]
                                                        : firstblockname,
                                                    firstblockstates,
                                                    {
                                                        matchingBlock: "air",
                                                        minMSBetweenYields: 5000,
                                                    },
                                                    undefined,
                                                    replacemode,
                                                    integrity
                                                ).then(
                                                    (a) => {
                                                        player.sendMessageB(
                                                            `${a.counter == 0
                                                                ? "§c"
                                                                : ""}${a.counter} blocks filled in ${a.completionData
                                                                .endTime -
                                                            a.completionData
                                                                .startTime} ms over ${a.completionData
                                                                .endTick -
                                                            a.completionData
                                                                .startTick} tick${a.completionData
                                                                .endTick -
                                                                a
                                                                    .completionData
                                                                    .startTick ==
                                                                1
                                                                ? ""
                                                                : "s"}${a.completionData
                                                                .containsUnloadedChunks
                                                                ? "; Some blocks were not generated because they were in unloaded chunks. "
                                                                : ""}`
                                                        );
                                                    },
                                                    (e) => {
                                                        player.sendError(
                                                            "§c" + e + e.stack,
                                                            true
                                                        );
                                                    }
                                                );
                                            } catch (e) {
                                                player.sendError(
                                                    "§c" + e + e.stack,
                                                    true
                                                );
                                            } finally {
                                                tac.forEach((tab) => tab?.remove()
                                                );
                                            }
                                        });
                                    } catch (e) {
                                        player.sendError(
                                            "§c" + e + e.stack,
                                            true
                                        );
                                    }
                                });
                                break;
                            case "walls":
                                system.run(() => {
                                    let ta: Entity[];
                                    try {
                                        generateTickingAreaFillCoordinatesC(
                                            player.location,
                                            (() => {
                                                let a = new CompoundBlockVolume();
                                                a.pushVolume({
                                                    volume: new BlockVolume(
                                                        coordinatesa,
                                                        coordinatesb
                                                    ),
                                                });
                                                return a;
                                            })(),
                                            player.dimension
                                        ).then((tac) => {
                                            ta = tac;
                                            try {
                                                fillBlocksHWG(
                                                    coordinatesa,
                                                    coordinatesb,
                                                    player.dimension,
                                                    firstblockname == "random"
                                                        ? () => blocktypes[Math.floor(
                                                            blocktypes.length *
                                                            Math.random()
                                                        )]
                                                        : firstblockname,
                                                    firstblockstates,
                                                    {
                                                        matchingBlock: matchingblock[0],
                                                        matchingBlockStates: matchingblock[1],
                                                        minMSBetweenYields: 5000,
                                                    },
                                                    undefined,
                                                    replacemode,
                                                    integrity
                                                ).then(
                                                    (a) => {
                                                        player.sendMessageB(
                                                            `${a.counter == 0
                                                                ? "§c"
                                                                : ""}${a.counter} blocks filled in ${a.completionData
                                                                .endTime -
                                                            a.completionData
                                                                .startTime} ms over ${a.completionData
                                                                .endTick -
                                                            a.completionData
                                                                .startTick} tick${a.completionData
                                                                .endTick -
                                                                a
                                                                    .completionData
                                                                    .startTick ==
                                                                1
                                                                ? ""
                                                                : "s"}${a.completionData
                                                                .containsUnloadedChunks
                                                                ? "; Some blocks were not generated because they were in unloaded chunks. "
                                                                : ""}`
                                                        );
                                                    },
                                                    (e) => {
                                                        player.sendError(
                                                            "§c" + e + e.stack,
                                                            true
                                                        );
                                                    }
                                                );
                                            } catch (e) {
                                                player.sendError(
                                                    "§c" + e + e.stack,
                                                    true
                                                );
                                            } finally {
                                                tac.forEach((tab) => tab?.remove()
                                                );
                                            }
                                        });
                                    } catch (e) {
                                        player.sendError(
                                            "§c" + e + e.stack,
                                            true
                                        );
                                    }
                                });
                                break;
                            case "hollow":
                                system.run(() => {
                                    let ta: Entity[];
                                    try {
                                        generateTickingAreaFillCoordinatesC(
                                            player.location,
                                            (() => {
                                                let a = new CompoundBlockVolume();
                                                a.pushVolume({
                                                    volume: new BlockVolume(
                                                        coordinatesa,
                                                        coordinatesb
                                                    ),
                                                });
                                                return a;
                                            })(),
                                            player.dimension
                                        ).then((tac) => {
                                            ta = tac;
                                            try {
                                                fillBlocksHHG(
                                                    coordinatesa,
                                                    coordinatesb,
                                                    player.dimension,
                                                    firstblockname == "random"
                                                        ? () => blocktypes[Math.floor(
                                                            blocktypes.length *
                                                            Math.random()
                                                        )]
                                                        : firstblockname,
                                                    firstblockstates,
                                                    {
                                                        matchingBlock: matchingblock[0],
                                                        matchingBlockStates: matchingblock[1],
                                                        minMSBetweenYields: 5000,
                                                    },
                                                    undefined,
                                                    replacemode,
                                                    integrity
                                                ).then(
                                                    (a) => {
                                                        player.sendMessageB(
                                                            `${a.counter == 0
                                                                ? "§c"
                                                                : ""}${a.counter} blocks filled in ${a.completionData
                                                                .endTime -
                                                            a.completionData
                                                                .startTime} ms over ${a.completionData
                                                                .endTick -
                                                            a.completionData
                                                                .startTick} tick${a.completionData
                                                                .endTick -
                                                                a
                                                                    .completionData
                                                                    .startTick ==
                                                                1
                                                                ? ""
                                                                : "s"}${a.completionData
                                                                .containsUnloadedChunks
                                                                ? "; Some blocks were not generated because they were in unloaded chunks. "
                                                                : ""}`
                                                        );
                                                    },
                                                    (e) => {
                                                        player.sendError(
                                                            "§c" + e + e.stack,
                                                            true
                                                        );
                                                    }
                                                );
                                            } catch (e) {
                                                player.sendError(
                                                    "§c" + e + e.stack,
                                                    true
                                                );
                                            } finally {
                                                tac.forEach((tab) => tab?.remove()
                                                );
                                            }
                                        });
                                    } catch (e) {
                                        player.sendError(
                                            "§c" + e + e.stack,
                                            true
                                        );
                                    }
                                });
                                break;
                            case "outline":
                                system.run(() => {
                                    let ta: Entity[];
                                    try {
                                        generateTickingAreaFillCoordinatesC(
                                            player.location,
                                            (() => {
                                                let a = new CompoundBlockVolume();
                                                a.pushVolume({
                                                    volume: new BlockVolume(
                                                        coordinatesa,
                                                        coordinatesb
                                                    ),
                                                });
                                                return a;
                                            })(),
                                            player.dimension
                                        ).then((tac) => {
                                            ta = tac;
                                            try {
                                                fillBlocksHOTG(
                                                    coordinatesa,
                                                    coordinatesb,
                                                    player.dimension,
                                                    firstblockname == "random"
                                                        ? () => blocktypes[Math.floor(
                                                            blocktypes.length *
                                                            Math.random()
                                                        )]
                                                        : firstblockname,
                                                    firstblockstates,
                                                    {
                                                        matchingBlock: matchingblock[0],
                                                        matchingBlockStates: matchingblock[1],
                                                        minMSBetweenYields: 5000,
                                                    },
                                                    undefined,
                                                    replacemode,
                                                    integrity
                                                ).then(
                                                    (a) => {
                                                        player.sendMessageB(
                                                            `${a.counter == 0
                                                                ? "§c"
                                                                : ""}${a.counter} blocks filled in ${a.completionData
                                                                .endTime -
                                                            a.completionData
                                                                .startTime} ms over ${a.completionData
                                                                .endTick -
                                                            a.completionData
                                                                .startTick} tick${a.completionData
                                                                .endTick -
                                                                a
                                                                    .completionData
                                                                    .startTick ==
                                                                1
                                                                ? ""
                                                                : "s"}${a.completionData
                                                                .containsUnloadedChunks
                                                                ? "; Some blocks were not generated because they were in unloaded chunks. "
                                                                : ""}`
                                                        );
                                                    },
                                                    (e) => {
                                                        player.sendError(
                                                            "§c" + e + e.stack,
                                                            true
                                                        );
                                                    }
                                                );
                                            } catch (e) {
                                                player.sendError(
                                                    "§c" + e + e.stack,
                                                    true
                                                );
                                            } finally {
                                                tac.forEach((tab) => tab?.remove()
                                                );
                                            }
                                        });
                                    } catch (e) {
                                        player.sendError(
                                            "§c" + e + e.stack,
                                            true
                                        );
                                    }
                                });
                                break;
                            case "pillars":
                                system.run(() => {
                                    let ta: Entity[];
                                    try {
                                        generateTickingAreaFillCoordinatesC(
                                            player.location,
                                            (() => {
                                                let a = new CompoundBlockVolume();
                                                a.pushVolume({
                                                    volume: new BlockVolume(
                                                        coordinatesa,
                                                        coordinatesb
                                                    ),
                                                });
                                                return a;
                                            })(),
                                            player.dimension
                                        ).then((tac) => {
                                            ta = tac;
                                            try {
                                                let startTime = Date.now();
                                                let a = fillBlocksHP(
                                                    coordinatesa,
                                                    coordinatesb,
                                                    player.dimension,
                                                    firstblockname,
                                                    firstblockstates,
                                                    {
                                                        matchingBlock: matchingblock[0],
                                                        matchingBlockStates: matchingblock[1],
                                                    },
                                                    undefined,
                                                    replacemode
                                                );
                                                let endTime = Date.now();
                                                player.sendMessageB(
                                                    `${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`
                                                );
                                            } catch (e) {
                                                player.sendError(
                                                    "§c" + e + e.stack,
                                                    true
                                                );
                                            } finally {
                                                tac.forEach((tab) => tab?.remove()
                                                );
                                            }
                                        });
                                    } catch (e) {
                                        player.sendError(
                                            "§c" + e + e.stack,
                                            true
                                        );
                                    }
                                });
                                break;
                            case "skygrid":
                                system.run(() => {
                                    let ta: Entity[];
                                    try {
                                        generateTickingAreaFillCoordinatesC(
                                            player.location,
                                            (() => {
                                                let a = new CompoundBlockVolume();
                                                a.pushVolume({
                                                    volume: new BlockVolume(
                                                        coordinatesa,
                                                        coordinatesb
                                                    ),
                                                });
                                                return a;
                                            })(),
                                            player.dimension
                                        ).then((tac) => {
                                            ta = tac;
                                            try {
                                                fillBlocksHSGG(
                                                    coordinatesa,
                                                    coordinatesb,
                                                    sgskygridsize,
                                                    player.dimension,
                                                    sgfirstblockname,
                                                    sgfirstblockstates,
                                                    {
                                                        matchingBlock: sgmatchingblock[0],
                                                        matchingBlockStates: sgmatchingblock[1],
                                                        minMSBetweenYields: 5000,
                                                    },
                                                    undefined,
                                                    sgreplacemode,
                                                    integrity
                                                ).then(
                                                    (a) => {
                                                        player.sendMessageB(
                                                            `${a.counter == 0
                                                                ? "§c"
                                                                : ""}${a.counter} blocks filled in ${a.completionData
                                                                .endTime -
                                                            a.completionData
                                                                .startTime} ms over ${a.completionData
                                                                .endTick -
                                                            a.completionData
                                                                .startTick} tick${a.completionData
                                                                .endTick -
                                                                a
                                                                    .completionData
                                                                    .startTick ==
                                                                1
                                                                ? ""
                                                                : "s"}${a.completionData
                                                                .containsUnloadedChunks
                                                                ? "; Some blocks were not generated because they were in unloaded chunks. "
                                                                : ""}`
                                                        );
                                                    },
                                                    (e) => {
                                                        player.sendError(
                                                            "§c" + e + e.stack,
                                                            true
                                                        );
                                                    }
                                                );
                                            } catch (e) {
                                                player.sendError(
                                                    "§c" + e + e.stack,
                                                    true
                                                );
                                            } finally {
                                                tac.forEach((tab) => tab?.remove()
                                                );
                                            }
                                        });
                                    } catch (e) {
                                        player.sendError(
                                            "§c" + e + e.stack,
                                            true
                                        );
                                    }
                                });
                                break;
                            case "inverseskygrid":
                                system.run(() => {
                                    let ta: Entity[];
                                    try {
                                        generateTickingAreaFillCoordinatesC(
                                            player.location,
                                            (() => {
                                                let a = new CompoundBlockVolume();
                                                a.pushVolume({
                                                    volume: new BlockVolume(
                                                        coordinatesa,
                                                        coordinatesb
                                                    ),
                                                });
                                                return a;
                                            })(),
                                            player.dimension
                                        ).then((tac) => {
                                            ta = tac;
                                            try {
                                                fillBlocksHISGG(
                                                    coordinatesa,
                                                    coordinatesb,
                                                    sgskygridsize,
                                                    player.dimension,
                                                    sgfirstblockname,
                                                    sgfirstblockstates,
                                                    {
                                                        matchingBlock: sgmatchingblock[0],
                                                        matchingBlockStates: sgmatchingblock[1],
                                                        minMSBetweenYields: 5000,
                                                    },
                                                    undefined,
                                                    sgreplacemode,
                                                    integrity
                                                ).then(
                                                    (a) => {
                                                        player.sendMessageB(
                                                            `${a.counter == 0
                                                                ? "§c"
                                                                : ""}${a.counter} blocks filled in ${a.completionData
                                                                .endTime -
                                                            a.completionData
                                                                .startTime} ms over ${a.completionData
                                                                .endTick -
                                                            a.completionData
                                                                .startTick} tick${a.completionData
                                                                .endTick -
                                                                a
                                                                    .completionData
                                                                    .startTick ==
                                                                1
                                                                ? ""
                                                                : "s"}${a.completionData
                                                                .containsUnloadedChunks
                                                                ? "; Some blocks were not generated because they were in unloaded chunks. "
                                                                : ""}`
                                                        );
                                                    },
                                                    (e) => {
                                                        player.sendError(
                                                            "§c" + e + e.stack,
                                                            true
                                                        );
                                                    }
                                                );
                                            } catch (e) {
                                                player.sendError(
                                                    "§c" + e + e.stack,
                                                    true
                                                );
                                            } finally {
                                                tac.forEach((tab) => tab?.remove()
                                                );
                                            }
                                        });
                                    } catch (e) {
                                        player.sendError(
                                            "§c" + e + e.stack,
                                            true
                                        );
                                    }
                                });
                                break;
                            case "tunnel":
                                player.sendMessageB("§eComing Soon! ");
                                break;
                            case "floor":
                                player.sendMessageB("§eComing Soon! ");
                                break;
                            case "ceilling":
                                player.sendMessageB("§eComing Soon! ");
                                break;
                            case "diamond":
                                player.sendMessageB("§eComing Soon! ");
                                break;
                            case "hollowovoid":
                                system.run(() => {
                                    let ta: Entity;
                                    try {
                                        player.dimension.runCommand(
                                            "summon andexdb:tickingarea_6 itwalls " +
                                            vTStr(center)
                                        );
                                        ta = player.dimension
                                            .getEntitiesAtBlockLocation(center)
                                            .find(
                                                (v) => v.typeId ==
                                                    "andexdb:tickingarea_6"
                                            );
                                        /*console.warn(ta, location); */ system.runTimeout(
                                                () => {
                                                    try {
                                                        fillBlocksHHOG(
                                                            center,
                                                            vTV3(
                                                                Vector3Utils.subtract(
                                                                    horadi,
                                                                    {
                                                                        x: -0.5,
                                                                        y: -0.5,
                                                                        z: -0.5,
                                                                    }
                                                                )
                                                            ),
                                                            hooffset,
                                                            hothickness,
                                                            player.dimension,
                                                            hofirstblockname,
                                                            hofirstblockstates,
                                                            {
                                                                matchingBlock: homatchingblock[0],
                                                                matchingBlockStates: homatchingblock[1],
                                                                minMSBetweenYields: 5000,
                                                            },
                                                            undefined,
                                                            horeplacemode,
                                                            hointegrity
                                                        ).then(
                                                            (a) => {
                                                                player.sendMessageB(
                                                                    `${a.counter ==
                                                                        0
                                                                        ? "§c"
                                                                        : ""}${a.counter} blocks filled in ${a
                                                                        .completionData
                                                                        .endTime -
                                                                    a
                                                                        .completionData
                                                                        .startTime} ms over ${a
                                                                        .completionData
                                                                        .endTick -
                                                                    a
                                                                        .completionData
                                                                        .startTick} tick${a
                                                                        .completionData
                                                                        .endTick -
                                                                        a
                                                                            .completionData
                                                                            .startTick ==
                                                                        1
                                                                        ? ""
                                                                        : "s"}${a
                                                                        .completionData
                                                                        .containsUnloadedChunks
                                                                        ? "; Some blocks were not generated because they were in unloaded chunks. "
                                                                        : ""}`
                                                                );
                                                            },
                                                            (e) => {
                                                                player.sendError(
                                                                    "§c" +
                                                                    e +
                                                                    e.stack,
                                                                    true
                                                                );
                                                            }
                                                        );
                                                    } catch (e) {
                                                        player.sendError(
                                                            "§c" + e + e.stack,
                                                            true
                                                        );
                                                    } finally {
                                                        ta?.remove();
                                                    }
                                                },
                                                2
                                            );
                                    } catch (e) {
                                        player.sendError(
                                            "§c" + e + e.stack,
                                            true
                                        );
                                    }
                                });
                                break;
                            case "ovoid":
                                system.run(() => {
                                    let ta: Entity;
                                    try {
                                        player.dimension.runCommand(
                                            "summon andexdb:tickingarea_6 itwalls " +
                                            vTStr(center)
                                        );
                                        ta = player.dimension
                                            .getEntitiesAtBlockLocation(center)
                                            .find(
                                                (v) => v.typeId ==
                                                    "andexdb:tickingarea_6"
                                            );
                                        /*console.warn(ta, location); */ system.runTimeout(
                                                () => {
                                                    try {
                                                        fillBlocksHOG(
                                                            center,
                                                            vTV3(
                                                                Vector3Utils.subtract(
                                                                    oradi,
                                                                    {
                                                                        x: -0.5,
                                                                        y: -0.5,
                                                                        z: -0.5,
                                                                    }
                                                                )
                                                            ),
                                                            ooffset,
                                                            player.dimension,
                                                            ofirstblockname,
                                                            ofirstblockstates,
                                                            {
                                                                matchingBlock: omatchingblock[0],
                                                                matchingBlockStates: omatchingblock[1],
                                                                minMSBetweenYields: 5000,
                                                            },
                                                            undefined,
                                                            oreplacemode,
                                                            ointegrity
                                                        ).then(
                                                            (a) => {
                                                                player.sendMessageB(
                                                                    `${a.counter ==
                                                                        0
                                                                        ? "§c"
                                                                        : ""}${a.counter} blocks filled in ${a
                                                                        .completionData
                                                                        .endTime -
                                                                    a
                                                                        .completionData
                                                                        .startTime} ms over ${a
                                                                        .completionData
                                                                        .endTick -
                                                                    a
                                                                        .completionData
                                                                        .startTick} tick${a
                                                                        .completionData
                                                                        .endTick -
                                                                        a
                                                                            .completionData
                                                                            .startTick ==
                                                                        1
                                                                        ? ""
                                                                        : "s"}${a
                                                                        .completionData
                                                                        .containsUnloadedChunks
                                                                        ? "; Some blocks were not generated because they were in unloaded chunks. "
                                                                        : ""}`
                                                                );
                                                            },
                                                            (e) => {
                                                                player.sendError(
                                                                    "§c" +
                                                                    e +
                                                                    e.stack,
                                                                    true
                                                                );
                                                            }
                                                        );
                                                    } catch (e) {
                                                        player.sendError(
                                                            "§c" + e + e.stack,
                                                            true
                                                        );
                                                    } finally {
                                                        ta?.remove();
                                                    }
                                                },
                                                2
                                            );
                                    } catch (e) {
                                        player.sendError(
                                            "§c" + e + e.stack,
                                            true
                                        );
                                    }
                                });
                                break;
                            case "hollowsphere":
                                system.run(() => {
                                    let ta: Entity;
                                    try {
                                        player.dimension.runCommand(
                                            "summon andexdb:tickingarea_6 itwalls " +
                                            vTStr(center)
                                        );
                                        ta = player.dimension
                                            .getEntitiesAtBlockLocation(center)
                                            .find(
                                                (v) => v.typeId ==
                                                    "andexdb:tickingarea_6"
                                            );
                                        /*console.warn(ta, location); */ system.runTimeout(
                                                () => {
                                                    try {
                                                        fillBlocksHHSG(
                                                            center,
                                                            radius - 0.5,
                                                            thickness,
                                                            player.dimension,
                                                            hsfirstblockname,
                                                            hsfirstblockstates,
                                                            {
                                                                matchingBlock: hsmatchingblock[0],
                                                                matchingBlockStates: hsmatchingblock[1],
                                                                minMSBetweenYields: 5000,
                                                            },
                                                            undefined,
                                                            hsreplacemode,
                                                            cintegrity
                                                        ).then(
                                                            (a) => {
                                                                player.sendMessageB(
                                                                    `${a.counter ==
                                                                        0
                                                                        ? "§c"
                                                                        : ""}${a.counter} blocks filled in ${a
                                                                        .completionData
                                                                        .endTime -
                                                                    a
                                                                        .completionData
                                                                        .startTime} ms over ${a
                                                                        .completionData
                                                                        .endTick -
                                                                    a
                                                                        .completionData
                                                                        .startTick} tick${a
                                                                        .completionData
                                                                        .endTick -
                                                                        a
                                                                            .completionData
                                                                            .startTick ==
                                                                        1
                                                                        ? ""
                                                                        : "s"}${a
                                                                        .completionData
                                                                        .containsUnloadedChunks
                                                                        ? "; Some blocks were not generated because they were in unloaded chunks. "
                                                                        : ""}`
                                                                );
                                                            },
                                                            (e) => {
                                                                player.sendError(
                                                                    "§c" +
                                                                    e +
                                                                    e.stack,
                                                                    true
                                                                );
                                                            }
                                                        );
                                                    } catch (e) {
                                                        player.sendError(
                                                            "§c" + e + e.stack,
                                                            true
                                                        );
                                                    } finally {
                                                        ta?.remove();
                                                    }
                                                },
                                                2
                                            );
                                    } catch (e) {
                                        player.sendError(
                                            "§c" + e + e.stack,
                                            true
                                        );
                                    }
                                });
                                break;
                            case "dome":
                                system.run(() => {
                                    let ta: Entity;
                                    try {
                                        player.dimension.runCommand(
                                            "summon andexdb:tickingarea_6 itwalls " +
                                            vTStr(center)
                                        );
                                        ta = player.dimension
                                            .getEntitiesAtBlockLocation(center)
                                            .find(
                                                (v) => v.typeId ==
                                                    "andexdb:tickingarea_6"
                                            );
                                        /*console.warn(ta, location); */ system.runTimeout(
                                                () => {
                                                    try {
                                                        fillBlocksHDG(
                                                            center,
                                                            radius - 0.5,
                                                            thickness,
                                                            player.dimension,
                                                            hsfirstblockname,
                                                            hsfirstblockstates,
                                                            {
                                                                matchingBlock: hsmatchingblock[0],
                                                                matchingBlockStates: hsmatchingblock[1],
                                                                minMSBetweenYields: 5000,
                                                            },
                                                            undefined,
                                                            hsreplacemode,
                                                            cintegrity
                                                        ).then(
                                                            (a) => {
                                                                player.sendMessageB(
                                                                    `${a.counter ==
                                                                        0
                                                                        ? "§c"
                                                                        : ""}${a.counter} blocks filled in ${a
                                                                        .completionData
                                                                        .endTime -
                                                                    a
                                                                        .completionData
                                                                        .startTime} ms over ${a
                                                                        .completionData
                                                                        .endTick -
                                                                    a
                                                                        .completionData
                                                                        .startTick} tick${a
                                                                        .completionData
                                                                        .endTick -
                                                                        a
                                                                            .completionData
                                                                            .startTick ==
                                                                        1
                                                                        ? ""
                                                                        : "s"}${a
                                                                        .completionData
                                                                        .containsUnloadedChunks
                                                                        ? "; Some blocks were not generated because they were in unloaded chunks. "
                                                                        : ""}`
                                                                );
                                                            },
                                                            (e) => {
                                                                player.sendError(
                                                                    "§c" +
                                                                    e +
                                                                    e.stack,
                                                                    true
                                                                );
                                                            }
                                                        );
                                                    } catch (e) {
                                                        player.sendError(
                                                            "§c" + e + e.stack,
                                                            true
                                                        );
                                                    } finally {
                                                        ta?.remove();
                                                    }
                                                },
                                                2
                                            );
                                    } catch (e) {
                                        player.sendError(
                                            "§c" + e + e.stack,
                                            true
                                        );
                                    }
                                });
                                break;
                            case "sphere":
                                system.run(() => {
                                    let ta: Entity;
                                    try {
                                        player.dimension.runCommand(
                                            "summon andexdb:tickingarea_6 itwalls " +
                                            vTStr(center)
                                        );
                                        ta = player.dimension
                                            .getEntitiesAtBlockLocation(center)
                                            .find(
                                                (v) => v.typeId ==
                                                    "andexdb:tickingarea_6"
                                            );
                                        /*console.warn(ta, location); */ system.runTimeout(
                                                () => {
                                                    try {
                                                        fillBlocksHSG(
                                                            center,
                                                            radius - 0.5,
                                                            player.dimension,
                                                            ccfirstblockname,
                                                            ccfirstblockstates,
                                                            {
                                                                matchingBlock: ccmatchingblock[0],
                                                                matchingBlockStates: ccmatchingblock[1],
                                                                minMSBetweenYields: 5000,
                                                            },
                                                            undefined,
                                                            ccreplacemode,
                                                            cintegrity
                                                        ).then(
                                                            (a) => {
                                                                player.sendMessageB(
                                                                    `${a.counter ==
                                                                        0
                                                                        ? "§c"
                                                                        : ""}${a.counter} blocks filled in ${a
                                                                        .completionData
                                                                        .endTime -
                                                                    a
                                                                        .completionData
                                                                        .startTime} ms over ${a
                                                                        .completionData
                                                                        .endTick -
                                                                    a
                                                                        .completionData
                                                                        .startTick} tick${a
                                                                        .completionData
                                                                        .endTick -
                                                                        a
                                                                            .completionData
                                                                            .startTick ==
                                                                        1
                                                                        ? ""
                                                                        : "s"}`
                                                                );
                                                            },
                                                            (e) => {
                                                                player.sendError(
                                                                    "§c" +
                                                                    e +
                                                                    e.stack,
                                                                    true
                                                                );
                                                            }
                                                        );
                                                    } catch (e) {
                                                        player.sendError(
                                                            "§c" + e + e.stack,
                                                            true
                                                        );
                                                    } finally {
                                                        ta?.remove();
                                                    }
                                                },
                                                2
                                            );
                                    } catch (e) {
                                        player.sendError(
                                            "§c" + e + e.stack,
                                            true
                                        );
                                    }
                                });
                                break;
                            case "semisphere":
                                system.run(() => {
                                    let ta: Entity;
                                    try {
                                        player.dimension.runCommand(
                                            "summon andexdb:tickingarea_6 itwalls " +
                                            vTStr(center)
                                        );
                                        ta = player.dimension
                                            .getEntitiesAtBlockLocation(center)
                                            .find(
                                                (v) => v.typeId ==
                                                    "andexdb:tickingarea_6"
                                            );
                                        /*console.warn(ta, location); */ system.runTimeout(
                                                () => {
                                                    try {
                                                        fillBlocksHSSG(
                                                            center,
                                                            radius - 0.5,
                                                            player.dimension,
                                                            ccfirstblockname,
                                                            ccfirstblockstates,
                                                            {
                                                                matchingBlock: ccmatchingblock[0],
                                                                matchingBlockStates: ccmatchingblock[1],
                                                                minMSBetweenYields: 5000,
                                                            },
                                                            undefined,
                                                            ccreplacemode,
                                                            cintegrity
                                                        ).then(
                                                            (a) => {
                                                                player.sendMessageB(
                                                                    `${a.counter ==
                                                                        0
                                                                        ? "§c"
                                                                        : ""}${a.counter} blocks filled in ${a
                                                                        .completionData
                                                                        .endTime -
                                                                    a
                                                                        .completionData
                                                                        .startTime} ms over ${a
                                                                        .completionData
                                                                        .endTick -
                                                                    a
                                                                        .completionData
                                                                        .startTick} tick${a
                                                                        .completionData
                                                                        .endTick -
                                                                        a
                                                                            .completionData
                                                                            .startTick ==
                                                                        1
                                                                        ? ""
                                                                        : "s"}`
                                                                );
                                                            },
                                                            (e) => {
                                                                player.sendError(
                                                                    "§c" +
                                                                    e +
                                                                    e.stack,
                                                                    true
                                                                );
                                                            }
                                                        );
                                                    } catch (e) {
                                                        player.sendError(
                                                            "§c" + e + e.stack,
                                                            true
                                                        );
                                                    } finally {
                                                        ta?.remove();
                                                    }
                                                },
                                                2
                                            );
                                    } catch (e) {
                                        player.sendError(
                                            "§c" + e + e.stack,
                                            true
                                        );
                                    }
                                });
                                break;
                            case "circle":
                                system.run(() => {
                                    let ta: Entity;
                                    try {
                                        player.dimension.runCommand(
                                            "summon andexdb:tickingarea_6 itwalls " +
                                            vTStr(center)
                                        );
                                        ta = player.dimension
                                            .getEntitiesAtBlockLocation(center)
                                            .find(
                                                (v) => v.typeId ==
                                                    "andexdb:tickingarea_6"
                                            );
                                        /*console.warn(ta, location); */ system.runTimeout(
                                                () => {
                                                    try {
                                                        let startTime = Date.now();
                                                        let a = fillBlocksHC(
                                                            center,
                                                            radius,
                                                            player.dimension,
                                                            axis,
                                                            cfirstblockname,
                                                            cfirstblockstates,
                                                            {
                                                                matchingBlock: cmatchingblock[0],
                                                                matchingBlockStates: cmatchingblock[1],
                                                            },
                                                            undefined,
                                                            creplacemode
                                                        );
                                                        let endTime = Date.now();
                                                        player.sendMessageB(
                                                            `${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`
                                                        );
                                                    } catch (e) {
                                                        player.sendError(
                                                            "§c" + e + e.stack,
                                                            true
                                                        );
                                                    } finally {
                                                        ta?.remove();
                                                    }
                                                },
                                                2
                                            );
                                    } catch (e) {
                                        player.sendError(
                                            "§c" + e + e.stack,
                                            true
                                        );
                                    }
                                });
                                break;
                            case "circlex":
                                system.run(() => {
                                    let ta: Entity;
                                    try {
                                        player.dimension.runCommand(
                                            "summon andexdb:tickingarea_6 itwalls " +
                                            vTStr(center)
                                        );
                                        ta = player.dimension
                                            .getEntitiesAtBlockLocation(center)
                                            .find(
                                                (v) => v.typeId ==
                                                    "andexdb:tickingarea_6"
                                            );
                                        /*console.warn(ta, location); */ system.runTimeout(
                                                () => {
                                                    try {
                                                        let startTime = Date.now();
                                                        let a = fillBlocksHC(
                                                            center,
                                                            radius,
                                                            player.dimension,
                                                            "x",
                                                            ccfirstblockname,
                                                            ccfirstblockstates,
                                                            {
                                                                matchingBlock: ccmatchingblock[0],
                                                                matchingBlockStates: ccmatchingblock[1],
                                                            },
                                                            undefined,
                                                            ccreplacemode
                                                        );
                                                        let endTime = Date.now();
                                                        player.sendMessageB(
                                                            `${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`
                                                        );
                                                    } catch (e) {
                                                        player.sendError(
                                                            "§c" + e + e.stack,
                                                            true
                                                        );
                                                    } finally {
                                                        ta?.remove();
                                                    }
                                                },
                                                2
                                            );
                                    } catch (e) {
                                        player.sendError(
                                            "§c" + e + e.stack,
                                            true
                                        );
                                    }
                                });
                                break;
                            case "circley":
                                system.run(() => {
                                    let ta: Entity;
                                    try {
                                        player.dimension.runCommand(
                                            "summon andexdb:tickingarea_6 itwalls " +
                                            vTStr(center)
                                        );
                                        ta = player.dimension
                                            .getEntitiesAtBlockLocation(center)
                                            .find(
                                                (v) => v.typeId ==
                                                    "andexdb:tickingarea_6"
                                            );
                                        /*console.warn(ta, location); */ system.runTimeout(
                                                () => {
                                                    try {
                                                        let startTime = Date.now();
                                                        let a = fillBlocksHC(
                                                            center,
                                                            radius,
                                                            player.dimension,
                                                            "y",
                                                            ccfirstblockname,
                                                            ccfirstblockstates,
                                                            {
                                                                matchingBlock: ccmatchingblock[0],
                                                                matchingBlockStates: ccmatchingblock[1],
                                                            },
                                                            undefined,
                                                            ccreplacemode
                                                        );
                                                        let endTime = Date.now();
                                                        player.sendMessageB(
                                                            `${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`
                                                        );
                                                    } catch (e) {
                                                        player.sendError(
                                                            "§c" + e + e.stack,
                                                            true
                                                        );
                                                    } finally {
                                                        ta?.remove();
                                                    }
                                                },
                                                2
                                            );
                                    } catch (e) {
                                        player.sendError(
                                            "§c" + e + e.stack,
                                            true
                                        );
                                    }
                                });
                                break;
                            case "circlez":
                                system.run(() => {
                                    let ta: Entity;
                                    try {
                                        player.dimension.runCommand(
                                            "summon andexdb:tickingarea_6 itwalls " +
                                            vTStr(center)
                                        );
                                        ta = player.dimension
                                            .getEntitiesAtBlockLocation(center)
                                            .find(
                                                (v) => v.typeId ==
                                                    "andexdb:tickingarea_6"
                                            );
                                        /*console.warn(ta, location); */ system.runTimeout(
                                                () => {
                                                    try {
                                                        let startTime = Date.now();
                                                        let a = fillBlocksHC(
                                                            center,
                                                            radius,
                                                            player.dimension,
                                                            "z",
                                                            ccfirstblockname,
                                                            ccfirstblockstates,
                                                            {
                                                                matchingBlock: ccmatchingblock[0],
                                                                matchingBlockStates: ccmatchingblock[1],
                                                            },
                                                            undefined,
                                                            ccreplacemode
                                                        );
                                                        let endTime = Date.now();
                                                        player.sendMessageB(
                                                            `${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`
                                                        );
                                                    } catch (e) {
                                                        player.sendError(
                                                            "§c" + e + e.stack,
                                                            true
                                                        );
                                                    } finally {
                                                        ta?.remove();
                                                    }
                                                },
                                                2
                                            );
                                    } catch (e) {
                                        player.sendError(
                                            "§c" + e + e.stack,
                                            true
                                        );
                                    }
                                });
                                break;
                            case "circlexy":
                                system.run(() => {
                                    let ta: Entity;
                                    try {
                                        player.dimension.runCommand(
                                            "summon andexdb:tickingarea_6 itwalls " +
                                            vTStr(center)
                                        );
                                        ta = player.dimension
                                            .getEntitiesAtBlockLocation(center)
                                            .find(
                                                (v) => v.typeId ==
                                                    "andexdb:tickingarea_6"
                                            );
                                        /*console.warn(ta, location); */ system.runTimeout(
                                                () => {
                                                    try {
                                                        let startTime = Date.now();
                                                        let a = fillBlocksHC(
                                                            center,
                                                            radius,
                                                            player.dimension,
                                                            "xy",
                                                            ccfirstblockname,
                                                            ccfirstblockstates,
                                                            {
                                                                matchingBlock: ccmatchingblock[0],
                                                                matchingBlockStates: ccmatchingblock[1],
                                                            },
                                                            undefined,
                                                            ccreplacemode
                                                        );
                                                        let endTime = Date.now();
                                                        player.sendMessageB(
                                                            `${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`
                                                        );
                                                    } catch (e) {
                                                        player.sendError(
                                                            "§c" + e + e.stack,
                                                            true
                                                        );
                                                    } finally {
                                                        ta?.remove();
                                                    }
                                                },
                                                2
                                            );
                                    } catch (e) {
                                        player.sendError(
                                            "§c" + e + e.stack,
                                            true
                                        );
                                    }
                                });
                                break;
                            case "circleyz":
                                system.run(() => {
                                    let ta: Entity;
                                    try {
                                        player.dimension.runCommand(
                                            "summon andexdb:tickingarea_6 itwalls " +
                                            vTStr(center)
                                        );
                                        ta = player.dimension
                                            .getEntitiesAtBlockLocation(center)
                                            .find(
                                                (v) => v.typeId ==
                                                    "andexdb:tickingarea_6"
                                            );
                                        /*console.warn(ta, location); */ system.runTimeout(
                                                () => {
                                                    try {
                                                        let startTime = Date.now();
                                                        let a = fillBlocksHC(
                                                            center,
                                                            radius,
                                                            player.dimension,
                                                            "yz",
                                                            ccfirstblockname,
                                                            ccfirstblockstates,
                                                            {
                                                                matchingBlock: ccmatchingblock[0],
                                                                matchingBlockStates: ccmatchingblock[1],
                                                            },
                                                            undefined,
                                                            ccreplacemode
                                                        );
                                                        let endTime = Date.now();
                                                        player.sendMessageB(
                                                            `${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`
                                                        );
                                                    } catch (e) {
                                                        player.sendError(
                                                            "§c" + e + e.stack,
                                                            true
                                                        );
                                                    } finally {
                                                        ta?.remove();
                                                    }
                                                },
                                                2
                                            );
                                    } catch (e) {
                                        player.sendError(
                                            "§c" + e + e.stack,
                                            true
                                        );
                                    }
                                });
                                break;
                            case "circlexz":
                                system.run(() => {
                                    let ta: Entity;
                                    try {
                                        player.dimension.runCommand(
                                            "summon andexdb:tickingarea_6 itwalls " +
                                            vTStr(center)
                                        );
                                        ta = player.dimension
                                            .getEntitiesAtBlockLocation(center)
                                            .find(
                                                (v) => v.typeId ==
                                                    "andexdb:tickingarea_6"
                                            );
                                        /*console.warn(ta, location); */ system.runTimeout(
                                                () => {
                                                    try {
                                                        let startTime = Date.now();
                                                        let a = fillBlocksHC(
                                                            center,
                                                            radius,
                                                            player.dimension,
                                                            "xz",
                                                            ccfirstblockname,
                                                            ccfirstblockstates,
                                                            {
                                                                matchingBlock: ccmatchingblock[0],
                                                                matchingBlockStates: ccmatchingblock[1],
                                                            },
                                                            undefined,
                                                            ccreplacemode
                                                        );
                                                        let endTime = Date.now();
                                                        player.sendMessageB(
                                                            `${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`
                                                        );
                                                    } catch (e) {
                                                        player.sendError(
                                                            "§c" + e + e.stack,
                                                            true
                                                        );
                                                    } finally {
                                                        ta?.remove();
                                                    }
                                                },
                                                2
                                            );
                                    } catch (e) {
                                        player.sendError(
                                            "§c" + e + e.stack,
                                            true
                                        );
                                    }
                                });
                                break;
                            case "circlexyz":
                                system.run(() => {
                                    let ta: Entity;
                                    try {
                                        player.dimension.runCommand(
                                            "summon andexdb:tickingarea_6 itwalls " +
                                            vTStr(center)
                                        );
                                        ta = player.dimension
                                            .getEntitiesAtBlockLocation(center)
                                            .find(
                                                (v) => v.typeId ==
                                                    "andexdb:tickingarea_6"
                                            );
                                        /*console.warn(ta, location); */ system.runTimeout(
                                                () => {
                                                    try {
                                                        let startTime = Date.now();
                                                        let a = fillBlocksHC(
                                                            center,
                                                            radius,
                                                            player.dimension,
                                                            "xyz",
                                                            ccfirstblockname,
                                                            ccfirstblockstates,
                                                            {
                                                                matchingBlock: ccmatchingblock[0],
                                                                matchingBlockStates: ccmatchingblock[1],
                                                            },
                                                            undefined,
                                                            ccreplacemode
                                                        );
                                                        let endTime = Date.now();
                                                        player.sendMessageB(
                                                            `${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`
                                                        );
                                                    } catch (e) {
                                                        player.sendError(
                                                            "§c" + e + e.stack,
                                                            true
                                                        );
                                                    } finally {
                                                        ta?.remove();
                                                    }
                                                },
                                                2
                                            );
                                    } catch (e) {
                                        player.sendError(
                                            "§c" + e + e.stack,
                                            true
                                        );
                                    }
                                });
                                break;
                            case "cylinder":
                                system.run(() => {
                                    let ta: Entity;
                                    try {
                                        player.dimension.runCommand(
                                            "summon andexdb:tickingarea_6 itwalls " +
                                            vTStr(center)
                                        );
                                        ta = player.dimension
                                            .getEntitiesAtBlockLocation(center)
                                            .find(
                                                (v) => v.typeId ==
                                                    "andexdb:tickingarea_6"
                                            );
                                        /*console.warn(ta, location); */ system.runTimeout(
                                                () => {
                                                    try {
                                                        let startTime = Date.now();
                                                        let a = fillBlocksHT(
                                                            center,
                                                            radius,
                                                            thickness,
                                                            taxis,
                                                            player.dimension,
                                                            tfirstblockname,
                                                            tfirstblockstates,
                                                            {
                                                                matchingBlock: tmatchingblock[0],
                                                                matchingBlockStates: tmatchingblock[1],
                                                            },
                                                            undefined,
                                                            treplacemode,
                                                            tintegrity
                                                        );
                                                        let endTime = Date.now();
                                                        player.sendMessageB(
                                                            `${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`
                                                        );
                                                    } catch (e) {
                                                        player.sendError(
                                                            "§c" + e + e.stack,
                                                            true
                                                        );
                                                    } finally {
                                                        ta?.remove();
                                                    }
                                                },
                                                2
                                            );
                                    } catch (e) {
                                        player.sendError(
                                            "§c" + e + e.stack,
                                            true
                                        );
                                    }
                                });
                                break;
                            case "cylinderx":
                                system.run(() => {
                                    let ta: Entity;
                                    try {
                                        player.dimension.runCommand(
                                            "summon andexdb:tickingarea_6 itwalls " +
                                            vTStr(center)
                                        );
                                        ta = player.dimension
                                            .getEntitiesAtBlockLocation(center)
                                            .find(
                                                (v) => v.typeId ==
                                                    "andexdb:tickingarea_6"
                                            );
                                        /*console.warn(ta, location); */ system.runTimeout(
                                                () => {
                                                    try {
                                                        let startTime = Date.now();
                                                        let a = fillBlocksHT(
                                                            center,
                                                            radius,
                                                            thickness,
                                                            "x",
                                                            player.dimension,
                                                            hsfirstblockname,
                                                            hsfirstblockstates,
                                                            {
                                                                matchingBlock: hsmatchingblock[0],
                                                                matchingBlockStates: hsmatchingblock[1],
                                                            },
                                                            undefined,
                                                            hsreplacemode,
                                                            tintegrity
                                                        );
                                                        let endTime = Date.now();
                                                        player.sendMessageB(
                                                            `${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`
                                                        );
                                                    } catch (e) {
                                                        player.sendError(
                                                            "§c" + e + e.stack,
                                                            true
                                                        );
                                                    } finally {
                                                        ta?.remove();
                                                    }
                                                },
                                                2
                                            );
                                    } catch (e) {
                                        player.sendError(
                                            "§c" + e + e.stack,
                                            true
                                        );
                                    }
                                });
                                break;
                            case "cylindery":
                                system.run(() => {
                                    let ta: Entity;
                                    try {
                                        player.dimension.runCommand(
                                            "summon andexdb:tickingarea_6 itwalls " +
                                            vTStr(center)
                                        );
                                        ta = player.dimension
                                            .getEntitiesAtBlockLocation(center)
                                            .find(
                                                (v) => v.typeId ==
                                                    "andexdb:tickingarea_6"
                                            );
                                        /*console.warn(ta, location); */ system.runTimeout(
                                                () => {
                                                    try {
                                                        let startTime = Date.now();
                                                        let a = fillBlocksHT(
                                                            center,
                                                            radius,
                                                            thickness,
                                                            "y",
                                                            player.dimension,
                                                            hsfirstblockname,
                                                            hsfirstblockstates,
                                                            {
                                                                matchingBlock: hsmatchingblock[0],
                                                                matchingBlockStates: hsmatchingblock[1],
                                                            },
                                                            undefined,
                                                            hsreplacemode,
                                                            tintegrity
                                                        );
                                                        let endTime = Date.now();
                                                        player.sendMessageB(
                                                            `${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`
                                                        );
                                                    } catch (e) {
                                                        player.sendError(
                                                            "§c" + e + e.stack,
                                                            true
                                                        );
                                                    } finally {
                                                        ta?.remove();
                                                    }
                                                },
                                                2
                                            );
                                    } catch (e) {
                                        player.sendError(
                                            "§c" + e + e.stack,
                                            true
                                        );
                                    }
                                });
                                break;
                            case "cylinderz":
                                system.run(() => {
                                    let ta: Entity;
                                    try {
                                        player.dimension.runCommand(
                                            "summon andexdb:tickingarea_6 itwalls " +
                                            vTStr(center)
                                        );
                                        ta = player.dimension
                                            .getEntitiesAtBlockLocation(center)
                                            .find(
                                                (v) => v.typeId ==
                                                    "andexdb:tickingarea_6"
                                            );
                                        /*console.warn(ta, location); */ system.runTimeout(
                                                () => {
                                                    try {
                                                        let startTime = Date.now();
                                                        let a = fillBlocksHT(
                                                            center,
                                                            radius,
                                                            thickness,
                                                            "z",
                                                            player.dimension,
                                                            hsfirstblockname,
                                                            hsfirstblockstates,
                                                            {
                                                                matchingBlock: hsmatchingblock[0],
                                                                matchingBlockStates: hsmatchingblock[1],
                                                            },
                                                            undefined,
                                                            hsreplacemode,
                                                            tintegrity
                                                        );
                                                        let endTime = Date.now();
                                                        player.sendMessageB(
                                                            `${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`
                                                        );
                                                    } catch (e) {
                                                        player.sendError(
                                                            "§c" + e + e.stack,
                                                            true
                                                        );
                                                    } finally {
                                                        ta?.remove();
                                                    }
                                                },
                                                2
                                            );
                                    } catch (e) {
                                        player.sendError(
                                            "§c" + e + e.stack,
                                            true
                                        );
                                    }
                                });
                                break;
                            case "cylinderxy":
                                system.run(() => {
                                    let ta: Entity;
                                    try {
                                        player.dimension.runCommand(
                                            "summon andexdb:tickingarea_6 itwalls " +
                                            vTStr(center)
                                        );
                                        ta = player.dimension
                                            .getEntitiesAtBlockLocation(center)
                                            .find(
                                                (v) => v.typeId ==
                                                    "andexdb:tickingarea_6"
                                            );
                                        /*console.warn(ta, location); */ system.runTimeout(
                                                () => {
                                                    try {
                                                        let startTime = Date.now();
                                                        let a = fillBlocksHT(
                                                            center,
                                                            radius,
                                                            thickness,
                                                            "x",
                                                            player.dimension,
                                                            hsfirstblockname,
                                                            hsfirstblockstates,
                                                            {
                                                                matchingBlock: hsmatchingblock[0],
                                                                matchingBlockStates: hsmatchingblock[1],
                                                            },
                                                            undefined,
                                                            hsreplacemode,
                                                            tintegrity
                                                        );
                                                        let endTime = Date.now();
                                                        player.sendMessageB(
                                                            `${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`
                                                        );
                                                    } catch (e) {
                                                        player.sendError(
                                                            "§c" + e + e.stack,
                                                            true
                                                        );
                                                    } finally {
                                                        ta?.remove();
                                                    }
                                                },
                                                2
                                            );
                                    } catch (e) {
                                        player.sendError(
                                            "§c" + e + e.stack,
                                            true
                                        );
                                    }
                                });
                                break;
                            case "cylinderyz":
                                system.run(() => {
                                    let ta: Entity;
                                    try {
                                        player.dimension.runCommand(
                                            "summon andexdb:tickingarea_6 itwalls " +
                                            vTStr(center)
                                        );
                                        ta = player.dimension
                                            .getEntitiesAtBlockLocation(center)
                                            .find(
                                                (v) => v.typeId ==
                                                    "andexdb:tickingarea_6"
                                            );
                                        /*console.warn(ta, location); */ system.runTimeout(
                                                () => {
                                                    try {
                                                        let startTime = Date.now();
                                                        let a = fillBlocksHT(
                                                            center,
                                                            radius,
                                                            thickness,
                                                            "y",
                                                            player.dimension,
                                                            hsfirstblockname,
                                                            hsfirstblockstates,
                                                            {
                                                                matchingBlock: hsmatchingblock[0],
                                                                matchingBlockStates: hsmatchingblock[1],
                                                            },
                                                            undefined,
                                                            hsreplacemode,
                                                            tintegrity
                                                        );
                                                        let endTime = Date.now();
                                                        player.sendMessageB(
                                                            `${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`
                                                        );
                                                    } catch (e) {
                                                        player.sendError(
                                                            "§c" + e + e.stack,
                                                            true
                                                        );
                                                    } finally {
                                                        ta?.remove();
                                                    }
                                                },
                                                2
                                            );
                                    } catch (e) {
                                        player.sendError(
                                            "§c" + e + e.stack,
                                            true
                                        );
                                    }
                                });
                                break;
                            case "cylinderxz":
                                system.run(() => {
                                    let ta: Entity;
                                    try {
                                        player.dimension.runCommand(
                                            "summon andexdb:tickingarea_6 itwalls " +
                                            vTStr(center)
                                        );
                                        ta = player.dimension
                                            .getEntitiesAtBlockLocation(center)
                                            .find(
                                                (v) => v.typeId ==
                                                    "andexdb:tickingarea_6"
                                            );
                                        /*console.warn(ta, location); */ system.runTimeout(
                                                () => {
                                                    try {
                                                        let startTime = Date.now();
                                                        let a = fillBlocksHT(
                                                            center,
                                                            radius,
                                                            thickness,
                                                            "z",
                                                            player.dimension,
                                                            hsfirstblockname,
                                                            hsfirstblockstates,
                                                            {
                                                                matchingBlock: hsmatchingblock[0],
                                                                matchingBlockStates: hsmatchingblock[1],
                                                            },
                                                            undefined,
                                                            hsreplacemode,
                                                            tintegrity
                                                        );
                                                        let endTime = Date.now();
                                                        player.sendMessageB(
                                                            `${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`
                                                        );
                                                    } catch (e) {
                                                        player.sendError(
                                                            "§c" + e + e.stack,
                                                            true
                                                        );
                                                    } finally {
                                                        ta?.remove();
                                                    }
                                                },
                                                2
                                            );
                                    } catch (e) {
                                        player.sendError(
                                            "§c" + e + e.stack,
                                            true
                                        );
                                    }
                                });
                                break;
                            case "cylinderxyz":
                                system.run(() => {
                                    let ta: Entity;
                                    try {
                                        player.dimension.runCommand(
                                            "summon andexdb:tickingarea_6 itwalls " +
                                            vTStr(center)
                                        );
                                        ta = player.dimension
                                            .getEntitiesAtBlockLocation(center)
                                            .find(
                                                (v) => v.typeId ==
                                                    "andexdb:tickingarea_6"
                                            );
                                        /*console.warn(ta, location); */ system.runTimeout(
                                                () => {
                                                    try {
                                                        let startTime = Date.now();
                                                        let a = fillBlocksHT(
                                                            center,
                                                            radius,
                                                            thickness,
                                                            "z",
                                                            player.dimension,
                                                            hsfirstblockname,
                                                            hsfirstblockstates,
                                                            {
                                                                matchingBlock: hsmatchingblock[0],
                                                                matchingBlockStates: hsmatchingblock[1],
                                                            },
                                                            undefined,
                                                            hsreplacemode,
                                                            tintegrity
                                                        );
                                                        let endTime = Date.now();
                                                        player.sendMessageB(
                                                            `${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`
                                                        );
                                                    } catch (e) {
                                                        player.sendError(
                                                            "§c" + e + e.stack,
                                                            true
                                                        );
                                                    } finally {
                                                        ta?.remove();
                                                    }
                                                },
                                                2
                                            );
                                    } catch (e) {
                                        player.sendError(
                                            "§c" + e + e.stack,
                                            true
                                        );
                                    }
                                });
                                break;
                            case "hourglass":
                                player.sendMessageB("§eComing Soon! ");
                                break;
                            case "cube":
                                system.run(() => {
                                    let ta: Entity;
                                    try {
                                        let location = {
                                            x: (coordinatesa.x +
                                                coordinatesb.x) /
                                                2,
                                            y: (coordinatesa.y +
                                                coordinatesb.y) /
                                                2,
                                            z: (coordinatesa.z +
                                                coordinatesb.z) /
                                                2,
                                        };
                                        player.dimension.runCommand(
                                            "summon andexdb:tickingarea_6 itwalls " +
                                            vTStr(location)
                                        );
                                        ta = player.dimension
                                            .getEntitiesAtBlockLocation(
                                                location
                                            )
                                            .find(
                                                (v) => v.typeId ==
                                                    "andexdb:tickingarea_6"
                                            );
                                        system.runTimeout(() => {
                                            try {
                                                let startTime = Date.now();
                                                if (replacemode) {
                                                    clearAllContainerBlocks(
                                                        scanForContainerBlocks(
                                                            coordinatesa,
                                                            coordinatesb,
                                                            player.dimension,
                                                            "Block"
                                                        ) as Block[]
                                                    );
                                                }
                                                let a = fillBlocksH(
                                                    coordinatesa,
                                                    coordinatesb,
                                                    player.dimension,
                                                    firstblockname,
                                                    firstblockstates,
                                                    {
                                                        matchingBlock: matchingblock[0],
                                                        matchingBlockStates: matchingblock[1],
                                                    }
                                                );
                                                let endTime = Date.now();
                                                player.sendMessageB(
                                                    `${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`
                                                );
                                            } catch (e) {
                                                player.sendError(
                                                    "§c" + e + e.stack,
                                                    true
                                                );
                                            } finally {
                                                ta?.remove();
                                            }
                                        }, 2);
                                    } catch (e) {
                                        player.sendError(
                                            "§c" + e + e.stack,
                                            true
                                        );
                                    }
                                });
                                break;
                            default:
                        }
                    }
                    //            try{system.run(()=>{player.dimension.fillBlocks(evaluateCoordinates(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[0][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[1][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[2][0], player.location, player.getRotation()), evaluateCoordinates(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[3][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[4][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0], player.location, player.getRotation()), BlockPermutation.resolve(switchTestB.split(" ").slice(1).join(" ").slice(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5].index+Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0].indexOf(" ")+1).split(" ")[0], extractJSONStrings(switchTestB.split(" ").slice(1).join(" ").slice(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5].index+Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0].indexOf(" ")).split(" ").slice(1).join(" "), false)[0]), {matchingBlock: BlockPermutation.resolve(getParametersFromString(switchTestB.split(" ").slice(1).join(" ").slice(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5].index+Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0].indexOf(" ")+1)).results[2], extractJSONStrings(switchTestB.split(" ").slice(1).join(" ").slice(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5].index+Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0].indexOf(" ")).split(" ").slice(1).join(" "), false)[1])}); }); }catch(e){player.sendError("§c" + e + e.stack, true)}
                }
                break;
            case !!switchTest.match(/^ifillc$/):
                {
                    eventData.cancel = true;
                    let coordinatesa = evaluateCoordinates(
                        Array.from(
                            switchTestB
                                .split(" ")
                                .slice(1)
                                .join(" ")
                                .matchAll(
                                    /\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis
                                )
                        )[0][0],
                        Array.from(
                            switchTestB
                                .split(" ")
                                .slice(1)
                                .join(" ")
                                .matchAll(
                                    /\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis
                                )
                        )[1][0],
                        Array.from(
                            switchTestB
                                .split(" ")
                                .slice(1)
                                .join(" ")
                                .matchAll(
                                    /\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis
                                )
                        )[2][0],
                        player.location,
                        player.getRotation()
                    );
                    let coordinatesb = evaluateCoordinates(
                        Array.from(
                            switchTestB
                                .split(" ")
                                .slice(1)
                                .join(" ")
                                .matchAll(
                                    /\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis
                                )
                        )[3][0],
                        Array.from(
                            switchTestB
                                .split(" ")
                                .slice(1)
                                .join(" ")
                                .matchAll(
                                    /\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis
                                )
                        )[4][0],
                        Array.from(
                            switchTestB
                                .split(" ")
                                .slice(1)
                                .join(" ")
                                .matchAll(
                                    /\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis
                                )
                        )[5][0],
                        player.location,
                        player.getRotation()
                    );
                    let firstblocknameindex = Array.from(
                        switchTestB
                            .split(" ")
                            .slice(1)
                            .join(" ")
                            .matchAll(
                                /\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis
                            )
                    )[5].index +
                        Array.from(
                            switchTestB
                                .split(" ")
                                .slice(1)
                                .join(" ")
                                .matchAll(
                                    /\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis
                                )
                        )[5][0].indexOf(" ") +
                        1;
                    let reststringaftercoordinates = switchTestB
                        .split(" ")
                        .slice(1)
                        .join(" ")
                        .slice(firstblocknameindex);
                    let firstblockname = reststringaftercoordinates.split(" ")[0];
                    let firstblockstates = reststringaftercoordinates
                        .split(" ")
                        .slice(1)
                        .join(" ")
                        .trimStart()
                        .startsWith("{")
                        ? JSONParse(
                            extractJSONStrings(
                                reststringaftercoordinates
                                    .split(" ")
                                    .slice(1)
                                    .join(" ")
                                    .trimStart(),
                                false
                            )[0]
                        )
                        : reststringaftercoordinates
                            .split(" ")
                            .slice(1)
                            .join(" ")
                            .trimStart()
                            .startsWith("[")
                            ? JSONParse(
                                extractJSONStrings(
                                    reststringaftercoordinates
                                        .split(" ")
                                        .slice(1)
                                        .join(" ")
                                        .trimStart()
                                        .replaceAll("=", ":")
                                        .replaceAll("[", "{")
                                        .replaceAll("]", "}"),
                                    false
                                )[0]
                            )
                            : undefined;
                    let lastblockname = reststringaftercoordinates
                        .split(" ")
                        .slice(1)
                        .join(" ")
                        .trimStart()
                        .startsWith("{")
                        ? reststringaftercoordinates
                            .split(" ")
                            .slice(1)
                            .join(" ")
                            .trimStart()
                            .slice(
                                extractJSONStrings(
                                    reststringaftercoordinates
                                        .split(" ")
                                        .slice(1)
                                        .join(" ")
                                        .trimStart(),
                                    false
                                )[0].length
                            )
                            .trimStart()
                            .split(" ")[0]
                        : reststringaftercoordinates
                            .split(" ")
                            .slice(1)
                            .join(" ")
                            .trimStart()
                            .startsWith("[")
                            ? reststringaftercoordinates
                                .split(" ")
                                .slice(1)
                                .join(" ")
                                .trimStart()
                                .slice(
                                    extractJSONStrings(
                                        reststringaftercoordinates
                                            .split(" ")
                                            .slice(1)
                                            .join(" ")
                                            .trimStart()
                                            .replaceAll("=", ":")
                                            .replaceAll("[", "{")
                                            .replaceAll("]", "}"),
                                        false
                                    )[0].length
                                )
                                .trimStart()
                                .split(" ")[0]
                            : reststringaftercoordinates
                                .trimStart()
                                .split(" ")
                                .slice(1)
                                .join(" ")
                                .trimStart()
                                .split(" ")[0];
                    let somethingtest = reststringaftercoordinates
                        .split(" ")
                        .slice(1)
                        .join(" ")
                        .trimStart()
                        .startsWith("{")
                        ? reststringaftercoordinates
                            .split(" ")
                            .slice(1)
                            .join(" ")
                            .trimStart()
                            .slice(
                                extractJSONStrings(
                                    reststringaftercoordinates
                                        .split(" ")
                                        .slice(1)
                                        .join(" ")
                                        .trimStart(),
                                    false
                                )[0].length
                            )
                            .trimStart()
                            .split(" ")
                            .slice(1)
                            .join(" ")
                            .trim()
                        : reststringaftercoordinates
                            .split(" ")
                            .slice(1)
                            .join(" ")
                            .trimStart()
                            .startsWith("[")
                            ? reststringaftercoordinates
                                .split(" ")
                                .slice(1)
                                .join(" ")
                                .trimStart()
                                .slice(
                                    extractJSONStrings(
                                        reststringaftercoordinates
                                            .split(" ")
                                            .slice(1)
                                            .join(" ")
                                            .trimStart()
                                            .replaceAll("=", ":")
                                            .replaceAll("[", "{")
                                            .replaceAll("]", "}"),
                                        false
                                    )[0].length
                                )
                                .trimStart()
                                .split(" ")
                                .slice(1)
                                .join(" ")
                                .trim()
                            : reststringaftercoordinates
                                .trimStart()
                                .split(" ")
                                .slice(1)
                                .join(" ")
                                .trimStart()
                                .split(" ")
                                .slice(1)
                                .join(" ")
                                .trim();
                    let lastblockstates = somethingtest.startsWith("{")
                        ? JSONParse(extractJSONStrings(somethingtest, false)[0])
                        : somethingtest.startsWith("[")
                            ? JSONParse(
                                extractJSONStrings(
                                    somethingtest
                                        .replaceAll("=", ":")
                                        .replaceAll("[", "{")
                                        .replaceAll("]", "}"),
                                    false
                                )[0]
                            )
                            : undefined;
                    let matchingblock = lastblockname == ""
                        ? []
                        : lastblockname == "keep"
                            ? ["air"]
                            : [
                                BlockTypes.get(lastblockname).id,
                                lastblockstates,
                            ]; /*
  console.warn(JSONStringify({coordinatesa, coordinatesb, firstblockname, firstblocknameindex, reststringaftercoordinates, firstblockstates, lastblockname, somethingtest, lastblockstates, matchingblock}))*/

                    srun(() => {
                        try {
                            let startTime = Date.now();
                            let a = fillBlocksH(
                                coordinatesa,
                                coordinatesb,
                                player.dimension,
                                firstblockname,
                                firstblockstates,
                                {
                                    matchingBlock: matchingblock[0],
                                    matchingBlockStates: matchingblock[1],
                                }
                            );
                            let endTime = Date.now();
                            player.sendMessageB(
                                `${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`
                            );
                        } catch (e) {
                            player.sendError("§c" + e + e.stack, true);
                        }
                    });
                    //            try{system.run(()=>{player.dimension.fillBlocks(evaluateCoordinates(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[0][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[1][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[2][0], player.location, player.getRotation()), evaluateCoordinates(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[3][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[4][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0], player.location, player.getRotation()), BlockPermutation.resolve(switchTestB.split(" ").slice(1).join(" ").slice(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5].index+Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0].indexOf(" ")+1).split(" ")[0], extractJSONStrings(switchTestB.split(" ").slice(1).join(" ").slice(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5].index+Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0].indexOf(" ")).split(" ").slice(1).join(" "), false)[0]), {matchingBlock: BlockPermutation.resolve(getParametersFromString(switchTestB.split(" ").slice(1).join(" ").slice(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5].index+Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0].indexOf(" ")+1)).results[2], extractJSONStrings(switchTestB.split(" ").slice(1).join(" ").slice(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5].index+Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0].indexOf(" ")).split(" ").slice(1).join(" "), false)[1])}); }); }catch(e){player.sendError("§c" + e + e.stack, true)}
                }
                break;
            case !!switchTest.match(/^ifilld$/):
                {
                    eventData.cancel = true;
                    let coordinatesa = evaluateCoordinates(
                        Array.from(
                            switchTestB
                                .split(" ")
                                .slice(1)
                                .join(" ")
                                .matchAll(
                                    /\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis
                                )
                        )[0][0],
                        Array.from(
                            switchTestB
                                .split(" ")
                                .slice(1)
                                .join(" ")
                                .matchAll(
                                    /\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis
                                )
                        )[1][0],
                        Array.from(
                            switchTestB
                                .split(" ")
                                .slice(1)
                                .join(" ")
                                .matchAll(
                                    /\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis
                                )
                        )[2][0],
                        player.location,
                        player.getRotation()
                    );
                    let coordinatesb = evaluateCoordinates(
                        Array.from(
                            switchTestB
                                .split(" ")
                                .slice(1)
                                .join(" ")
                                .matchAll(
                                    /\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis
                                )
                        )[3][0],
                        Array.from(
                            switchTestB
                                .split(" ")
                                .slice(1)
                                .join(" ")
                                .matchAll(
                                    /\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis
                                )
                        )[4][0],
                        Array.from(
                            switchTestB
                                .split(" ")
                                .slice(1)
                                .join(" ")
                                .matchAll(
                                    /\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis
                                )
                        )[5][0],
                        player.location,
                        player.getRotation()
                    );
                    let firstblocknameindex = Array.from(
                        switchTestB
                            .split(" ")
                            .slice(1)
                            .join(" ")
                            .matchAll(
                                /\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis
                            )
                    )[5].index +
                        Array.from(
                            switchTestB
                                .split(" ")
                                .slice(1)
                                .join(" ")
                                .matchAll(
                                    /\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis
                                )
                        )[5][0].indexOf(" ") +
                        1;
                    let reststringaftercoordinates = switchTestB
                        .split(" ")
                        .slice(1)
                        .join(" ")
                        .slice(firstblocknameindex);
                    let firstblockname = reststringaftercoordinates.split(" ")[0];
                    let firstblockstates = reststringaftercoordinates
                        .split(" ")
                        .slice(1)
                        .join(" ")
                        .trimStart()
                        .startsWith("{")
                        ? JSONParse(
                            extractJSONStrings(
                                reststringaftercoordinates
                                    .split(" ")
                                    .slice(1)
                                    .join(" ")
                                    .trimStart(),
                                false
                            )[0]
                        )
                        : reststringaftercoordinates
                            .split(" ")
                            .slice(1)
                            .join(" ")
                            .trimStart()
                            .startsWith("[")
                            ? JSONParse(
                                extractJSONStrings(
                                    reststringaftercoordinates
                                        .split(" ")
                                        .slice(1)
                                        .join(" ")
                                        .trimStart()
                                        .replaceAll("=", ":")
                                        .replaceAll("[", "{")
                                        .replaceAll("]", "}"),
                                    false
                                )[0]
                            )
                            : undefined;
                    let lastblockname = reststringaftercoordinates
                        .split(" ")
                        .slice(1)
                        .join(" ")
                        .trimStart()
                        .startsWith("{")
                        ? reststringaftercoordinates
                            .split(" ")
                            .slice(1)
                            .join(" ")
                            .trimStart()
                            .slice(
                                extractJSONStrings(
                                    reststringaftercoordinates
                                        .split(" ")
                                        .slice(1)
                                        .join(" ")
                                        .trimStart(),
                                    false
                                )[0].length
                            )
                            .trimStart()
                            .split(" ")[0]
                        : reststringaftercoordinates
                            .split(" ")
                            .slice(1)
                            .join(" ")
                            .trimStart()
                            .startsWith("[")
                            ? reststringaftercoordinates
                                .split(" ")
                                .slice(1)
                                .join(" ")
                                .trimStart()
                                .slice(
                                    extractJSONStrings(
                                        reststringaftercoordinates
                                            .split(" ")
                                            .slice(1)
                                            .join(" ")
                                            .trimStart()
                                            .replaceAll("=", ":")
                                            .replaceAll("[", "{")
                                            .replaceAll("]", "}"),
                                        false
                                    )[0].length
                                )
                                .trimStart()
                                .split(" ")[0]
                            : reststringaftercoordinates
                                .trimStart()
                                .split(" ")
                                .slice(1)
                                .join(" ")
                                .trimStart()
                                .split(" ")[0];
                    let somethingtest = reststringaftercoordinates
                        .split(" ")
                        .slice(1)
                        .join(" ")
                        .trimStart()
                        .startsWith("{")
                        ? reststringaftercoordinates
                            .split(" ")
                            .slice(1)
                            .join(" ")
                            .trimStart()
                            .slice(
                                extractJSONStrings(
                                    reststringaftercoordinates
                                        .split(" ")
                                        .slice(1)
                                        .join(" ")
                                        .trimStart(),
                                    false
                                )[0].length
                            )
                            .trimStart()
                            .split(" ")
                            .slice(1)
                            .join(" ")
                            .trim()
                        : reststringaftercoordinates
                            .split(" ")
                            .slice(1)
                            .join(" ")
                            .trimStart()
                            .startsWith("[")
                            ? reststringaftercoordinates
                                .split(" ")
                                .slice(1)
                                .join(" ")
                                .trimStart()
                                .slice(
                                    extractJSONStrings(
                                        reststringaftercoordinates
                                            .split(" ")
                                            .slice(1)
                                            .join(" ")
                                            .trimStart()
                                            .replaceAll("=", ":")
                                            .replaceAll("[", "{")
                                            .replaceAll("]", "}"),
                                        false
                                    )[0].length
                                )
                                .trimStart()
                                .split(" ")
                                .slice(1)
                                .join(" ")
                                .trim()
                            : reststringaftercoordinates
                                .trimStart()
                                .split(" ")
                                .slice(1)
                                .join(" ")
                                .trimStart()
                                .split(" ")
                                .slice(1)
                                .join(" ")
                                .trim();
                    let lastblockstates = somethingtest.startsWith("{")
                        ? JSONParse(extractJSONStrings(somethingtest, false)[0])
                        : somethingtest.startsWith("[")
                            ? JSONParse(
                                extractJSONStrings(
                                    somethingtest
                                        .replaceAll("=", ":")
                                        .replaceAll("[", "{")
                                        .replaceAll("]", "}"),
                                    false
                                )[0]
                            )
                            : undefined;
                    let matchingblock = lastblockname == ""
                        ? []
                        : lastblockname == "keep"
                            ? ["air"]
                            : [
                                BlockTypes.get(lastblockname).id,
                                lastblockstates,
                            ]; /*
  console.warn(JSONStringify({coordinatesa, coordinatesb, firstblockname, firstblocknameindex, reststringaftercoordinates, firstblockstates, lastblockname, somethingtest, lastblockstates, matchingblock}))*/

                    srun(() => {
                        try {
                            let startTime = Date.now();
                            let a = fillBlocksH(
                                coordinatesa,
                                coordinatesb,
                                player.dimension,
                                firstblockname,
                                firstblockstates,
                                {
                                    matchingBlock: matchingblock[0],
                                    matchingBlockStates: matchingblock[1],
                                }
                            );
                            let endTime = Date.now();
                            player.sendMessageB(
                                `${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`
                            );
                        } catch (e) {
                            player.sendError("§c" + e + e.stack, true);
                        }
                    });
                    //            try{system.run(()=>{player.dimension.fillBlocks(evaluateCoordinates(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[0][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[1][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[2][0], player.location, player.getRotation()), evaluateCoordinates(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[3][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[4][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0], player.location, player.getRotation()), BlockPermutation.resolve(switchTestB.split(" ").slice(1).join(" ").slice(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5].index+Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0].indexOf(" ")+1).split(" ")[0], extractJSONStrings(switchTestB.split(" ").slice(1).join(" ").slice(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5].index+Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0].indexOf(" ")).split(" ").slice(1).join(" "), false)[0]), {matchingBlock: BlockPermutation.resolve(getParametersFromString(switchTestB.split(" ").slice(1).join(" ").slice(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5].index+Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0].indexOf(" ")+1)).results[2], extractJSONStrings(switchTestB.split(" ").slice(1).join(" ").slice(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5].index+Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0].indexOf(" ")).split(" ").slice(1).join(" "), false)[1])}); }); }catch(e){player.sendError("§c" + e + e.stack, true)}
                }
                break;
            case !!switchTest.match(/^itfillc$/):
                {
                    eventData.cancel = true;
                    let coordinatesa = evaluateCoordinates(
                        Array.from(
                            switchTestB
                                .split(" ")
                                .slice(1)
                                .join(" ")
                                .matchAll(
                                    /\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis
                                )
                        )[0][0],
                        Array.from(
                            switchTestB
                                .split(" ")
                                .slice(1)
                                .join(" ")
                                .matchAll(
                                    /\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis
                                )
                        )[1][0],
                        Array.from(
                            switchTestB
                                .split(" ")
                                .slice(1)
                                .join(" ")
                                .matchAll(
                                    /\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis
                                )
                        )[2][0],
                        player.location,
                        player.getRotation()
                    );
                    let coordinatesb = evaluateCoordinates(
                        Array.from(
                            switchTestB
                                .split(" ")
                                .slice(1)
                                .join(" ")
                                .matchAll(
                                    /\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis
                                )
                        )[3][0],
                        Array.from(
                            switchTestB
                                .split(" ")
                                .slice(1)
                                .join(" ")
                                .matchAll(
                                    /\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis
                                )
                        )[4][0],
                        Array.from(
                            switchTestB
                                .split(" ")
                                .slice(1)
                                .join(" ")
                                .matchAll(
                                    /\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis
                                )
                        )[5][0],
                        player.location,
                        player.getRotation()
                    );
                    let firstblocknameindex = Array.from(
                        switchTestB
                            .split(" ")
                            .slice(1)
                            .join(" ")
                            .matchAll(
                                /\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis
                            )
                    )[5].index +
                        Array.from(
                            switchTestB
                                .split(" ")
                                .slice(1)
                                .join(" ")
                                .matchAll(
                                    /\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis
                                )
                        )[5][0].indexOf(" ") +
                        1;
                    let reststringaftercoordinates = switchTestB
                        .split(" ")
                        .slice(1)
                        .join(" ")
                        .slice(firstblocknameindex);
                    let firstblockname = reststringaftercoordinates.split(" ")[0];
                    let firstblockstates = reststringaftercoordinates
                        .split(" ")
                        .slice(1)
                        .join(" ")
                        .trimStart()
                        .startsWith("{")
                        ? JSONParse(
                            extractJSONStrings(
                                reststringaftercoordinates
                                    .split(" ")
                                    .slice(1)
                                    .join(" ")
                                    .trimStart(),
                                false
                            )[0]
                        )
                        : reststringaftercoordinates
                            .split(" ")
                            .slice(1)
                            .join(" ")
                            .trimStart()
                            .startsWith("[")
                            ? JSONParse(
                                extractJSONStrings(
                                    reststringaftercoordinates
                                        .split(" ")
                                        .slice(1)
                                        .join(" ")
                                        .trimStart()
                                        .replaceAll("=", ":")
                                        .replaceAll("[", "{")
                                        .replaceAll("]", "}"),
                                    false
                                )[0]
                            )
                            : undefined;
                    let lastblockname = reststringaftercoordinates
                        .split(" ")
                        .slice(1)
                        .join(" ")
                        .trimStart()
                        .startsWith("{")
                        ? reststringaftercoordinates
                            .split(" ")
                            .slice(1)
                            .join(" ")
                            .trimStart()
                            .slice(
                                extractJSONStrings(
                                    reststringaftercoordinates
                                        .split(" ")
                                        .slice(1)
                                        .join(" ")
                                        .trimStart(),
                                    false
                                )[0].length
                            )
                            .trimStart()
                            .split(" ")[0]
                        : reststringaftercoordinates
                            .split(" ")
                            .slice(1)
                            .join(" ")
                            .trimStart()
                            .startsWith("[")
                            ? reststringaftercoordinates
                                .split(" ")
                                .slice(1)
                                .join(" ")
                                .trimStart()
                                .slice(
                                    extractJSONStrings(
                                        reststringaftercoordinates
                                            .split(" ")
                                            .slice(1)
                                            .join(" ")
                                            .trimStart()
                                            .replaceAll("=", ":")
                                            .replaceAll("[", "{")
                                            .replaceAll("]", "}"),
                                        false
                                    )[0].length
                                )
                                .trimStart()
                                .split(" ")[0]
                            : reststringaftercoordinates
                                .trimStart()
                                .split(" ")
                                .slice(1)
                                .join(" ")
                                .trimStart()
                                .split(" ")[0];
                    let somethingtest = reststringaftercoordinates
                        .split(" ")
                        .slice(1)
                        .join(" ")
                        .trimStart()
                        .startsWith("{")
                        ? reststringaftercoordinates
                            .split(" ")
                            .slice(1)
                            .join(" ")
                            .trimStart()
                            .slice(
                                extractJSONStrings(
                                    reststringaftercoordinates
                                        .split(" ")
                                        .slice(1)
                                        .join(" ")
                                        .trimStart(),
                                    false
                                )[0].length
                            )
                            .trimStart()
                            .split(" ")
                            .slice(1)
                            .join(" ")
                            .trim()
                        : reststringaftercoordinates
                            .split(" ")
                            .slice(1)
                            .join(" ")
                            .trimStart()
                            .startsWith("[")
                            ? reststringaftercoordinates
                                .split(" ")
                                .slice(1)
                                .join(" ")
                                .trimStart()
                                .slice(
                                    extractJSONStrings(
                                        reststringaftercoordinates
                                            .split(" ")
                                            .slice(1)
                                            .join(" ")
                                            .trimStart()
                                            .replaceAll("=", ":")
                                            .replaceAll("[", "{")
                                            .replaceAll("]", "}"),
                                        false
                                    )[0].length
                                )
                                .trimStart()
                                .split(" ")
                                .slice(1)
                                .join(" ")
                                .trim()
                            : reststringaftercoordinates
                                .trimStart()
                                .split(" ")
                                .slice(1)
                                .join(" ")
                                .trimStart()
                                .split(" ")
                                .slice(1)
                                .join(" ")
                                .trim();
                    let lastblockstates = somethingtest.startsWith("{")
                        ? JSONParse(extractJSONStrings(somethingtest, false)[0])
                        : somethingtest.startsWith("[")
                            ? JSONParse(
                                extractJSONStrings(
                                    somethingtest
                                        .replaceAll("=", ":")
                                        .replaceAll("[", "{")
                                        .replaceAll("]", "}"),
                                    false
                                )[0]
                            )
                            : undefined;
                    let matchingblock = lastblockname == ""
                        ? []
                        : lastblockname == "keep"
                            ? ["air"]
                            : [
                                BlockTypes.get(lastblockname).id,
                                lastblockstates,
                            ]; /*
  console.warn(JSONStringify({coordinatesa, coordinatesb, firstblockname, firstblocknameindex, reststringaftercoordinates, firstblockstates, lastblockname, somethingtest, lastblockstates, matchingblock}))*/

                    system.run(() => {
                        let ta: Entity;
                        try {
                            let location = {
                                x: (coordinatesa.x + coordinatesb.x) / 2,
                                y: (coordinatesa.y + coordinatesb.y) / 2,
                                z: (coordinatesa.z + coordinatesb.z) / 2,
                            };
                            player.dimension.runCommand(
                                "summon andexdb:tickingarea_6 itwalls " +
                                vTStr(location)
                            );
                            ta = player.dimension
                                .getEntitiesAtBlockLocation(location)
                                .find(
                                    (v) => v.typeId == "andexdb:tickingarea_6"
                                );
                            system.runTimeout(() => {
                                try {
                                    let startTime = Date.now();
                                    let a = fillBlocksH(
                                        coordinatesa,
                                        coordinatesb,
                                        player.dimension,
                                        firstblockname,
                                        firstblockstates,
                                        {
                                            matchingBlock: matchingblock[0],
                                            matchingBlockStates: matchingblock[1],
                                        }
                                    );
                                    let endTime = Date.now();
                                    player.sendMessageB(
                                        `${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`
                                    );
                                } catch (e) {
                                    player.sendError("§c" + e + e.stack, true);
                                } finally {
                                    ta?.remove();
                                }
                            }, 2);
                        } catch (e) {
                            player.sendError("§c" + e + e.stack, true);
                        }
                    });
                    //            try{system.run(()=>{player.dimension.fillBlocks(evaluateCoordinates(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[0][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[1][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[2][0], player.location, player.getRotation()), evaluateCoordinates(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[3][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[4][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0], player.location, player.getRotation()), BlockPermutation.resolve(switchTestB.split(" ").slice(1).join(" ").slice(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5].index+Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0].indexOf(" ")+1).split(" ")[0], extractJSONStrings(switchTestB.split(" ").slice(1).join(" ").slice(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5].index+Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0].indexOf(" ")).split(" ").slice(1).join(" "), false)[0]), {matchingBlock: BlockPermutation.resolve(getParametersFromString(switchTestB.split(" ").slice(1).join(" ").slice(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5].index+Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0].indexOf(" ")+1)).results[2], extractJSONStrings(switchTestB.split(" ").slice(1).join(" ").slice(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5].index+Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0].indexOf(" ")).split(" ").slice(1).join(" "), false)[1])}); }); }catch(e){player.sendError("§c" + e + e.stack, true)}
                }
                break;
            case !!switchTest.match(/^iwalls$/):
                {
                    eventData.cancel = true;
                    let coordinatesa = evaluateCoordinates(
                        Array.from(
                            switchTestB
                                .split(" ")
                                .slice(1)
                                .join(" ")
                                .matchAll(
                                    /\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis
                                )
                        )[0][0],
                        Array.from(
                            switchTestB
                                .split(" ")
                                .slice(1)
                                .join(" ")
                                .matchAll(
                                    /\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis
                                )
                        )[1][0],
                        Array.from(
                            switchTestB
                                .split(" ")
                                .slice(1)
                                .join(" ")
                                .matchAll(
                                    /\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis
                                )
                        )[2][0],
                        player.location,
                        player.getRotation()
                    );
                    let coordinatesb = evaluateCoordinates(
                        Array.from(
                            switchTestB
                                .split(" ")
                                .slice(1)
                                .join(" ")
                                .matchAll(
                                    /\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis
                                )
                        )[3][0],
                        Array.from(
                            switchTestB
                                .split(" ")
                                .slice(1)
                                .join(" ")
                                .matchAll(
                                    /\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis
                                )
                        )[4][0],
                        Array.from(
                            switchTestB
                                .split(" ")
                                .slice(1)
                                .join(" ")
                                .matchAll(
                                    /\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis
                                )
                        )[5][0],
                        player.location,
                        player.getRotation()
                    );
                    let firstblocknameindex = Array.from(
                        switchTestB
                            .split(" ")
                            .slice(1)
                            .join(" ")
                            .matchAll(
                                /\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis
                            )
                    )[5].index +
                        Array.from(
                            switchTestB
                                .split(" ")
                                .slice(1)
                                .join(" ")
                                .matchAll(
                                    /\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis
                                )
                        )[5][0].indexOf(" ") +
                        1;
                    let reststringaftercoordinates = switchTestB
                        .split(" ")
                        .slice(1)
                        .join(" ")
                        .slice(firstblocknameindex);
                    let firstblockname = reststringaftercoordinates.split(" ")[0];
                    let firstblockstates = reststringaftercoordinates
                        .split(" ")
                        .slice(1)
                        .join(" ")
                        .trimStart()
                        .startsWith("{")
                        ? JSONParse(
                            extractJSONStrings(
                                reststringaftercoordinates
                                    .split(" ")
                                    .slice(1)
                                    .join(" ")
                                    .trimStart(),
                                false
                            )[0]
                        )
                        : reststringaftercoordinates
                            .split(" ")
                            .slice(1)
                            .join(" ")
                            .trimStart()
                            .startsWith("[")
                            ? JSONParse(
                                extractJSONStrings(
                                    reststringaftercoordinates
                                        .split(" ")
                                        .slice(1)
                                        .join(" ")
                                        .trimStart()
                                        .replaceAll("=", ":")
                                        .replaceAll("[", "{")
                                        .replaceAll("]", "}"),
                                    false
                                )[0]
                            )
                            : undefined;
                    let lastblockname = reststringaftercoordinates
                        .split(" ")
                        .slice(1)
                        .join(" ")
                        .trimStart()
                        .startsWith("{")
                        ? reststringaftercoordinates
                            .split(" ")
                            .slice(1)
                            .join(" ")
                            .trimStart()
                            .slice(
                                extractJSONStrings(
                                    reststringaftercoordinates
                                        .split(" ")
                                        .slice(1)
                                        .join(" ")
                                        .trimStart(),
                                    false
                                )[0].length
                            )
                            .trimStart()
                            .split(" ")[0]
                        : reststringaftercoordinates
                            .split(" ")
                            .slice(1)
                            .join(" ")
                            .trimStart()
                            .startsWith("[")
                            ? reststringaftercoordinates
                                .split(" ")
                                .slice(1)
                                .join(" ")
                                .trimStart()
                                .slice(
                                    extractJSONStrings(
                                        reststringaftercoordinates
                                            .split(" ")
                                            .slice(1)
                                            .join(" ")
                                            .trimStart()
                                            .replaceAll("=", ":")
                                            .replaceAll("[", "{")
                                            .replaceAll("]", "}"),
                                        false
                                    )[0].length
                                )
                                .trimStart()
                                .split(" ")[0]
                            : reststringaftercoordinates
                                .trimStart()
                                .split(" ")
                                .slice(1)
                                .join(" ")
                                .trimStart()
                                .split(" ")[0];
                    let somethingtest = reststringaftercoordinates
                        .split(" ")
                        .slice(1)
                        .join(" ")
                        .trimStart()
                        .startsWith("{")
                        ? reststringaftercoordinates
                            .split(" ")
                            .slice(1)
                            .join(" ")
                            .trimStart()
                            .slice(
                                extractJSONStrings(
                                    reststringaftercoordinates
                                        .split(" ")
                                        .slice(1)
                                        .join(" ")
                                        .trimStart(),
                                    false
                                )[0].length
                            )
                            .trimStart()
                            .split(" ")
                            .slice(1)
                            .join(" ")
                            .trim()
                        : reststringaftercoordinates
                            .split(" ")
                            .slice(1)
                            .join(" ")
                            .trimStart()
                            .startsWith("[")
                            ? reststringaftercoordinates
                                .split(" ")
                                .slice(1)
                                .join(" ")
                                .trimStart()
                                .slice(
                                    extractJSONStrings(
                                        reststringaftercoordinates
                                            .split(" ")
                                            .slice(1)
                                            .join(" ")
                                            .trimStart()
                                            .replaceAll("=", ":")
                                            .replaceAll("[", "{")
                                            .replaceAll("]", "}"),
                                        false
                                    )[0].length
                                )
                                .trimStart()
                                .split(" ")
                                .slice(1)
                                .join(" ")
                                .trim()
                            : reststringaftercoordinates
                                .trimStart()
                                .split(" ")
                                .slice(1)
                                .join(" ")
                                .trimStart()
                                .split(" ")
                                .slice(1)
                                .join(" ")
                                .trim();
                    let lastblockstates = somethingtest.startsWith("{")
                        ? JSONParse(extractJSONStrings(somethingtest, false)[0])
                        : somethingtest.startsWith("[")
                            ? JSONParse(
                                extractJSONStrings(
                                    somethingtest
                                        .replaceAll("=", ":")
                                        .replaceAll("[", "{")
                                        .replaceAll("]", "}"),
                                    false
                                )[0]
                            )
                            : undefined;
                    let matchingblock = lastblockname == ""
                        ? [undefined, undefined]
                        : lastblockname == "keep"
                            ? ["air"]
                            : [
                                BlockTypes.get(lastblockname).id,
                                lastblockstates,
                            ]; /*
  console.warn(JSONStringify({coordinatesa, coordinatesb, firstblockname, firstblocknameindex, reststringaftercoordinates, firstblockstates, lastblockname, somethingtest, lastblockstates, matchingblock}))*/

                    system.run(() => {
                        try {
                            let startTime = Date.now();
                            let a = fillBlocksHW(
                                coordinatesa,
                                coordinatesb,
                                player.dimension,
                                firstblockname,
                                firstblockstates,
                                {
                                    matchingBlock: matchingblock[0],
                                    matchingBlockStates: matchingblock[1],
                                }
                            );
                            let endTime = Date.now();
                            player.sendMessageB(
                                `${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`
                            );
                        } catch (e) {
                            player.sendError("§c" + e + e.stack, true);
                        }
                    });
                    //            try{system.run(()=>{player.dimension.fillBlocks(evaluateCoordinates(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[0][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[1][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[2][0], player.location, player.getRotation()), evaluateCoordinates(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[3][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[4][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0], player.location, player.getRotation()), BlockPermutation.resolve(switchTestB.split(" ").slice(1).join(" ").slice(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5].index+Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0].indexOf(" ")+1).split(" ")[0], extractJSONStrings(switchTestB.split(" ").slice(1).join(" ").slice(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5].index+Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0].indexOf(" ")).split(" ").slice(1).join(" "), false)[0]), {matchingBlock: BlockPermutation.resolve(getParametersFromString(switchTestB.split(" ").slice(1).join(" ").slice(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5].index+Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0].indexOf(" ")+1)).results[2], extractJSONStrings(switchTestB.split(" ").slice(1).join(" ").slice(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5].index+Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0].indexOf(" ")).split(" ").slice(1).join(" "), false)[1])}); }); }catch(e){player.sendError("§c" + e + e.stack, true)}
                }
                break;
            case !!switchTest.match(/^itwalls$/):
                {
                    eventData.cancel = true;
                    let argsa = evaluateParameters(switchTestB, [
                        "presetText",
                        "Vector",
                        "Vector",
                        "Vector",
                        "Vector",
                        "Vector",
                        "Vector",
                        "string",
                    ]);
                    let args = argsa.args;
                    let argsaextra = argsa.extra;
                    let coordinatesa = evaluateCoordinates(
                        args[1],
                        args[2],
                        args[3],
                        player.location,
                        player.getRotation()
                    );
                    let coordinatesb = evaluateCoordinates(
                        args[4],
                        args[5],
                        args[6],
                        player.location,
                        player.getRotation()
                    );
                    //let firstblocknameindex = Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5].index+Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0].indexOf(" ")+1
                    //let reststringaftercoordinates = switchTestB.split(" ").slice(1).join(" ").slice(firstblocknameindex)
                    let firstblockname = args[7];
                    let firstblockstates = argsa.extra
                        .trimStart()
                        .startsWith("{")
                        ? JSONParse(
                            extractJSONStrings(
                                argsa.extra.trimStart(),
                                false
                            )[0]
                        )
                        : argsa.extra.trimStart().startsWith("[")
                            ? JSONParse(
                                extractJSONStrings(
                                    argsa.extra
                                        .trimStart()
                                        .replaceAll("=", ":")
                                        .replaceAll("[", "{")
                                        .replaceAll("]", "}"),
                                    false
                                )[0]
                            )
                            : undefined;
                    let lastblockname = argsa.extra.trimStart().startsWith("{")
                        ? argsa.extra
                            .trimStart()
                            .slice(
                                extractJSONStrings(
                                    argsa.extra.trimStart(),
                                    false
                                )[0].length
                            )
                            .trimStart()
                            .split(" ")[0]
                        : argsa.extra.trimStart().startsWith("[")
                            ? argsa.extra
                                .trimStart()
                                .slice(
                                    extractJSONStrings(
                                        argsa.extra
                                            .trimStart()
                                            .replaceAll("=", ":")
                                            .replaceAll("[", "{")
                                            .replaceAll("]", "}"),
                                        false
                                    )[0].length
                                )
                                .trimStart()
                                .split(" ")[0]
                            : argsa.extra.trimStart().split(" ")[0];
                    let somethingtest = argsa.extra.trimStart().startsWith("{")
                        ? argsa.extra
                            .trimStart()
                            .slice(
                                extractJSONStrings(
                                    argsa.extra.trimStart(),
                                    false
                                )[0].length
                            )
                            .trimStart()
                            .split(" ")
                            .slice(1)
                            .join(" ")
                            .trim()
                        : argsa.extra.trimStart().startsWith("[")
                            ? argsa.extra
                                .trimStart()
                                .slice(
                                    extractJSONStrings(
                                        argsa.extra
                                            .trimStart()
                                            .replaceAll("=", ":")
                                            .replaceAll("[", "{")
                                            .replaceAll("]", "}"),
                                        false
                                    )[0].length
                                )
                                .trimStart()
                                .split(" ")
                                .slice(1)
                                .join(" ")
                                .trim()
                            : argsa.extra
                                .trimStart()
                                .split(" ")
                                .slice(1)
                                .join(" ")
                                .trim();
                    let lastblockstates = somethingtest.startsWith("{")
                        ? JSONParse(extractJSONStrings(somethingtest, false)[0])
                        : somethingtest.startsWith("[")
                            ? JSONParse(
                                extractJSONStrings(
                                    somethingtest
                                        .replaceAll("=", ":")
                                        .replaceAll("[", "{")
                                        .replaceAll("]", "}"),
                                    false
                                )[0]
                            )
                            : undefined;
                    let matchingblock = lastblockname == ""
                        ? [undefined, undefined]
                        : lastblockname == "keep"
                            ? ["air"]
                            : [
                                BlockTypes.get(lastblockname).id,
                                lastblockstates,
                            ];
                    console.warn(
                        JSONStringify({
                            coordinatesa,
                            coordinatesb,
                            firstblockname,
                            argsaextra,
                            args /*, firstblocknameindex, reststringaftercoordinates*/,
                            firstblockstates,
                            lastblockname,
                            somethingtest,
                            lastblockstates,
                            matchingblock,
                        })
                    );
                    system.run(() => {
                        let ta: Entity;
                        try {
                            let location = {
                                x: (coordinatesa.x + coordinatesb.x) / 2,
                                y: (coordinatesa.y + coordinatesb.y) / 2,
                                z: (coordinatesa.z + coordinatesb.z) / 2,
                            };
                            player.dimension.runCommand(
                                "summon andexdb:tickingarea_6 itwalls " +
                                vTStr(location)
                            );
                            ta = player.dimension
                                .getEntitiesAtBlockLocation(location)
                                .find(
                                    (v) => v.typeId == "andexdb:tickingarea_6"
                                );
                            /*console.warn(ta, location); */ system.runTimeout(
                                    () => {
                                        try {
                                            let startTime = Date.now();
                                            let a = fillBlocksHW(
                                                coordinatesa,
                                                coordinatesb,
                                                player.dimension,
                                                firstblockname,
                                                firstblockstates,
                                                {
                                                    matchingBlock: matchingblock[0],
                                                    matchingBlockStates: matchingblock[1],
                                                }
                                            );
                                            let endTime = Date.now();
                                            player.sendMessageB(
                                                `${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`
                                            );
                                        } catch (e) {
                                            player.sendError(
                                                "§c" + e + e.stack,
                                                true
                                            );
                                        } finally {
                                            ta?.remove();
                                        }
                                    },
                                    2
                                );
                        } catch (e) {
                            player.sendError("§c" + e + e.stack, true);
                        }
                    });
                    //            try{system.run(()=>{player.dimension.fillBlocks(evaluateCoordinates(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[0][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[1][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[2][0], player.location, player.getRotation()), evaluateCoordinates(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[3][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[4][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0], player.location, player.getRotation()), BlockPermutation.resolve(switchTestB.split(" ").slice(1).join(" ").slice(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5].index+Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0].indexOf(" ")+1).split(" ")[0], extractJSONStrings(switchTestB.split(" ").slice(1).join(" ").slice(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5].index+Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0].indexOf(" ")).split(" ").slice(1).join(" "), false)[0]), {matchingBlock: BlockPermutation.resolve(getParametersFromString(switchTestB.split(" ").slice(1).join(" ").slice(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5].index+Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0].indexOf(" ")+1)).results[2], extractJSONStrings(switchTestB.split(" ").slice(1).join(" ").slice(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5].index+Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0].indexOf(" ")).split(" ").slice(1).join(" "), false)[1])}); }); }catch(e){player.sendError("§c" + e + e.stack, true)}
                }
                break;
            case !!switchTest.match(/^ihollow$/):
                {
                    eventData.cancel = true;
                    let coordinatesa = evaluateCoordinates(
                        Array.from(
                            switchTestB
                                .split(" ")
                                .slice(1)
                                .join(" ")
                                .matchAll(
                                    /\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis
                                )
                        )[0][0],
                        Array.from(
                            switchTestB
                                .split(" ")
                                .slice(1)
                                .join(" ")
                                .matchAll(
                                    /\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis
                                )
                        )[1][0],
                        Array.from(
                            switchTestB
                                .split(" ")
                                .slice(1)
                                .join(" ")
                                .matchAll(
                                    /\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis
                                )
                        )[2][0],
                        player.location,
                        player.getRotation()
                    );
                    let coordinatesb = evaluateCoordinates(
                        Array.from(
                            switchTestB
                                .split(" ")
                                .slice(1)
                                .join(" ")
                                .matchAll(
                                    /\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis
                                )
                        )[3][0],
                        Array.from(
                            switchTestB
                                .split(" ")
                                .slice(1)
                                .join(" ")
                                .matchAll(
                                    /\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis
                                )
                        )[4][0],
                        Array.from(
                            switchTestB
                                .split(" ")
                                .slice(1)
                                .join(" ")
                                .matchAll(
                                    /\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis
                                )
                        )[5][0],
                        player.location,
                        player.getRotation()
                    );
                    let firstblocknameindex = Array.from(
                        switchTestB
                            .split(" ")
                            .slice(1)
                            .join(" ")
                            .matchAll(
                                /\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis
                            )
                    )[5].index +
                        Array.from(
                            switchTestB
                                .split(" ")
                                .slice(1)
                                .join(" ")
                                .matchAll(
                                    /\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis
                                )
                        )[5][0].indexOf(" ") +
                        1;
                    let reststringaftercoordinates = switchTestB
                        .split(" ")
                        .slice(1)
                        .join(" ")
                        .slice(firstblocknameindex);
                    let firstblockname = reststringaftercoordinates.split(" ")[0];
                    let firstblockstates = reststringaftercoordinates
                        .split(" ")
                        .slice(1)
                        .join(" ")
                        .trimStart()
                        .startsWith("{")
                        ? JSONParse(
                            extractJSONStrings(
                                reststringaftercoordinates
                                    .split(" ")
                                    .slice(1)
                                    .join(" ")
                                    .trimStart(),
                                false
                            )[0]
                        )
                        : reststringaftercoordinates
                            .split(" ")
                            .slice(1)
                            .join(" ")
                            .trimStart()
                            .startsWith("[")
                            ? JSONParse(
                                extractJSONStrings(
                                    reststringaftercoordinates
                                        .split(" ")
                                        .slice(1)
                                        .join(" ")
                                        .trimStart()
                                        .replaceAll("=", ":")
                                        .replaceAll("[", "{")
                                        .replaceAll("]", "}"),
                                    false
                                )[0]
                            )
                            : undefined;
                    let lastblockname = reststringaftercoordinates
                        .split(" ")
                        .slice(1)
                        .join(" ")
                        .trimStart()
                        .startsWith("{")
                        ? reststringaftercoordinates
                            .split(" ")
                            .slice(1)
                            .join(" ")
                            .trimStart()
                            .slice(
                                extractJSONStrings(
                                    reststringaftercoordinates
                                        .split(" ")
                                        .slice(1)
                                        .join(" ")
                                        .trimStart(),
                                    false
                                )[0].length
                            )
                            .trimStart()
                            .split(" ")[0]
                        : reststringaftercoordinates
                            .split(" ")
                            .slice(1)
                            .join(" ")
                            .trimStart()
                            .startsWith("[")
                            ? reststringaftercoordinates
                                .split(" ")
                                .slice(1)
                                .join(" ")
                                .trimStart()
                                .slice(
                                    extractJSONStrings(
                                        reststringaftercoordinates
                                            .split(" ")
                                            .slice(1)
                                            .join(" ")
                                            .trimStart()
                                            .replaceAll("=", ":")
                                            .replaceAll("[", "{")
                                            .replaceAll("]", "}"),
                                        false
                                    )[0].length
                                )
                                .trimStart()
                                .split(" ")[0]
                            : reststringaftercoordinates
                                .trimStart()
                                .split(" ")
                                .slice(1)
                                .join(" ")
                                .trimStart()
                                .split(" ")[0];
                    let somethingtest = reststringaftercoordinates
                        .split(" ")
                        .slice(1)
                        .join(" ")
                        .trimStart()
                        .startsWith("{")
                        ? reststringaftercoordinates
                            .split(" ")
                            .slice(1)
                            .join(" ")
                            .trimStart()
                            .slice(
                                extractJSONStrings(
                                    reststringaftercoordinates
                                        .split(" ")
                                        .slice(1)
                                        .join(" ")
                                        .trimStart(),
                                    false
                                )[0].length
                            )
                            .trimStart()
                            .split(" ")
                            .slice(1)
                            .join(" ")
                            .trim()
                        : reststringaftercoordinates
                            .split(" ")
                            .slice(1)
                            .join(" ")
                            .trimStart()
                            .startsWith("[")
                            ? reststringaftercoordinates
                                .split(" ")
                                .slice(1)
                                .join(" ")
                                .trimStart()
                                .slice(
                                    extractJSONStrings(
                                        reststringaftercoordinates
                                            .split(" ")
                                            .slice(1)
                                            .join(" ")
                                            .trimStart()
                                            .replaceAll("=", ":")
                                            .replaceAll("[", "{")
                                            .replaceAll("]", "}"),
                                        false
                                    )[0].length
                                )
                                .trimStart()
                                .split(" ")
                                .slice(1)
                                .join(" ")
                                .trim()
                            : reststringaftercoordinates
                                .trimStart()
                                .split(" ")
                                .slice(1)
                                .join(" ")
                                .trimStart()
                                .split(" ")
                                .slice(1)
                                .join(" ")
                                .trim();
                    let lastblockstates = somethingtest.startsWith("{")
                        ? JSONParse(extractJSONStrings(somethingtest, false)[0])
                        : somethingtest.startsWith("[")
                            ? JSONParse(
                                extractJSONStrings(
                                    somethingtest
                                        .replaceAll("=", ":")
                                        .replaceAll("[", "{")
                                        .replaceAll("]", "}"),
                                    false
                                )[0]
                            )
                            : undefined;
                    let matchingblock = lastblockname == ""
                        ? [undefined, undefined]
                        : lastblockname == "keep"
                            ? ["air"]
                            : [
                                BlockTypes.get(lastblockname).id,
                                lastblockstates,
                            ]; /*
  console.warn(JSONStringify({coordinatesa, coordinatesb, firstblockname, firstblocknameindex, reststringaftercoordinates, firstblockstates, lastblockname, somethingtest, lastblockstates, matchingblock}))*/

                    system.run(() => {
                        try {
                            let startTime = Date.now();
                            let a = fillBlocksHH(
                                coordinatesa,
                                coordinatesb,
                                player.dimension,
                                firstblockname,
                                firstblockstates,
                                {
                                    matchingBlock: matchingblock[0],
                                    matchingBlockStates: matchingblock[1],
                                }
                            );
                            let endTime = Date.now();
                            player.sendMessageB(
                                `${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`
                            );
                        } catch (e) {
                            player.sendError("§c" + e + e.stack, true);
                        }
                    });
                    //            try{system.run(()=>{player.dimension.fillBlocks(evaluateCoordinates(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[0][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[1][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[2][0], player.location, player.getRotation()), evaluateCoordinates(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[3][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[4][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0], player.location, player.getRotation()), BlockPermutation.resolve(switchTestB.split(" ").slice(1).join(" ").slice(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5].index+Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0].indexOf(" ")+1).split(" ")[0], extractJSONStrings(switchTestB.split(" ").slice(1).join(" ").slice(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5].index+Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0].indexOf(" ")).split(" ").slice(1).join(" "), false)[0]), {matchingBlock: BlockPermutation.resolve(getParametersFromString(switchTestB.split(" ").slice(1).join(" ").slice(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5].index+Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0].indexOf(" ")+1)).results[2], extractJSONStrings(switchTestB.split(" ").slice(1).join(" ").slice(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5].index+Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0].indexOf(" ")).split(" ").slice(1).join(" "), false)[1])}); }); }catch(e){player.sendError("§c" + e + e.stack, true)}
                }
                break;
            case !!switchTest.match(/^ithollow$/):
                {
                    eventData.cancel = true;
                    let argsa = evaluateParameters(switchTestB, [
                        "presetText",
                        "Vector",
                        "Vector",
                        "Vector",
                        "Vector",
                        "Vector",
                        "Vector",
                        "string",
                    ]);
                    let args = argsa.args;
                    let argsaextra = argsa.extra;
                    let coordinatesa = evaluateCoordinates(
                        args[1],
                        args[2],
                        args[3],
                        player.location,
                        player.getRotation()
                    );
                    let coordinatesb = evaluateCoordinates(
                        args[4],
                        args[5],
                        args[6],
                        player.location,
                        player.getRotation()
                    );
                    //let firstblocknameindex = Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5].index+Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0].indexOf(" ")+1
                    //let reststringaftercoordinates = switchTestB.split(" ").slice(1).join(" ").slice(firstblocknameindex)
                    let firstblockname = args[7];
                    let firstblockstates = argsa.extra
                        .trimStart()
                        .startsWith("{")
                        ? JSONParse(
                            extractJSONStrings(
                                argsa.extra.trimStart(),
                                false
                            )[0]
                        )
                        : argsa.extra.trimStart().startsWith("[")
                            ? JSONParse(
                                extractJSONStrings(
                                    argsa.extra
                                        .trimStart()
                                        .replaceAll("=", ":")
                                        .replaceAll("[", "{")
                                        .replaceAll("]", "}"),
                                    false
                                )[0]
                            )
                            : undefined;
                    let lastblockname = argsa.extra.trimStart().startsWith("{")
                        ? argsa.extra
                            .trimStart()
                            .slice(
                                extractJSONStrings(
                                    argsa.extra.trimStart(),
                                    false
                                )[0].length
                            )
                            .trimStart()
                            .split(" ")[0]
                        : argsa.extra.trimStart().startsWith("[")
                            ? argsa.extra
                                .trimStart()
                                .slice(
                                    extractJSONStrings(
                                        argsa.extra
                                            .trimStart()
                                            .replaceAll("=", ":")
                                            .replaceAll("[", "{")
                                            .replaceAll("]", "}"),
                                        false
                                    )[0].length
                                )
                                .trimStart()
                                .split(" ")[0]
                            : argsa.extra.trimStart().split(" ")[0];
                    let somethingtest = argsa.extra.trimStart().startsWith("{")
                        ? argsa.extra
                            .trimStart()
                            .slice(
                                extractJSONStrings(
                                    argsa.extra.trimStart(),
                                    false
                                )[0].length
                            )
                            .trimStart()
                            .split(" ")
                            .slice(1)
                            .join(" ")
                            .trim()
                        : argsa.extra.trimStart().startsWith("[")
                            ? argsa.extra
                                .trimStart()
                                .slice(
                                    extractJSONStrings(
                                        argsa.extra
                                            .trimStart()
                                            .replaceAll("=", ":")
                                            .replaceAll("[", "{")
                                            .replaceAll("]", "}"),
                                        false
                                    )[0].length
                                )
                                .trimStart()
                                .split(" ")
                                .slice(1)
                                .join(" ")
                                .trim()
                            : argsa.extra
                                .trimStart()
                                .split(" ")
                                .slice(1)
                                .join(" ")
                                .trim();
                    let lastblockstates = somethingtest.startsWith("{")
                        ? JSONParse(extractJSONStrings(somethingtest, false)[0])
                        : somethingtest.startsWith("[")
                            ? JSONParse(
                                extractJSONStrings(
                                    somethingtest
                                        .replaceAll("=", ":")
                                        .replaceAll("[", "{")
                                        .replaceAll("]", "}"),
                                    false
                                )[0]
                            )
                            : undefined;
                    let matchingblock = lastblockname == ""
                        ? [undefined, undefined]
                        : lastblockname == "keep"
                            ? ["air"]
                            : [
                                BlockTypes.get(lastblockname).id,
                                lastblockstates,
                            ];
                    console.warn(
                        JSONStringify({
                            coordinatesa,
                            coordinatesb,
                            firstblockname,
                            argsaextra,
                            args /*, firstblocknameindex, reststringaftercoordinates*/,
                            firstblockstates,
                            lastblockname,
                            somethingtest,
                            lastblockstates,
                            matchingblock,
                        })
                    );
                    system.run(() => {
                        let ta: Entity;
                        try {
                            let location = {
                                x: (coordinatesa.x + coordinatesb.x) / 2,
                                y: (coordinatesa.y + coordinatesb.y) / 2,
                                z: (coordinatesa.z + coordinatesb.z) / 2,
                            };
                            player.dimension.runCommand(
                                "summon andexdb:tickingarea_6 itwalls " +
                                vTStr(location)
                            );
                            ta = player.dimension
                                .getEntitiesAtBlockLocation(location)
                                .find(
                                    (v) => v.typeId == "andexdb:tickingarea_6"
                                );
                            /*console.warn(ta, location); */ system.runTimeout(
                                    () => {
                                        try {
                                            let startTime = Date.now();
                                            let a = fillBlocksHH(
                                                coordinatesa,
                                                coordinatesb,
                                                player.dimension,
                                                firstblockname,
                                                firstblockstates,
                                                {
                                                    matchingBlock: matchingblock[0],
                                                    matchingBlockStates: matchingblock[1],
                                                }
                                            );
                                            let endTime = Date.now();
                                            player.sendMessageB(
                                                `${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`
                                            );
                                        } catch (e) {
                                            player.sendError(
                                                "§c" + e + e.stack,
                                                true
                                            );
                                        } finally {
                                            ta?.remove();
                                        }
                                    },
                                    2
                                );
                        } catch (e) {
                            player.sendError("§c" + e + e.stack, true);
                        }
                    });
                    //            try{system.run(()=>{player.dimension.fillBlocks(evaluateCoordinates(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[0][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[1][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[2][0], player.location, player.getRotation()), evaluateCoordinates(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[3][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[4][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0], player.location, player.getRotation()), BlockPermutation.resolve(switchTestB.split(" ").slice(1).join(" ").slice(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5].index+Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0].indexOf(" ")+1).split(" ")[0], extractJSONStrings(switchTestB.split(" ").slice(1).join(" ").slice(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5].index+Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0].indexOf(" ")).split(" ").slice(1).join(" "), false)[0]), {matchingBlock: BlockPermutation.resolve(getParametersFromString(switchTestB.split(" ").slice(1).join(" ").slice(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5].index+Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0].indexOf(" ")+1)).results[2], extractJSONStrings(switchTestB.split(" ").slice(1).join(" ").slice(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5].index+Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0].indexOf(" ")).split(" ").slice(1).join(" "), false)[1])}); }); }catch(e){player.sendError("§c" + e + e.stack, true)}
                }
                break;
            case !!switchTest.match(/^ioutline$/):
                {
                    eventData.cancel = true;
                    let coordinatesa = evaluateCoordinates(
                        Array.from(
                            switchTestB
                                .split(" ")
                                .slice(1)
                                .join(" ")
                                .matchAll(
                                    /\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis
                                )
                        )[0][0],
                        Array.from(
                            switchTestB
                                .split(" ")
                                .slice(1)
                                .join(" ")
                                .matchAll(
                                    /\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis
                                )
                        )[1][0],
                        Array.from(
                            switchTestB
                                .split(" ")
                                .slice(1)
                                .join(" ")
                                .matchAll(
                                    /\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis
                                )
                        )[2][0],
                        player.location,
                        player.getRotation()
                    );
                    let coordinatesb = evaluateCoordinates(
                        Array.from(
                            switchTestB
                                .split(" ")
                                .slice(1)
                                .join(" ")
                                .matchAll(
                                    /\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis
                                )
                        )[3][0],
                        Array.from(
                            switchTestB
                                .split(" ")
                                .slice(1)
                                .join(" ")
                                .matchAll(
                                    /\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis
                                )
                        )[4][0],
                        Array.from(
                            switchTestB
                                .split(" ")
                                .slice(1)
                                .join(" ")
                                .matchAll(
                                    /\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis
                                )
                        )[5][0],
                        player.location,
                        player.getRotation()
                    );
                    let firstblocknameindex = Array.from(
                        switchTestB
                            .split(" ")
                            .slice(1)
                            .join(" ")
                            .matchAll(
                                /\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis
                            )
                    )[5].index +
                        Array.from(
                            switchTestB
                                .split(" ")
                                .slice(1)
                                .join(" ")
                                .matchAll(
                                    /\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis
                                )
                        )[5][0].indexOf(" ") +
                        1;
                    let reststringaftercoordinates = switchTestB
                        .split(" ")
                        .slice(1)
                        .join(" ")
                        .slice(firstblocknameindex);
                    let firstblockname = reststringaftercoordinates.split(" ")[0];
                    let firstblockstates = reststringaftercoordinates
                        .split(" ")
                        .slice(1)
                        .join(" ")
                        .trimStart()
                        .startsWith("{")
                        ? JSONParse(
                            extractJSONStrings(
                                reststringaftercoordinates
                                    .split(" ")
                                    .slice(1)
                                    .join(" ")
                                    .trimStart(),
                                false
                            )[0]
                        )
                        : reststringaftercoordinates
                            .split(" ")
                            .slice(1)
                            .join(" ")
                            .trimStart()
                            .startsWith("[")
                            ? JSONParse(
                                extractJSONStrings(
                                    reststringaftercoordinates
                                        .split(" ")
                                        .slice(1)
                                        .join(" ")
                                        .trimStart()
                                        .replaceAll("=", ":")
                                        .replaceAll("[", "{")
                                        .replaceAll("]", "}"),
                                    false
                                )[0]
                            )
                            : undefined;
                    let lastblockname = reststringaftercoordinates
                        .split(" ")
                        .slice(1)
                        .join(" ")
                        .trimStart()
                        .startsWith("{")
                        ? reststringaftercoordinates
                            .split(" ")
                            .slice(1)
                            .join(" ")
                            .trimStart()
                            .slice(
                                extractJSONStrings(
                                    reststringaftercoordinates
                                        .split(" ")
                                        .slice(1)
                                        .join(" ")
                                        .trimStart(),
                                    false
                                )[0].length
                            )
                            .trimStart()
                            .split(" ")[0]
                        : reststringaftercoordinates
                            .split(" ")
                            .slice(1)
                            .join(" ")
                            .trimStart()
                            .startsWith("[")
                            ? reststringaftercoordinates
                                .split(" ")
                                .slice(1)
                                .join(" ")
                                .trimStart()
                                .slice(
                                    extractJSONStrings(
                                        reststringaftercoordinates
                                            .split(" ")
                                            .slice(1)
                                            .join(" ")
                                            .trimStart()
                                            .replaceAll("=", ":")
                                            .replaceAll("[", "{")
                                            .replaceAll("]", "}"),
                                        false
                                    )[0].length
                                )
                                .trimStart()
                                .split(" ")[0]
                            : reststringaftercoordinates
                                .trimStart()
                                .split(" ")
                                .slice(1)
                                .join(" ")
                                .trimStart()
                                .split(" ")[0];
                    let somethingtest = reststringaftercoordinates
                        .split(" ")
                        .slice(1)
                        .join(" ")
                        .trimStart()
                        .startsWith("{")
                        ? reststringaftercoordinates
                            .split(" ")
                            .slice(1)
                            .join(" ")
                            .trimStart()
                            .slice(
                                extractJSONStrings(
                                    reststringaftercoordinates
                                        .split(" ")
                                        .slice(1)
                                        .join(" ")
                                        .trimStart(),
                                    false
                                )[0].length
                            )
                            .trimStart()
                            .split(" ")
                            .slice(1)
                            .join(" ")
                            .trim()
                        : reststringaftercoordinates
                            .split(" ")
                            .slice(1)
                            .join(" ")
                            .trimStart()
                            .startsWith("[")
                            ? reststringaftercoordinates
                                .split(" ")
                                .slice(1)
                                .join(" ")
                                .trimStart()
                                .slice(
                                    extractJSONStrings(
                                        reststringaftercoordinates
                                            .split(" ")
                                            .slice(1)
                                            .join(" ")
                                            .trimStart()
                                            .replaceAll("=", ":")
                                            .replaceAll("[", "{")
                                            .replaceAll("]", "}"),
                                        false
                                    )[0].length
                                )
                                .trimStart()
                                .split(" ")
                                .slice(1)
                                .join(" ")
                                .trim()
                            : reststringaftercoordinates
                                .trimStart()
                                .split(" ")
                                .slice(1)
                                .join(" ")
                                .trimStart()
                                .split(" ")
                                .slice(1)
                                .join(" ")
                                .trim();
                    let lastblockstates = somethingtest.startsWith("{")
                        ? JSONParse(extractJSONStrings(somethingtest, false)[0])
                        : somethingtest.startsWith("[")
                            ? JSONParse(
                                extractJSONStrings(
                                    somethingtest
                                        .replaceAll("=", ":")
                                        .replaceAll("[", "{")
                                        .replaceAll("]", "}"),
                                    false
                                )[0]
                            )
                            : undefined;
                    let matchingblock = lastblockname == ""
                        ? [undefined, undefined]
                        : lastblockname == "keep"
                            ? ["air"]
                            : [
                                BlockTypes.get(lastblockname).id,
                                lastblockstates,
                            ]; /*
  console.warn(JSONStringify({coordinatesa, coordinatesb, firstblockname, firstblocknameindex, reststringaftercoordinates, firstblockstates, lastblockname, somethingtest, lastblockstates, matchingblock}))*/

                    system.run(() => {
                        try {
                            let startTime = Date.now();
                            let a = fillBlocksHO(
                                coordinatesa,
                                coordinatesb,
                                player.dimension,
                                firstblockname,
                                firstblockstates,
                                {
                                    matchingBlock: matchingblock[0],
                                    matchingBlockStates: matchingblock[1],
                                }
                            );
                            let endTime = Date.now();
                            player.sendMessageB(
                                `${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`
                            );
                        } catch (e) {
                            player.sendError("§c" + e + e.stack, true);
                        }
                    });
                    //            try{system.run(()=>{player.dimension.fillBlocks(evaluateCoordinates(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[0][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[1][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[2][0], player.location, player.getRotation()), evaluateCoordinates(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[3][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[4][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0], player.location, player.getRotation()), BlockPermutation.resolve(switchTestB.split(" ").slice(1).join(" ").slice(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5].index+Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0].indexOf(" ")+1).split(" ")[0], extractJSONStrings(switchTestB.split(" ").slice(1).join(" ").slice(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5].index+Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0].indexOf(" ")).split(" ").slice(1).join(" "), false)[0]), {matchingBlock: BlockPermutation.resolve(getParametersFromString(switchTestB.split(" ").slice(1).join(" ").slice(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5].index+Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0].indexOf(" ")+1)).results[2], extractJSONStrings(switchTestB.split(" ").slice(1).join(" ").slice(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5].index+Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0].indexOf(" ")).split(" ").slice(1).join(" "), false)[1])}); }); }catch(e){player.sendError("§c" + e + e.stack, true)}
                }
                break;
            case !!switchTest.match(/^itoutline$/):
                {
                    eventData.cancel = true;
                    let argsa = evaluateParameters(switchTestB, [
                        "presetText",
                        "Vector",
                        "Vector",
                        "Vector",
                        "Vector",
                        "Vector",
                        "Vector",
                        "string",
                    ]);
                    let args = argsa.args;
                    let argsaextra = argsa.extra;
                    let coordinatesa = evaluateCoordinates(
                        args[1],
                        args[2],
                        args[3],
                        player.location,
                        player.getRotation()
                    );
                    let coordinatesb = evaluateCoordinates(
                        args[4],
                        args[5],
                        args[6],
                        player.location,
                        player.getRotation()
                    );
                    //let firstblocknameindex = Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5].index+Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0].indexOf(" ")+1
                    //let reststringaftercoordinates = switchTestB.split(" ").slice(1).join(" ").slice(firstblocknameindex)
                    let firstblockname = args[7];
                    let firstblockstates = argsa.extra
                        .trimStart()
                        .startsWith("{")
                        ? JSONParse(
                            extractJSONStrings(
                                argsa.extra.trimStart(),
                                false
                            )[0]
                        )
                        : argsa.extra.trimStart().startsWith("[")
                            ? JSONParse(
                                extractJSONStrings(
                                    argsa.extra
                                        .trimStart()
                                        .replaceAll("=", ":")
                                        .replaceAll("[", "{")
                                        .replaceAll("]", "}"),
                                    false
                                )[0]
                            )
                            : undefined;
                    let lastblockname = argsa.extra.trimStart().startsWith("{")
                        ? argsa.extra
                            .trimStart()
                            .slice(
                                extractJSONStrings(
                                    argsa.extra.trimStart(),
                                    false
                                )[0].length
                            )
                            .trimStart()
                            .split(" ")[0]
                        : argsa.extra.trimStart().startsWith("[")
                            ? argsa.extra
                                .trimStart()
                                .slice(
                                    extractJSONStrings(
                                        argsa.extra
                                            .trimStart()
                                            .replaceAll("=", ":")
                                            .replaceAll("[", "{")
                                            .replaceAll("]", "}"),
                                        false
                                    )[0].length
                                )
                                .trimStart()
                                .split(" ")[0]
                            : argsa.extra.trimStart().split(" ")[0];
                    let somethingtest = argsa.extra.trimStart().startsWith("{")
                        ? argsa.extra
                            .trimStart()
                            .slice(
                                extractJSONStrings(
                                    argsa.extra.trimStart(),
                                    false
                                )[0].length
                            )
                            .trimStart()
                            .split(" ")
                            .slice(1)
                            .join(" ")
                            .trim()
                        : argsa.extra.trimStart().startsWith("[")
                            ? argsa.extra
                                .trimStart()
                                .slice(
                                    extractJSONStrings(
                                        argsa.extra
                                            .trimStart()
                                            .replaceAll("=", ":")
                                            .replaceAll("[", "{")
                                            .replaceAll("]", "}"),
                                        false
                                    )[0].length
                                )
                                .trimStart()
                                .split(" ")
                                .slice(1)
                                .join(" ")
                                .trim()
                            : argsa.extra
                                .trimStart()
                                .split(" ")
                                .slice(1)
                                .join(" ")
                                .trim();
                    let lastblockstates = somethingtest.startsWith("{")
                        ? JSONParse(extractJSONStrings(somethingtest, false)[0])
                        : somethingtest.startsWith("[")
                            ? JSONParse(
                                extractJSONStrings(
                                    somethingtest
                                        .replaceAll("=", ":")
                                        .replaceAll("[", "{")
                                        .replaceAll("]", "}"),
                                    false
                                )[0]
                            )
                            : undefined;
                    let matchingblock = lastblockname == ""
                        ? [undefined, undefined]
                        : lastblockname == "keep"
                            ? ["air"]
                            : [
                                BlockTypes.get(lastblockname).id,
                                lastblockstates,
                            ];
                    console.warn(
                        JSONStringify({
                            coordinatesa,
                            coordinatesb,
                            firstblockname,
                            argsaextra,
                            args /*, firstblocknameindex, reststringaftercoordinates*/,
                            firstblockstates,
                            lastblockname,
                            somethingtest,
                            lastblockstates,
                            matchingblock,
                        })
                    );
                    system.run(() => {
                        let ta: Entity;
                        try {
                            let location = {
                                x: (coordinatesa.x + coordinatesb.x) / 2,
                                y: (coordinatesa.y + coordinatesb.y) / 2,
                                z: (coordinatesa.z + coordinatesb.z) / 2,
                            };
                            player.dimension.runCommand(
                                "summon andexdb:tickingarea_6 itwalls " +
                                vTStr(location)
                            );
                            ta = player.dimension
                                .getEntitiesAtBlockLocation(location)
                                .find(
                                    (v) => v.typeId == "andexdb:tickingarea_6"
                                );
                            /*console.warn(ta, location); */ system.runTimeout(
                                    () => {
                                        try {
                                            let startTime = Date.now();
                                            let a = fillBlocksHO(
                                                coordinatesa,
                                                coordinatesb,
                                                player.dimension,
                                                firstblockname,
                                                firstblockstates,
                                                {
                                                    matchingBlock: matchingblock[0],
                                                    matchingBlockStates: matchingblock[1],
                                                }
                                            );
                                            let endTime = Date.now();
                                            player.sendMessageB(
                                                `${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`
                                            );
                                        } catch (e) {
                                            player.sendError(
                                                "§c" + e + e.stack,
                                                true
                                            );
                                        } finally {
                                            ta?.remove();
                                        }
                                    },
                                    2
                                );
                        } catch (e) {
                            player.sendError("§c" + e + e.stack, true);
                        }
                    });
                    //            try{system.run(()=>{player.dimension.fillBlocks(evaluateCoordinates(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[0][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[1][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[2][0], player.location, player.getRotation()), evaluateCoordinates(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[3][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[4][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0], player.location, player.getRotation()), BlockPermutation.resolve(switchTestB.split(" ").slice(1).join(" ").slice(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5].index+Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0].indexOf(" ")+1).split(" ")[0], extractJSONStrings(switchTestB.split(" ").slice(1).join(" ").slice(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5].index+Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0].indexOf(" ")).split(" ").slice(1).join(" "), false)[0]), {matchingBlock: BlockPermutation.resolve(getParametersFromString(switchTestB.split(" ").slice(1).join(" ").slice(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5].index+Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0].indexOf(" ")+1)).results[2], extractJSONStrings(switchTestB.split(" ").slice(1).join(" ").slice(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5].index+Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0].indexOf(" ")).split(" ").slice(1).join(" "), false)[1])}); }); }catch(e){player.sendError("§c" + e + e.stack, true)}
                }
                break;
            case !!switchTest.match(/^ipillars$/):
                {
                    eventData.cancel = true;
                    let coordinatesa = evaluateCoordinates(
                        Array.from(
                            switchTestB
                                .split(" ")
                                .slice(1)
                                .join(" ")
                                .matchAll(
                                    /\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis
                                )
                        )[0][0],
                        Array.from(
                            switchTestB
                                .split(" ")
                                .slice(1)
                                .join(" ")
                                .matchAll(
                                    /\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis
                                )
                        )[1][0],
                        Array.from(
                            switchTestB
                                .split(" ")
                                .slice(1)
                                .join(" ")
                                .matchAll(
                                    /\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis
                                )
                        )[2][0],
                        player.location,
                        player.getRotation()
                    );
                    let coordinatesb = evaluateCoordinates(
                        Array.from(
                            switchTestB
                                .split(" ")
                                .slice(1)
                                .join(" ")
                                .matchAll(
                                    /\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis
                                )
                        )[3][0],
                        Array.from(
                            switchTestB
                                .split(" ")
                                .slice(1)
                                .join(" ")
                                .matchAll(
                                    /\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis
                                )
                        )[4][0],
                        Array.from(
                            switchTestB
                                .split(" ")
                                .slice(1)
                                .join(" ")
                                .matchAll(
                                    /\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis
                                )
                        )[5][0],
                        player.location,
                        player.getRotation()
                    );
                    let firstblocknameindex = Array.from(
                        switchTestB
                            .split(" ")
                            .slice(1)
                            .join(" ")
                            .matchAll(
                                /\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis
                            )
                    )[5].index +
                        Array.from(
                            switchTestB
                                .split(" ")
                                .slice(1)
                                .join(" ")
                                .matchAll(
                                    /\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis
                                )
                        )[5][0].indexOf(" ") +
                        1;
                    let reststringaftercoordinates = switchTestB
                        .split(" ")
                        .slice(1)
                        .join(" ")
                        .slice(firstblocknameindex);
                    let firstblockname = reststringaftercoordinates.split(" ")[0];
                    let firstblockstates = reststringaftercoordinates
                        .split(" ")
                        .slice(1)
                        .join(" ")
                        .trimStart()
                        .startsWith("{")
                        ? JSONParse(
                            extractJSONStrings(
                                reststringaftercoordinates
                                    .split(" ")
                                    .slice(1)
                                    .join(" ")
                                    .trimStart(),
                                false
                            )[0]
                        )
                        : reststringaftercoordinates
                            .split(" ")
                            .slice(1)
                            .join(" ")
                            .trimStart()
                            .startsWith("[")
                            ? JSONParse(
                                extractJSONStrings(
                                    reststringaftercoordinates
                                        .split(" ")
                                        .slice(1)
                                        .join(" ")
                                        .trimStart()
                                        .replaceAll("=", ":")
                                        .replaceAll("[", "{")
                                        .replaceAll("]", "}"),
                                    false
                                )[0]
                            )
                            : undefined;
                    let lastblockname = reststringaftercoordinates
                        .split(" ")
                        .slice(1)
                        .join(" ")
                        .trimStart()
                        .startsWith("{")
                        ? reststringaftercoordinates
                            .split(" ")
                            .slice(1)
                            .join(" ")
                            .trimStart()
                            .slice(
                                extractJSONStrings(
                                    reststringaftercoordinates
                                        .split(" ")
                                        .slice(1)
                                        .join(" ")
                                        .trimStart(),
                                    false
                                )[0].length
                            )
                            .trimStart()
                            .split(" ")[0]
                        : reststringaftercoordinates
                            .split(" ")
                            .slice(1)
                            .join(" ")
                            .trimStart()
                            .startsWith("[")
                            ? reststringaftercoordinates
                                .split(" ")
                                .slice(1)
                                .join(" ")
                                .trimStart()
                                .slice(
                                    extractJSONStrings(
                                        reststringaftercoordinates
                                            .split(" ")
                                            .slice(1)
                                            .join(" ")
                                            .trimStart()
                                            .replaceAll("=", ":")
                                            .replaceAll("[", "{")
                                            .replaceAll("]", "}"),
                                        false
                                    )[0].length
                                )
                                .trimStart()
                                .split(" ")[0]
                            : reststringaftercoordinates
                                .trimStart()
                                .split(" ")
                                .slice(1)
                                .join(" ")
                                .trimStart()
                                .split(" ")[0];
                    let somethingtest = reststringaftercoordinates
                        .split(" ")
                        .slice(1)
                        .join(" ")
                        .trimStart()
                        .startsWith("{")
                        ? reststringaftercoordinates
                            .split(" ")
                            .slice(1)
                            .join(" ")
                            .trimStart()
                            .slice(
                                extractJSONStrings(
                                    reststringaftercoordinates
                                        .split(" ")
                                        .slice(1)
                                        .join(" ")
                                        .trimStart(),
                                    false
                                )[0].length
                            )
                            .trimStart()
                            .split(" ")
                            .slice(1)
                            .join(" ")
                            .trim()
                        : reststringaftercoordinates
                            .split(" ")
                            .slice(1)
                            .join(" ")
                            .trimStart()
                            .startsWith("[")
                            ? reststringaftercoordinates
                                .split(" ")
                                .slice(1)
                                .join(" ")
                                .trimStart()
                                .slice(
                                    extractJSONStrings(
                                        reststringaftercoordinates
                                            .split(" ")
                                            .slice(1)
                                            .join(" ")
                                            .trimStart()
                                            .replaceAll("=", ":")
                                            .replaceAll("[", "{")
                                            .replaceAll("]", "}"),
                                        false
                                    )[0].length
                                )
                                .trimStart()
                                .split(" ")
                                .slice(1)
                                .join(" ")
                                .trim()
                            : reststringaftercoordinates
                                .trimStart()
                                .split(" ")
                                .slice(1)
                                .join(" ")
                                .trimStart()
                                .split(" ")
                                .slice(1)
                                .join(" ")
                                .trim();
                    let lastblockstates = somethingtest.startsWith("{")
                        ? JSONParse(extractJSONStrings(somethingtest, false)[0])
                        : somethingtest.startsWith("[")
                            ? JSONParse(
                                extractJSONStrings(
                                    somethingtest
                                        .replaceAll("=", ":")
                                        .replaceAll("[", "{")
                                        .replaceAll("]", "}"),
                                    false
                                )[0]
                            )
                            : undefined;
                    let matchingblock = lastblockname == ""
                        ? [undefined, undefined]
                        : lastblockname == "keep"
                            ? ["air"]
                            : [
                                BlockTypes.get(lastblockname).id,
                                lastblockstates,
                            ]; /*
  console.warn(JSONStringify({coordinatesa, coordinatesb, firstblockname, firstblocknameindex, reststringaftercoordinates, firstblockstates, lastblockname, somethingtest, lastblockstates, matchingblock}))*/

                    system.run(() => {
                        try {
                            let startTime = Date.now();
                            let a = fillBlocksHP(
                                coordinatesa,
                                coordinatesb,
                                player.dimension,
                                firstblockname,
                                firstblockstates,
                                {
                                    matchingBlock: matchingblock[0],
                                    matchingBlockStates: matchingblock[1],
                                }
                            );
                            let endTime = Date.now();
                            player.sendMessageB(
                                `${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`
                            );
                        } catch (e) {
                            player.sendError("§c" + e + e.stack, true);
                        }
                    });
                    //            try{system.run(()=>{player.dimension.fillBlocks(evaluateCoordinates(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[0][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[1][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[2][0], player.location, player.getRotation()), evaluateCoordinates(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[3][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[4][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0], player.location, player.getRotation()), BlockPermutation.resolve(switchTestB.split(" ").slice(1).join(" ").slice(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5].index+Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0].indexOf(" ")+1).split(" ")[0], extractJSONStrings(switchTestB.split(" ").slice(1).join(" ").slice(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5].index+Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0].indexOf(" ")).split(" ").slice(1).join(" "), false)[0]), {matchingBlock: BlockPermutation.resolve(getParametersFromString(switchTestB.split(" ").slice(1).join(" ").slice(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5].index+Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0].indexOf(" ")+1)).results[2], extractJSONStrings(switchTestB.split(" ").slice(1).join(" ").slice(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5].index+Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0].indexOf(" ")).split(" ").slice(1).join(" "), false)[1])}); }); }catch(e){player.sendError("§c" + e + e.stack, true)}
                }
                break;
            case !!switchTest.match(/^itpillars$/):
                {
                    eventData.cancel = true;
                    let argsa = evaluateParameters(switchTestB, [
                        "presetText",
                        "Vector",
                        "Vector",
                        "Vector",
                        "Vector",
                        "Vector",
                        "Vector",
                        "string",
                    ]);
                    let args = argsa.args;
                    let argsaextra = argsa.extra;
                    let coordinatesa = evaluateCoordinates(
                        args[1],
                        args[2],
                        args[3],
                        player.location,
                        player.getRotation()
                    );
                    let coordinatesb = evaluateCoordinates(
                        args[4],
                        args[5],
                        args[6],
                        player.location,
                        player.getRotation()
                    );
                    //let firstblocknameindex = Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5].index+Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0].indexOf(" ")+1
                    //let reststringaftercoordinates = switchTestB.split(" ").slice(1).join(" ").slice(firstblocknameindex)
                    let firstblockname = args[7];
                    let firstblockstates = argsa.extra
                        .trimStart()
                        .startsWith("{")
                        ? JSONParse(
                            extractJSONStrings(
                                argsa.extra.trimStart(),
                                false
                            )[0]
                        )
                        : argsa.extra.trimStart().startsWith("[")
                            ? JSONParse(
                                extractJSONStrings(
                                    argsa.extra
                                        .trimStart()
                                        .replaceAll("=", ":")
                                        .replaceAll("[", "{")
                                        .replaceAll("]", "}"),
                                    false
                                )[0]
                            )
                            : undefined;
                    let lastblockname = argsa.extra.trimStart().startsWith("{")
                        ? argsa.extra
                            .trimStart()
                            .slice(
                                extractJSONStrings(
                                    argsa.extra.trimStart(),
                                    false
                                )[0].length
                            )
                            .trimStart()
                            .split(" ")[0]
                        : argsa.extra.trimStart().startsWith("[")
                            ? argsa.extra
                                .trimStart()
                                .slice(
                                    extractJSONStrings(
                                        argsa.extra
                                            .trimStart()
                                            .replaceAll("=", ":")
                                            .replaceAll("[", "{")
                                            .replaceAll("]", "}"),
                                        false
                                    )[0].length
                                )
                                .trimStart()
                                .split(" ")[0]
                            : argsa.extra.trimStart().split(" ")[0];
                    let somethingtest = argsa.extra.trimStart().startsWith("{")
                        ? argsa.extra
                            .trimStart()
                            .slice(
                                extractJSONStrings(
                                    argsa.extra.trimStart(),
                                    false
                                )[0].length
                            )
                            .trimStart()
                            .split(" ")
                            .slice(1)
                            .join(" ")
                            .trim()
                        : argsa.extra.trimStart().startsWith("[")
                            ? argsa.extra
                                .trimStart()
                                .slice(
                                    extractJSONStrings(
                                        argsa.extra
                                            .trimStart()
                                            .replaceAll("=", ":")
                                            .replaceAll("[", "{")
                                            .replaceAll("]", "}"),
                                        false
                                    )[0].length
                                )
                                .trimStart()
                                .split(" ")
                                .slice(1)
                                .join(" ")
                                .trim()
                            : argsa.extra
                                .trimStart()
                                .split(" ")
                                .slice(1)
                                .join(" ")
                                .trim();
                    let lastblockstates = somethingtest.startsWith("{")
                        ? JSONParse(extractJSONStrings(somethingtest, false)[0])
                        : somethingtest.startsWith("[")
                            ? JSONParse(
                                extractJSONStrings(
                                    somethingtest
                                        .replaceAll("=", ":")
                                        .replaceAll("[", "{")
                                        .replaceAll("]", "}"),
                                    false
                                )[0]
                            )
                            : undefined;
                    let matchingblock = lastblockname == ""
                        ? [undefined, undefined]
                        : lastblockname == "keep"
                            ? ["air"]
                            : [
                                BlockTypes.get(lastblockname).id,
                                lastblockstates,
                            ];
                    console.warn(
                        JSONStringify({
                            coordinatesa,
                            coordinatesb,
                            firstblockname,
                            argsaextra,
                            args /*, firstblocknameindex, reststringaftercoordinates*/,
                            firstblockstates,
                            lastblockname,
                            somethingtest,
                            lastblockstates,
                            matchingblock,
                        })
                    );
                    system.run(() => {
                        let ta: Entity;
                        try {
                            let location = {
                                x: (coordinatesa.x + coordinatesb.x) / 2,
                                y: (coordinatesa.y + coordinatesb.y) / 2,
                                z: (coordinatesa.z + coordinatesb.z) / 2,
                            };
                            player.dimension.runCommand(
                                "summon andexdb:tickingarea_6 itwalls " +
                                vTStr(location)
                            );
                            ta = player.dimension
                                .getEntitiesAtBlockLocation(location)
                                .find(
                                    (v) => v.typeId == "andexdb:tickingarea_6"
                                );
                            /*console.warn(ta, location); */ system.runTimeout(
                                    () => {
                                        try {
                                            let startTime = Date.now();
                                            let a = fillBlocksHP(
                                                coordinatesa,
                                                coordinatesb,
                                                player.dimension,
                                                firstblockname,
                                                firstblockstates,
                                                {
                                                    matchingBlock: matchingblock[0],
                                                    matchingBlockStates: matchingblock[1],
                                                }
                                            );
                                            let endTime = Date.now();
                                            player.sendMessageB(
                                                `${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`
                                            );
                                        } catch (e) {
                                            player.sendError(
                                                "§c" + e + e.stack,
                                                true
                                            );
                                        } finally {
                                            ta?.remove();
                                        }
                                    },
                                    2
                                );
                        } catch (e) {
                            player.sendError("§c" + e + e.stack, true);
                        }
                    });
                    //            try{system.run(()=>{player.dimension.fillBlocks(evaluateCoordinates(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[0][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[1][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[2][0], player.location, player.getRotation()), evaluateCoordinates(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[3][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[4][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0], player.location, player.getRotation()), BlockPermutation.resolve(switchTestB.split(" ").slice(1).join(" ").slice(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5].index+Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0].indexOf(" ")+1).split(" ")[0], extractJSONStrings(switchTestB.split(" ").slice(1).join(" ").slice(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5].index+Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0].indexOf(" ")).split(" ").slice(1).join(" "), false)[0]), {matchingBlock: BlockPermutation.resolve(getParametersFromString(switchTestB.split(" ").slice(1).join(" ").slice(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5].index+Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0].indexOf(" ")+1)).results[2], extractJSONStrings(switchTestB.split(" ").slice(1).join(" ").slice(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5].index+Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0].indexOf(" ")).split(" ").slice(1).join(" "), false)[1])}); }); }catch(e){player.sendError("§c" + e + e.stack, true)}
                }
                break;
            case !!switchTest.match(/^igfill$/):
                {
                    eventData.cancel = true;
                    let coordinatesa = evaluateCoordinates(
                        Array.from(
                            switchTestB
                                .split(" ")
                                .slice(1)
                                .join(" ")
                                .matchAll(
                                    /\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis
                                )
                        )[0][0],
                        Array.from(
                            switchTestB
                                .split(" ")
                                .slice(1)
                                .join(" ")
                                .matchAll(
                                    /\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis
                                )
                        )[1][0],
                        Array.from(
                            switchTestB
                                .split(" ")
                                .slice(1)
                                .join(" ")
                                .matchAll(
                                    /\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis
                                )
                        )[2][0],
                        player.location,
                        player.getRotation()
                    );
                    let coordinatesb = evaluateCoordinates(
                        Array.from(
                            switchTestB
                                .split(" ")
                                .slice(1)
                                .join(" ")
                                .matchAll(
                                    /\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis
                                )
                        )[3][0],
                        Array.from(
                            switchTestB
                                .split(" ")
                                .slice(1)
                                .join(" ")
                                .matchAll(
                                    /\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis
                                )
                        )[4][0],
                        Array.from(
                            switchTestB
                                .split(" ")
                                .slice(1)
                                .join(" ")
                                .matchAll(
                                    /\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis
                                )
                        )[5][0],
                        player.location,
                        player.getRotation()
                    );
                    let firstblocknameindex = Array.from(
                        switchTestB
                            .split(" ")
                            .slice(1)
                            .join(" ")
                            .matchAll(
                                /\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis
                            )
                    )[5].index +
                        Array.from(
                            switchTestB
                                .split(" ")
                                .slice(1)
                                .join(" ")
                                .matchAll(
                                    /\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis
                                )
                        )[5][0].indexOf(" ") +
                        1;
                    let reststringaftercoordinates = switchTestB
                        .split(" ")
                        .slice(1)
                        .join(" ")
                        .slice(firstblocknameindex);
                    let firstblockname = reststringaftercoordinates.split(" ")[0];
                    let firstblockstates = reststringaftercoordinates
                        .split(" ")
                        .slice(1)
                        .join(" ")
                        .trimStart()
                        .startsWith("{")
                        ? JSONParse(
                            extractJSONStrings(
                                reststringaftercoordinates
                                    .split(" ")
                                    .slice(1)
                                    .join(" ")
                                    .trimStart(),
                                false
                            )[0]
                        )
                        : reststringaftercoordinates
                            .split(" ")
                            .slice(1)
                            .join(" ")
                            .trimStart()
                            .startsWith("[")
                            ? JSONParse(
                                extractJSONStrings(
                                    reststringaftercoordinates
                                        .split(" ")
                                        .slice(1)
                                        .join(" ")
                                        .trimStart()
                                        .replaceAll("=", ":")
                                        .replaceAll("[", "{")
                                        .replaceAll("]", "}"),
                                    false
                                )[0]
                            )
                            : undefined;
                    let lastblockname = reststringaftercoordinates
                        .split(" ")
                        .slice(1)
                        .join(" ")
                        .trimStart()
                        .startsWith("{")
                        ? reststringaftercoordinates
                            .split(" ")
                            .slice(1)
                            .join(" ")
                            .trimStart()
                            .slice(
                                extractJSONStrings(
                                    reststringaftercoordinates
                                        .split(" ")
                                        .slice(1)
                                        .join(" ")
                                        .trimStart(),
                                    false
                                )[0].length
                            )
                            .trimStart()
                            .split(" ")[0]
                        : reststringaftercoordinates
                            .split(" ")
                            .slice(1)
                            .join(" ")
                            .trimStart()
                            .startsWith("[")
                            ? reststringaftercoordinates
                                .split(" ")
                                .slice(1)
                                .join(" ")
                                .trimStart()
                                .slice(
                                    extractJSONStrings(
                                        reststringaftercoordinates
                                            .split(" ")
                                            .slice(1)
                                            .join(" ")
                                            .trimStart()
                                            .replaceAll("=", ":")
                                            .replaceAll("[", "{")
                                            .replaceAll("]", "}"),
                                        false
                                    )[0].length
                                )
                                .trimStart()
                                .split(" ")[0]
                            : reststringaftercoordinates
                                .trimStart()
                                .split(" ")
                                .slice(1)
                                .join(" ")
                                .trimStart()
                                .split(" ")[0];
                    let somethingtest = reststringaftercoordinates
                        .split(" ")
                        .slice(1)
                        .join(" ")
                        .trimStart()
                        .startsWith("{")
                        ? reststringaftercoordinates
                            .split(" ")
                            .slice(1)
                            .join(" ")
                            .trimStart()
                            .slice(
                                extractJSONStrings(
                                    reststringaftercoordinates
                                        .split(" ")
                                        .slice(1)
                                        .join(" ")
                                        .trimStart(),
                                    false
                                )[0].length
                            )
                            .trimStart()
                            .split(" ")
                            .slice(1)
                            .join(" ")
                            .trim()
                        : reststringaftercoordinates
                            .split(" ")
                            .slice(1)
                            .join(" ")
                            .trimStart()
                            .startsWith("[")
                            ? reststringaftercoordinates
                                .split(" ")
                                .slice(1)
                                .join(" ")
                                .trimStart()
                                .slice(
                                    extractJSONStrings(
                                        reststringaftercoordinates
                                            .split(" ")
                                            .slice(1)
                                            .join(" ")
                                            .trimStart()
                                            .replaceAll("=", ":")
                                            .replaceAll("[", "{")
                                            .replaceAll("]", "}"),
                                        false
                                    )[0].length
                                )
                                .trimStart()
                                .split(" ")
                                .slice(1)
                                .join(" ")
                                .trim()
                            : reststringaftercoordinates
                                .trimStart()
                                .split(" ")
                                .slice(1)
                                .join(" ")
                                .trimStart()
                                .split(" ")
                                .slice(1)
                                .join(" ")
                                .trim();
                    let lastblockstates = somethingtest.startsWith("{")
                        ? JSONParse(extractJSONStrings(somethingtest, false)[0])
                        : somethingtest.startsWith("[")
                            ? JSONParse(
                                extractJSONStrings(
                                    somethingtest
                                        .replaceAll("=", ":")
                                        .replaceAll("[", "{")
                                        .replaceAll("]", "}"),
                                    false
                                )[0]
                            )
                            : undefined;
                    let matchingblock = lastblockname == ""
                        ? undefined
                        : lastblockname == "keep"
                            ? ["air"]
                            : [
                                BlockTypes.get(lastblockname).id,
                                lastblockstates,
                            ]; /*
  console.warn(JSONStringify({coordinatesa, coordinatesb, firstblockname, firstblocknameindex, reststringaftercoordinates, firstblockstates, lastblockname, somethingtest, lastblockstates, matchingblock}))*/

                    try {
                        system.run(() => {
                            player.sendMessageB(
                                "IFill Command Started, to cancel type in " +
                                String(
                                    world.getDynamicProperty(
                                        "andexdbSettings:chatCommandPrefix"
                                    ) ?? "\\"
                                ) +
                                "stopgen " +
                                system.runJob(
                                    fillBlocksCG(
                                        coordinatesa,
                                        coordinatesb,
                                        player.dimension,
                                        firstblockname,
                                        firstblockstates,
                                        matchingblock?.[0],
                                        matchingblock?.[1],
                                        false,
                                        (
                                            a,
                                            timea,
                                            timeb,
                                            totalTime,
                                            player
                                        ) => {
                                            player.sendMessageB(
                                                `${a == 0 ? "§c" : ""}${a} blocks filled in ${totalTime} ms`
                                            );
                                        },
                                        player
                                    )
                                )
                            );
                        });
                    } catch (e) {
                        player.sendError("§c" + e + e.stack, true);
                    }
                    //            try{system.run(()=>{player.dimension.fillBlocks(evaluateCoordinates(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[0][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[1][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[2][0], player.location, player.getRotation()), evaluateCoordinates(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[3][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[4][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0], player.location, player.getRotation()), BlockPermutation.resolve(switchTestB.split(" ").slice(1).join(" ").slice(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5].index+Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0].indexOf(" ")+1).split(" ")[0], extractJSONStrings(switchTestB.split(" ").slice(1).join(" ").slice(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5].index+Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0].indexOf(" ")).split(" ").slice(1).join(" "), false)[0]), {matchingBlock: BlockPermutation.resolve(getParametersFromString(switchTestB.split(" ").slice(1).join(" ").slice(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5].index+Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0].indexOf(" ")+1)).results[2], extractJSONStrings(switchTestB.split(" ").slice(1).join(" ").slice(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5].index+Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0].indexOf(" ")).split(" ").slice(1).join(" "), false)[1])}); }); }catch(e){player.sendError("§c" + e + e.stack, true)}
                }
                break;
            case !!switchTest.match(/^iogfill$/):
                {
                    eventData.cancel = true;
                    let coordinatesa = evaluateCoordinates(
                        Array.from(
                            switchTestB
                                .split(" ")
                                .slice(1)
                                .join(" ")
                                .matchAll(
                                    /\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis
                                )
                        )[0][0],
                        Array.from(
                            switchTestB
                                .split(" ")
                                .slice(1)
                                .join(" ")
                                .matchAll(
                                    /\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis
                                )
                        )[1][0],
                        Array.from(
                            switchTestB
                                .split(" ")
                                .slice(1)
                                .join(" ")
                                .matchAll(
                                    /\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis
                                )
                        )[2][0],
                        player.location,
                        player.getRotation()
                    );
                    let coordinatesb = evaluateCoordinates(
                        Array.from(
                            switchTestB
                                .split(" ")
                                .slice(1)
                                .join(" ")
                                .matchAll(
                                    /\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis
                                )
                        )[3][0],
                        Array.from(
                            switchTestB
                                .split(" ")
                                .slice(1)
                                .join(" ")
                                .matchAll(
                                    /\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis
                                )
                        )[4][0],
                        Array.from(
                            switchTestB
                                .split(" ")
                                .slice(1)
                                .join(" ")
                                .matchAll(
                                    /\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis
                                )
                        )[5][0],
                        player.location,
                        player.getRotation()
                    );
                    let firstblocknameindex = Array.from(
                        switchTestB
                            .split(" ")
                            .slice(1)
                            .join(" ")
                            .matchAll(
                                /\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis
                            )
                    )[5].index +
                        Array.from(
                            switchTestB
                                .split(" ")
                                .slice(1)
                                .join(" ")
                                .matchAll(
                                    /\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis
                                )
                        )[5][0].indexOf(" ") +
                        1;
                    let reststringaftercoordinates = switchTestB
                        .split(" ")
                        .slice(1)
                        .join(" ")
                        .slice(firstblocknameindex);
                    let firstblockname = reststringaftercoordinates.split(" ")[0];
                    let firstblockstates = reststringaftercoordinates
                        .split(" ")
                        .slice(1)
                        .join(" ")
                        .trimStart()
                        .startsWith("{")
                        ? JSONParse(
                            extractJSONStrings(
                                reststringaftercoordinates
                                    .split(" ")
                                    .slice(1)
                                    .join(" ")
                                    .trimStart(),
                                false
                            )[0]
                        )
                        : reststringaftercoordinates
                            .split(" ")
                            .slice(1)
                            .join(" ")
                            .trimStart()
                            .startsWith("[")
                            ? JSONParse(
                                extractJSONStrings(
                                    reststringaftercoordinates
                                        .split(" ")
                                        .slice(1)
                                        .join(" ")
                                        .trimStart()
                                        .replaceAll("=", ":")
                                        .replaceAll("[", "{")
                                        .replaceAll("]", "}"),
                                    false
                                )[0]
                            )
                            : undefined;
                    let lastblockname = reststringaftercoordinates
                        .split(" ")
                        .slice(1)
                        .join(" ")
                        .trimStart()
                        .startsWith("{")
                        ? reststringaftercoordinates
                            .split(" ")
                            .slice(1)
                            .join(" ")
                            .trimStart()
                            .slice(
                                extractJSONStrings(
                                    reststringaftercoordinates
                                        .split(" ")
                                        .slice(1)
                                        .join(" ")
                                        .trimStart(),
                                    false
                                )[0].length
                            )
                            .trimStart()
                            .split(" ")[0]
                        : reststringaftercoordinates
                            .split(" ")
                            .slice(1)
                            .join(" ")
                            .trimStart()
                            .startsWith("[")
                            ? reststringaftercoordinates
                                .split(" ")
                                .slice(1)
                                .join(" ")
                                .trimStart()
                                .slice(
                                    extractJSONStrings(
                                        reststringaftercoordinates
                                            .split(" ")
                                            .slice(1)
                                            .join(" ")
                                            .trimStart()
                                            .replaceAll("=", ":")
                                            .replaceAll("[", "{")
                                            .replaceAll("]", "}"),
                                        false
                                    )[0].length
                                )
                                .trimStart()
                                .split(" ")[0]
                            : reststringaftercoordinates
                                .trimStart()
                                .split(" ")
                                .slice(1)
                                .join(" ")
                                .trimStart()
                                .split(" ")[0];
                    let somethingtest = reststringaftercoordinates
                        .split(" ")
                        .slice(1)
                        .join(" ")
                        .trimStart()
                        .startsWith("{")
                        ? reststringaftercoordinates
                            .split(" ")
                            .slice(1)
                            .join(" ")
                            .trimStart()
                            .slice(
                                extractJSONStrings(
                                    reststringaftercoordinates
                                        .split(" ")
                                        .slice(1)
                                        .join(" ")
                                        .trimStart(),
                                    false
                                )[0].length
                            )
                            .trimStart()
                            .split(" ")
                            .slice(1)
                            .join(" ")
                            .trim()
                        : reststringaftercoordinates
                            .split(" ")
                            .slice(1)
                            .join(" ")
                            .trimStart()
                            .startsWith("[")
                            ? reststringaftercoordinates
                                .split(" ")
                                .slice(1)
                                .join(" ")
                                .trimStart()
                                .slice(
                                    extractJSONStrings(
                                        reststringaftercoordinates
                                            .split(" ")
                                            .slice(1)
                                            .join(" ")
                                            .trimStart()
                                            .replaceAll("=", ":")
                                            .replaceAll("[", "{")
                                            .replaceAll("]", "}"),
                                        false
                                    )[0].length
                                )
                                .trimStart()
                                .split(" ")
                                .slice(1)
                                .join(" ")
                                .trim()
                            : reststringaftercoordinates
                                .trimStart()
                                .split(" ")
                                .slice(1)
                                .join(" ")
                                .trimStart()
                                .split(" ")
                                .slice(1)
                                .join(" ")
                                .trim();
                    let lastblockstates = somethingtest.startsWith("{")
                        ? JSONParse(extractJSONStrings(somethingtest, false)[0])
                        : somethingtest.startsWith("[")
                            ? JSONParse(
                                extractJSONStrings(
                                    somethingtest
                                        .replaceAll("=", ":")
                                        .replaceAll("[", "{")
                                        .replaceAll("]", "}"),
                                    false
                                )[0]
                            )
                            : undefined;
                    let matchingblock = lastblockname == ""
                        ? undefined
                        : lastblockname == "keep"
                            ? ["air"]
                            : [
                                BlockTypes.get(lastblockname).id,
                                lastblockstates,
                            ]; /*
  console.warn(JSONStringify({coordinatesa, coordinatesb, firstblockname, firstblocknameindex, reststringaftercoordinates, firstblockstates, lastblockname, somethingtest, lastblockstates, matchingblock}))*/

                    try {
                        system.run(() => {
                            player.sendMessageB(
                                "IOFill Generator/Job Started, to cancel type in " +
                                String(
                                    world.getDynamicProperty(
                                        "andexdbSettings:chatCommandPrefix"
                                    ) ?? "\\"
                                ) +
                                "stopgen " +
                                system.runJob(
                                    fillBlocksCG(
                                        coordinatesa,
                                        coordinatesb,
                                        player.dimension,
                                        firstblockname,
                                        firstblockstates,
                                        matchingblock?.[0],
                                        matchingblock?.[1],
                                        false,
                                        (
                                            a,
                                            timea,
                                            timeb,
                                            totalTime,
                                            player
                                        ) => {
                                            player.sendMessageB(
                                                `${a == 0 ? "§c" : ""}${a} blocks filled in ${totalTime} ms`
                                            );
                                        },
                                        player
                                    )
                                )
                            );
                        });
                    } catch (e) {
                        player.sendError("§c" + e + e.stack, true);
                    }
                    //            try{system.run(()=>{player.dimension.fillBlocks(evaluateCoordinates(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[0][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[1][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[2][0], player.location, player.getRotation()), evaluateCoordinates(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[3][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[4][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0], player.location, player.getRotation()), BlockPermutation.resolve(switchTestB.split(" ").slice(1).join(" ").slice(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5].index+Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0].indexOf(" ")+1).split(" ")[0], extractJSONStrings(switchTestB.split(" ").slice(1).join(" ").slice(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5].index+Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0].indexOf(" ")).split(" ").slice(1).join(" "), false)[0]), {matchingBlock: BlockPermutation.resolve(getParametersFromString(switchTestB.split(" ").slice(1).join(" ").slice(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5].index+Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0].indexOf(" ")+1)).results[2], extractJSONStrings(switchTestB.split(" ").slice(1).join(" ").slice(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5].index+Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0].indexOf(" ")).split(" ").slice(1).join(" "), false)[1])}); }); }catch(e){player.sendError("§c" + e + e.stack, true)}
                }
                break;
            case !!switchTest.match(/^stopgen$/):
                {
                    eventData.cancel = true;
                    try {
                        system.clearJob(Number(switchTestB.split(" ")[1]));
                        player.sendMessageB(
                            `Successfully Clear Job/Generator With ID: ${switchTestB.split(" ")[1]}`
                        );
                    } catch (e) {
                        player.sendError("§c" + e + e.stack, true);
                    }
                    //            try{system.run(()=>{player.dimension.fillBlocks(evaluateCoordinates(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[0][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[1][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[2][0], player.location, player.getRotation()), evaluateCoordinates(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[3][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[4][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0], player.location, player.getRotation()), BlockPermutation.resolve(switchTestB.split(" ").slice(1).join(" ").slice(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5].index+Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0].indexOf(" ")+1).split(" ")[0], extractJSONStrings(switchTestB.split(" ").slice(1).join(" ").slice(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5].index+Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0].indexOf(" ")).split(" ").slice(1).join(" "), false)[0]), {matchingBlock: BlockPermutation.resolve(getParametersFromString(switchTestB.split(" ").slice(1).join(" ").slice(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5].index+Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0].indexOf(" ")+1)).results[2], extractJSONStrings(switchTestB.split(" ").slice(1).join(" ").slice(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5].index+Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0].indexOf(" ")).split(" ").slice(1).join(" "), false)[1])}); }); }catch(e){player.sendError("§c" + e + e.stack, true)}
                }
                break;
            case !!switchTest.match(/^ingfill$/):
                {
                    eventData.cancel = true;
                    let coordinatesa = evaluateCoordinates(
                        Array.from(
                            switchTestB
                                .split(" ")
                                .slice(1)
                                .join(" ")
                                .matchAll(
                                    /\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis
                                )
                        )[0][0],
                        Array.from(
                            switchTestB
                                .split(" ")
                                .slice(1)
                                .join(" ")
                                .matchAll(
                                    /\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis
                                )
                        )[1][0],
                        Array.from(
                            switchTestB
                                .split(" ")
                                .slice(1)
                                .join(" ")
                                .matchAll(
                                    /\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis
                                )
                        )[2][0],
                        player.location,
                        player.getRotation()
                    );
                    let coordinatesb = evaluateCoordinates(
                        Array.from(
                            switchTestB
                                .split(" ")
                                .slice(1)
                                .join(" ")
                                .matchAll(
                                    /\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis
                                )
                        )[3][0],
                        Array.from(
                            switchTestB
                                .split(" ")
                                .slice(1)
                                .join(" ")
                                .matchAll(
                                    /\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis
                                )
                        )[4][0],
                        Array.from(
                            switchTestB
                                .split(" ")
                                .slice(1)
                                .join(" ")
                                .matchAll(
                                    /\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis
                                )
                        )[5][0],
                        player.location,
                        player.getRotation()
                    );
                    let firstblocknameindex = Array.from(
                        switchTestB
                            .split(" ")
                            .slice(1)
                            .join(" ")
                            .matchAll(
                                /\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis
                            )
                    )[5].index +
                        Array.from(
                            switchTestB
                                .split(" ")
                                .slice(1)
                                .join(" ")
                                .matchAll(
                                    /\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis
                                )
                        )[5][0].indexOf(" ") +
                        1;
                    let reststringaftercoordinates = switchTestB
                        .split(" ")
                        .slice(1)
                        .join(" ")
                        .slice(firstblocknameindex);
                    let firstblockname = reststringaftercoordinates.split(" ")[0];
                    let firstblockstates = reststringaftercoordinates
                        .split(" ")
                        .slice(1)
                        .join(" ")
                        .trimStart()
                        .startsWith("{")
                        ? JSONParse(
                            extractJSONStrings(
                                reststringaftercoordinates
                                    .split(" ")
                                    .slice(1)
                                    .join(" ")
                                    .trimStart(),
                                false
                            )[0]
                        )
                        : reststringaftercoordinates
                            .split(" ")
                            .slice(1)
                            .join(" ")
                            .trimStart()
                            .startsWith("[")
                            ? JSONParse(
                                extractJSONStrings(
                                    reststringaftercoordinates
                                        .split(" ")
                                        .slice(1)
                                        .join(" ")
                                        .trimStart()
                                        .replaceAll("=", ":")
                                        .replaceAll("[", "{")
                                        .replaceAll("]", "}"),
                                    false
                                )[0]
                            )
                            : undefined;
                    let lastblockname = reststringaftercoordinates
                        .split(" ")
                        .slice(1)
                        .join(" ")
                        .trimStart()
                        .startsWith("{")
                        ? reststringaftercoordinates
                            .split(" ")
                            .slice(1)
                            .join(" ")
                            .trimStart()
                            .slice(
                                extractJSONStrings(
                                    reststringaftercoordinates
                                        .split(" ")
                                        .slice(1)
                                        .join(" ")
                                        .trimStart(),
                                    false
                                )[0].length
                            )
                            .trimStart()
                            .split(" ")[0]
                        : reststringaftercoordinates
                            .split(" ")
                            .slice(1)
                            .join(" ")
                            .trimStart()
                            .startsWith("[")
                            ? reststringaftercoordinates
                                .split(" ")
                                .slice(1)
                                .join(" ")
                                .trimStart()
                                .slice(
                                    extractJSONStrings(
                                        reststringaftercoordinates
                                            .split(" ")
                                            .slice(1)
                                            .join(" ")
                                            .trimStart()
                                            .replaceAll("=", ":")
                                            .replaceAll("[", "{")
                                            .replaceAll("]", "}"),
                                        false
                                    )[0].length
                                )
                                .trimStart()
                                .split(" ")[0]
                            : reststringaftercoordinates
                                .trimStart()
                                .split(" ")
                                .slice(1)
                                .join(" ")
                                .trimStart()
                                .split(" ")[0];
                    let somethingtest = reststringaftercoordinates
                        .split(" ")
                        .slice(1)
                        .join(" ")
                        .trimStart()
                        .startsWith("{")
                        ? reststringaftercoordinates
                            .split(" ")
                            .slice(1)
                            .join(" ")
                            .trimStart()
                            .slice(
                                extractJSONStrings(
                                    reststringaftercoordinates
                                        .split(" ")
                                        .slice(1)
                                        .join(" ")
                                        .trimStart(),
                                    false
                                )[0].length
                            )
                            .trimStart()
                            .split(" ")
                            .slice(1)
                            .join(" ")
                            .trim()
                        : reststringaftercoordinates
                            .split(" ")
                            .slice(1)
                            .join(" ")
                            .trimStart()
                            .startsWith("[")
                            ? reststringaftercoordinates
                                .split(" ")
                                .slice(1)
                                .join(" ")
                                .trimStart()
                                .slice(
                                    extractJSONStrings(
                                        reststringaftercoordinates
                                            .split(" ")
                                            .slice(1)
                                            .join(" ")
                                            .trimStart()
                                            .replaceAll("=", ":")
                                            .replaceAll("[", "{")
                                            .replaceAll("]", "}"),
                                        false
                                    )[0].length
                                )
                                .trimStart()
                                .split(" ")
                                .slice(1)
                                .join(" ")
                                .trim()
                            : reststringaftercoordinates
                                .trimStart()
                                .split(" ")
                                .slice(1)
                                .join(" ")
                                .trimStart()
                                .split(" ")
                                .slice(1)
                                .join(" ")
                                .trim();
                    let lastblockstates = somethingtest.startsWith("{")
                        ? JSONParse(extractJSONStrings(somethingtest, false)[0])
                        : somethingtest.startsWith("[")
                            ? JSONParse(
                                extractJSONStrings(
                                    somethingtest
                                        .replaceAll("=", ":")
                                        .replaceAll("[", "{")
                                        .replaceAll("]", "}"),
                                    false
                                )[0]
                            )
                            : undefined;
                    let matchingblock = lastblockname == ""
                        ? undefined
                        : lastblockname == "keep"
                            ? ["air"]
                            : [
                                BlockTypes.get(lastblockname).id,
                                lastblockstates,
                            ]; /*
  console.warn(JSONStringify({coordinatesa, coordinatesb, firstblockname, firstblocknameindex, reststringaftercoordinates, firstblockstates, lastblockname, somethingtest, lastblockstates, matchingblock}))*/

                    try {
                        system.run(() => {
                            let a = system.runJob(
                                fillBlocksCG(
                                    coordinatesa,
                                    coordinatesb,
                                    player.dimension,
                                    firstblockname,
                                    firstblockstates,
                                    matchingblock?.[0],
                                    matchingblock?.[1],
                                    true,
                                    (a) => {
                                        player.sendMessageB(
                                            `${a == 0 ? "§c" : ""}${a} blocks filled`
                                        );
                                    }
                                )
                            );
                        });
                    } catch (e) {
                        player.sendError("§c" + e + e.stack, true);
                    }
                    //            try{system.run(()=>{player.dimension.fillBlocks(evaluateCoordinates(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[0][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[1][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[2][0], player.location, player.getRotation()), evaluateCoordinates(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[3][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[4][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0], player.location, player.getRotation()), BlockPermutation.resolve(switchTestB.split(" ").slice(1).join(" ").slice(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5].index+Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0].indexOf(" ")+1).split(" ")[0], extractJSONStrings(switchTestB.split(" ").slice(1).join(" ").slice(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5].index+Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0].indexOf(" ")).split(" ").slice(1).join(" "), false)[0]), {matchingBlock: BlockPermutation.resolve(getParametersFromString(switchTestB.split(" ").slice(1).join(" ").slice(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5].index+Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0].indexOf(" ")+1)).results[2], extractJSONStrings(switchTestB.split(" ").slice(1).join(" ").slice(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5].index+Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0].indexOf(" ")).split(" ").slice(1).join(" "), false)[1])}); }); }catch(e){player.sendError("§c" + e + e.stack, true)}
                }
                break;
            case !!switchTest.match(/^iongfill$/):
                {
                    eventData.cancel = true;
                    let coordinatesa = evaluateCoordinates(
                        Array.from(
                            switchTestB
                                .split(" ")
                                .slice(1)
                                .join(" ")
                                .matchAll(
                                    /\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis
                                )
                        )[0][0],
                        Array.from(
                            switchTestB
                                .split(" ")
                                .slice(1)
                                .join(" ")
                                .matchAll(
                                    /\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis
                                )
                        )[1][0],
                        Array.from(
                            switchTestB
                                .split(" ")
                                .slice(1)
                                .join(" ")
                                .matchAll(
                                    /\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis
                                )
                        )[2][0],
                        player.location,
                        player.getRotation()
                    );
                    let coordinatesb = evaluateCoordinates(
                        Array.from(
                            switchTestB
                                .split(" ")
                                .slice(1)
                                .join(" ")
                                .matchAll(
                                    /\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis
                                )
                        )[3][0],
                        Array.from(
                            switchTestB
                                .split(" ")
                                .slice(1)
                                .join(" ")
                                .matchAll(
                                    /\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis
                                )
                        )[4][0],
                        Array.from(
                            switchTestB
                                .split(" ")
                                .slice(1)
                                .join(" ")
                                .matchAll(
                                    /\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis
                                )
                        )[5][0],
                        player.location,
                        player.getRotation()
                    );
                    let firstblocknameindex = Array.from(
                        switchTestB
                            .split(" ")
                            .slice(1)
                            .join(" ")
                            .matchAll(
                                /\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis
                            )
                    )[5].index +
                        Array.from(
                            switchTestB
                                .split(" ")
                                .slice(1)
                                .join(" ")
                                .matchAll(
                                    /\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis
                                )
                        )[5][0].indexOf(" ") +
                        1;
                    let reststringaftercoordinates = switchTestB
                        .split(" ")
                        .slice(1)
                        .join(" ")
                        .slice(firstblocknameindex);
                    let firstblockname = reststringaftercoordinates.split(" ")[0];
                    let firstblockstates = reststringaftercoordinates
                        .split(" ")
                        .slice(1)
                        .join(" ")
                        .trimStart()
                        .startsWith("{")
                        ? JSONParse(
                            extractJSONStrings(
                                reststringaftercoordinates
                                    .split(" ")
                                    .slice(1)
                                    .join(" ")
                                    .trimStart(),
                                false
                            )[0]
                        )
                        : reststringaftercoordinates
                            .split(" ")
                            .slice(1)
                            .join(" ")
                            .trimStart()
                            .startsWith("[")
                            ? JSONParse(
                                extractJSONStrings(
                                    reststringaftercoordinates
                                        .split(" ")
                                        .slice(1)
                                        .join(" ")
                                        .trimStart()
                                        .replaceAll("=", ":")
                                        .replaceAll("[", "{")
                                        .replaceAll("]", "}"),
                                    false
                                )[0]
                            )
                            : undefined;
                    let lastblockname = reststringaftercoordinates
                        .split(" ")
                        .slice(1)
                        .join(" ")
                        .trimStart()
                        .startsWith("{")
                        ? reststringaftercoordinates
                            .split(" ")
                            .slice(1)
                            .join(" ")
                            .trimStart()
                            .slice(
                                extractJSONStrings(
                                    reststringaftercoordinates
                                        .split(" ")
                                        .slice(1)
                                        .join(" ")
                                        .trimStart(),
                                    false
                                )[0].length
                            )
                            .trimStart()
                            .split(" ")[0]
                        : reststringaftercoordinates
                            .split(" ")
                            .slice(1)
                            .join(" ")
                            .trimStart()
                            .startsWith("[")
                            ? reststringaftercoordinates
                                .split(" ")
                                .slice(1)
                                .join(" ")
                                .trimStart()
                                .slice(
                                    extractJSONStrings(
                                        reststringaftercoordinates
                                            .split(" ")
                                            .slice(1)
                                            .join(" ")
                                            .trimStart()
                                            .replaceAll("=", ":")
                                            .replaceAll("[", "{")
                                            .replaceAll("]", "}"),
                                        false
                                    )[0].length
                                )
                                .trimStart()
                                .split(" ")[0]
                            : reststringaftercoordinates
                                .trimStart()
                                .split(" ")
                                .slice(1)
                                .join(" ")
                                .trimStart()
                                .split(" ")[0];
                    let somethingtest = reststringaftercoordinates
                        .split(" ")
                        .slice(1)
                        .join(" ")
                        .trimStart()
                        .startsWith("{")
                        ? reststringaftercoordinates
                            .split(" ")
                            .slice(1)
                            .join(" ")
                            .trimStart()
                            .slice(
                                extractJSONStrings(
                                    reststringaftercoordinates
                                        .split(" ")
                                        .slice(1)
                                        .join(" ")
                                        .trimStart(),
                                    false
                                )[0].length
                            )
                            .trimStart()
                            .split(" ")
                            .slice(1)
                            .join(" ")
                            .trim()
                        : reststringaftercoordinates
                            .split(" ")
                            .slice(1)
                            .join(" ")
                            .trimStart()
                            .startsWith("[")
                            ? reststringaftercoordinates
                                .split(" ")
                                .slice(1)
                                .join(" ")
                                .trimStart()
                                .slice(
                                    extractJSONStrings(
                                        reststringaftercoordinates
                                            .split(" ")
                                            .slice(1)
                                            .join(" ")
                                            .trimStart()
                                            .replaceAll("=", ":")
                                            .replaceAll("[", "{")
                                            .replaceAll("]", "}"),
                                        false
                                    )[0].length
                                )
                                .trimStart()
                                .split(" ")
                                .slice(1)
                                .join(" ")
                                .trim()
                            : reststringaftercoordinates
                                .trimStart()
                                .split(" ")
                                .slice(1)
                                .join(" ")
                                .trimStart()
                                .split(" ")
                                .slice(1)
                                .join(" ")
                                .trim();
                    let lastblockstates = somethingtest.startsWith("{")
                        ? JSONParse(extractJSONStrings(somethingtest, false)[0])
                        : somethingtest.startsWith("[")
                            ? JSONParse(
                                extractJSONStrings(
                                    somethingtest
                                        .replaceAll("=", ":")
                                        .replaceAll("[", "{")
                                        .replaceAll("]", "}"),
                                    false
                                )[0]
                            )
                            : undefined;
                    let matchingblock = lastblockname == ""
                        ? undefined
                        : lastblockname == "keep"
                            ? ["air"]
                            : [
                                BlockTypes.get(lastblockname).id,
                                lastblockstates,
                            ]; /*
  console.warn(JSONStringify({coordinatesa, coordinatesb, firstblockname, firstblocknameindex, reststringaftercoordinates, firstblockstates, lastblockname, somethingtest, lastblockstates, matchingblock}))*/

                    try {
                        system.run(() => {
                            let a = fillBlocksC(
                                coordinatesa,
                                coordinatesb,
                                player.dimension,
                                firstblockname,
                                firstblockstates,
                                matchingblock?.[0],
                                matchingblock?.[1],
                                true
                            );
                            player.sendMessageB(
                                `${a == 0 ? "§c" : ""}${a} blocks filled`
                            );
                        });
                    } catch (e) {
                        player.sendError("§c" + e + e.stack, true);
                    }
                    //            try{system.run(()=>{player.dimension.fillBlocks(evaluateCoordinates(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[0][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[1][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[2][0], player.location, player.getRotation()), evaluateCoordinates(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[3][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[4][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0], player.location, player.getRotation()), BlockPermutation.resolve(switchTestB.split(" ").slice(1).join(" ").slice(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5].index+Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0].indexOf(" ")+1).split(" ")[0], extractJSONStrings(switchTestB.split(" ").slice(1).join(" ").slice(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5].index+Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0].indexOf(" ")).split(" ").slice(1).join(" "), false)[0]), {matchingBlock: BlockPermutation.resolve(getParametersFromString(switchTestB.split(" ").slice(1).join(" ").slice(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5].index+Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0].indexOf(" ")+1)).results[2], extractJSONStrings(switchTestB.split(" ").slice(1).join(" ").slice(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5].index+Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0].indexOf(" ")).split(" ").slice(1).join(" "), false)[1])}); }); }catch(e){player.sendError("§c" + e + e.stack, true)}
                }
                break;
            case !!switchTest.match(/^ifillb$/):
                {
                    eventData.cancel = true;
                    let coordinatesa = evaluateCoordinates(
                        Array.from(
                            switchTestB
                                .split(" ")
                                .slice(1)
                                .join(" ")
                                .matchAll(
                                    /\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis
                                )
                        )[0][0],
                        Array.from(
                            switchTestB
                                .split(" ")
                                .slice(1)
                                .join(" ")
                                .matchAll(
                                    /\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis
                                )
                        )[1][0],
                        Array.from(
                            switchTestB
                                .split(" ")
                                .slice(1)
                                .join(" ")
                                .matchAll(
                                    /\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis
                                )
                        )[2][0],
                        player.location,
                        player.getRotation()
                    );
                    let coordinatesb = evaluateCoordinates(
                        Array.from(
                            switchTestB
                                .split(" ")
                                .slice(1)
                                .join(" ")
                                .matchAll(
                                    /\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis
                                )
                        )[3][0],
                        Array.from(
                            switchTestB
                                .split(" ")
                                .slice(1)
                                .join(" ")
                                .matchAll(
                                    /\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis
                                )
                        )[4][0],
                        Array.from(
                            switchTestB
                                .split(" ")
                                .slice(1)
                                .join(" ")
                                .matchAll(
                                    /\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis
                                )
                        )[5][0],
                        player.location,
                        player.getRotation()
                    );
                    let firstblocknameindex = Array.from(
                        switchTestB
                            .split(" ")
                            .slice(1)
                            .join(" ")
                            .matchAll(
                                /\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis
                            )
                    )[5].index +
                        Array.from(
                            switchTestB
                                .split(" ")
                                .slice(1)
                                .join(" ")
                                .matchAll(
                                    /\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis
                                )
                        )[5][0].indexOf(" ") +
                        1;
                    let reststringaftercoordinates = switchTestB
                        .split(" ")
                        .slice(1)
                        .join(" ")
                        .slice(firstblocknameindex);
                    let firstblockname = reststringaftercoordinates.split(" ")[0];
                    let firstblockstates = reststringaftercoordinates
                        .split(" ")
                        .slice(1)
                        .join(" ")
                        .trimStart()
                        .startsWith("{")
                        ? JSONParse(
                            extractJSONStrings(
                                reststringaftercoordinates
                                    .split(" ")
                                    .slice(1)
                                    .join(" ")
                                    .trimStart(),
                                false
                            )[0]
                        )
                        : reststringaftercoordinates
                            .split(" ")
                            .slice(1)
                            .join(" ")
                            .trimStart()
                            .startsWith("[")
                            ? JSONParse(
                                extractJSONStrings(
                                    reststringaftercoordinates
                                        .split(" ")
                                        .slice(1)
                                        .join(" ")
                                        .trimStart()
                                        .replaceAll("=", ":")
                                        .replaceAll("[", "{")
                                        .replaceAll("]", "}"),
                                    false
                                )[0]
                            )
                            : undefined;
                    let lastblockname = reststringaftercoordinates
                        .split(" ")
                        .slice(1)
                        .join(" ")
                        .trimStart()
                        .startsWith("{")
                        ? reststringaftercoordinates
                            .split(" ")
                            .slice(1)
                            .join(" ")
                            .trimStart()
                            .slice(
                                extractJSONStrings(
                                    reststringaftercoordinates
                                        .split(" ")
                                        .slice(1)
                                        .join(" ")
                                        .trimStart(),
                                    false
                                )[0].length
                            )
                            .trimStart()
                            .split(" ")[0]
                        : reststringaftercoordinates
                            .split(" ")
                            .slice(1)
                            .join(" ")
                            .trimStart()
                            .startsWith("[")
                            ? reststringaftercoordinates
                                .split(" ")
                                .slice(1)
                                .join(" ")
                                .trimStart()
                                .slice(
                                    extractJSONStrings(
                                        reststringaftercoordinates
                                            .split(" ")
                                            .slice(1)
                                            .join(" ")
                                            .trimStart()
                                            .replaceAll("=", ":")
                                            .replaceAll("[", "{")
                                            .replaceAll("]", "}"),
                                        false
                                    )[0].length
                                )
                                .trimStart()
                                .split(" ")[0]
                            : reststringaftercoordinates
                                .trimStart()
                                .split(" ")
                                .slice(1)
                                .join(" ")
                                .trimStart()
                                .split(" ")[0];
                    let somethingtest = reststringaftercoordinates
                        .split(" ")
                        .slice(1)
                        .join(" ")
                        .trimStart()
                        .startsWith("{")
                        ? reststringaftercoordinates
                            .split(" ")
                            .slice(1)
                            .join(" ")
                            .trimStart()
                            .slice(
                                extractJSONStrings(
                                    reststringaftercoordinates
                                        .split(" ")
                                        .slice(1)
                                        .join(" ")
                                        .trimStart(),
                                    false
                                )[0].length
                            )
                            .trimStart()
                            .split(" ")
                            .slice(1)
                            .join(" ")
                            .trim()
                        : reststringaftercoordinates
                            .split(" ")
                            .slice(1)
                            .join(" ")
                            .trimStart()
                            .startsWith("[")
                            ? reststringaftercoordinates
                                .split(" ")
                                .slice(1)
                                .join(" ")
                                .trimStart()
                                .slice(
                                    extractJSONStrings(
                                        reststringaftercoordinates
                                            .split(" ")
                                            .slice(1)
                                            .join(" ")
                                            .trimStart()
                                            .replaceAll("=", ":")
                                            .replaceAll("[", "{")
                                            .replaceAll("]", "}"),
                                        false
                                    )[0].length
                                )
                                .trimStart()
                                .split(" ")
                                .slice(1)
                                .join(" ")
                                .trim()
                            : reststringaftercoordinates
                                .trimStart()
                                .split(" ")
                                .slice(1)
                                .join(" ")
                                .trimStart()
                                .split(" ")
                                .slice(1)
                                .join(" ")
                                .trim();
                    let lastblockstates = somethingtest.startsWith("{")
                        ? JSONParse(extractJSONStrings(somethingtest, false)[0])
                        : somethingtest.startsWith("[")
                            ? JSONParse(
                                extractJSONStrings(
                                    somethingtest
                                        .replaceAll("=", ":")
                                        .replaceAll("[", "{")
                                        .replaceAll("]", "}"),
                                    false
                                )[0]
                            )
                            : undefined;
                    let matchingblock = lastblockname == ""
                        ? undefined
                        : lastblockname == "keep"
                            ? BlockPermutation.resolve("air")
                            : BlockPermutation.resolve(
                                lastblockname,
                                lastblockstates
                            ); /*
  console.warn(JSONStringify({coordinatesa, coordinatesb, firstblockname, firstblocknameindex, reststringaftercoordinates, firstblockstates, lastblockname, somethingtest, lastblockstates, matchingblock}))*/

                    try {
                        system.run(() => {
                            let a = fillBlocksB(
                                coordinatesa,
                                coordinatesb,
                                player.dimension,
                                BlockPermutation.resolve(
                                    firstblockname,
                                    firstblockstates
                                ),
                                {
                                    blockFilter: {
                                        includePermutations: [matchingblock],
                                    },
                                }
                            );
                            player.sendMessageB(
                                `${a == 0 ? "§c" : ""}${a} blocks filled`
                            );
                        });
                    } catch (e) {
                        player.sendError("§c" + e + e.stack, true);
                    }
                    //            try{system.run(()=>{player.dimension.fillBlocks(evaluateCoordinates(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[0][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[1][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[2][0], player.location, player.getRotation()), evaluateCoordinates(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[3][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[4][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0], player.location, player.getRotation()), BlockPermutation.resolve(switchTestB.split(" ").slice(1).join(" ").slice(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5].index+Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0].indexOf(" ")+1).split(" ")[0], extractJSONStrings(switchTestB.split(" ").slice(1).join(" ").slice(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5].index+Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0].indexOf(" ")).split(" ").slice(1).join(" "), false)[0]), {matchingBlock: BlockPermutation.resolve(getParametersFromString(switchTestB.split(" ").slice(1).join(" ").slice(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5].index+Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0].indexOf(" ")+1)).results[2], extractJSONStrings(switchTestB.split(" ").slice(1).join(" ").slice(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5].index+Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0].indexOf(" ")).split(" ").slice(1).join(" "), false)[1])}); }); }catch(e){player.sendError("§c" + e + e.stack, true)}
                }
                break;
            case !!switchTest.match(/^cloneitem$/):
                {
                    eventData.cancel = true;
                    system.run(() => {
                        let args = evaluateParameters(switchTestB, [
                            "presetText",
                            "targetSelector",
                        ]).args;
                        if (switchTestB.split(/\s+/g)[1]?.trim() == "~") {
                            args[1] = player.name;
                        }
                        if ((switchTestB.split(/\s+/g)[1] ?? "").trim() == "") {
                            args[1] = player.name;
                        }
                        let target = targetSelectorAllListC(
                            args[1],
                            "",
                            vTStr(player.location),
                            player
                        ).find((v) => v.typeId == "minecraft:player") as Player;
                        if (!!!target) {
                            player.sendError(
                                `§cError: No player matching the specified target selector was found. `,
                                true
                            );
                        } else {
                            target
                                .getComponent("inventory")
                                .container.addItem(
                                    player
                                        .getComponent("inventory")
                                        .container.getItem(
                                            event.sender.selectedSlotIndex
                                        )
                                        ?.clone()
                                );
                        }
                    });
                }
                break;
            case !!switchTest.match(/^copyitemfrom$/):
                {
                    //world.scoreboard.getObjective("MinsDisplay").getParticipants().filter(p=>!!!tryget(()=>p.getEntity())).forEach(p=>world.scoreboard.getObjective("balance").removeParticipant(p))
                    //if((world.scoreboard.getObjective("balance").getScore(player)??0)>JSON.parse(world.getDynamicProperty("shop:costs"))[r.selection]){world.scoreboard.getObjective("balance").addScore(player, -(JSON.parse(world.getDynamicProperty("shop:costs"))[r.selection])); player.getComponent("inventory").container.addItem(cmds.overworld.getBlock({x: 823, y: 84, z: 1037}).getComponent("inventory").container.getItem(r.selection))}
                    //${se}swdp("shop:costs", "[20, 50, 70, 80]")
                    eventData.cancel = true;
                    let args = evaluateParameters(switchTestB, [
                        "presetText",
                        "presetText",
                        "presetText",
                        "string",
                        "string",
                    ]).args;
                    if (switchTestB.split(/\s+/g)[2].trim() == "~") {
                        args[3] = player.name;
                    }
                    if ((switchTestB.split(/\s+/g)[2].trim() ?? "") == "") {
                        args[3] = player.name;
                    }
                    let from = world
                        .getAllPlayers()
                        .find((_) => _.name == args[3]);
                    if (switchTestB.split(/\s+/g)[2].trim() == "~") {
                        args[4] = player.name;
                    }
                    if ((switchTestB.split(/\s+/g)[2].trim() ?? "") == "") {
                        args[4] = player.name;
                    }
                    let to = world
                        .getAllPlayers()
                        .find((_) => _.name == args[4]);
                    if (!!!from) {
                        player.sendError(
                            `§cError: Unable to find player with the name ${args[3]}. `,
                            true
                        );
                    } else if (!!!to) {
                        player.sendError(
                            `§cError: Unable to find player with the name ${args[4]}. `,
                            true
                        );
                    } else {
                        const fromslot = getSlotFromParsedSlot(
                            parseSlot(args[1] ?? "~"),
                            {
                                container: from?.inventory?.container,
                                equipment: from?.equippable,
                                selectedSlotIndex: from?.selectedSlotIndex,
                            }
                        );
                        const toslot = getSlotFromParsedSlot(
                            parseSlot(args[2] ?? "~"),
                            {
                                container: to?.inventory?.container,
                                equipment: to?.equippable,
                                selectedSlotIndex: to?.selectedSlotIndex,
                            }
                        );
                        system.run(() => {
                            if (toslot instanceof PlayerCursorInventoryComponent) {
                                player.sendError(
                                    "§cYou cannot modify the item inside of a player's cursor inventory slot.",
                                    true
                                );
                                return;
                            }
                            toslot.setItem(
                                fromslot instanceof
                                    PlayerCursorInventoryComponent
                                    ? fromslot.item
                                    : fromslot.getItem()
                            );
                            player.sendMessageB(
                                `Successfully copied item from slot ${args[1]} of ${from.name}'s inventory to slot ${args[2]} of ${to.name}'s inventory. `
                            );
                        });
                    }
                }
                break;
            case !!switchTest.match(/^copyitem$/):
                {
                    //world.scoreboard.getObjective("MinsDisplay").getParticipants().filter(p=>!!!tryget(()=>p.getEntity())).forEach(p=>world.scoreboard.getObjective("balance").removeParticipant(p))
                    //if((world.scoreboard.getObjective("balance").getScore(player)??0)>JSON.parse(world.getDynamicProperty("shop:costs"))[r.selection]){world.scoreboard.getObjective("balance").addScore(player, -(JSON.parse(world.getDynamicProperty("shop:costs"))[r.selection])); player.getComponent("inventory").container.addItem(cmds.overworld.getBlock({x: 823, y: 84, z: 1037}).getComponent("inventory").container.getItem(r.selection))}
                    //${se}swdp("shop:costs", "[20, 50, 70, 80]")
                    eventData.cancel = true;
                    let args = evaluateParametersOld(
                        ["presetText", "presetText", "string"],
                        switchTestB
                    ).args;
                    if (switchTestB.split(/\s+/g)[2].trim() == "~") {
                        args[2] = player.name;
                    }
                    if ((switchTestB.split(/\s+/g)[2].trim() ?? "") == "") {
                        args[2] = player.name;
                    }
                    let target = world
                        .getAllPlayers()
                        .find((_) => _.name == args[2]);
                    if (!!!target) {
                        player.sendError(
                            `§cError: Unable to find player with the name ${args[2]}. `,
                            true
                        );
                    } else {
                        if (switchTestB.split(/\s+/g)[1].trim() == "~") {
                            args[1] = target.selectedSlotIndex;
                        }
                        let slot = getSlotFromParsedSlot(
                            parseSlot(String(args[1])),
                            {
                                container: target?.getComponent("inventory")
                                    ?.container,
                                equipment: target?.getComponent("equippable"),
                                selectedSlotIndex: target?.selectedSlotIndex,
                            }
                        );
                        system.run(() => {
                            if (slot instanceof PlayerCursorInventoryComponent) {
                                player.sendError(
                                    "§cYou cannot modify the item inside of a player's cursor inventory slot.",
                                    true
                                );
                                return;
                            }
                            if (String(args[1]).match(/^\d+$/)) {
                                target
                                    .getComponent("inventory")
                                    .container.setItem(
                                        Number(args[1]),
                                        player
                                            .getComponent("inventory")
                                            .container.getItem(
                                                player.selectedSlotIndex
                                            )
                                    );
                            } else {
                                slot.setItem(
                                    player
                                        .getComponent("inventory")
                                        .container.getItem(
                                            player.selectedSlotIndex
                                        )
                                );
                            }
                            player.sendMessageB(
                                `Successfully copied item to slot ${args[1]} of ${target.name}'s inventory. `
                            );
                        });
                    }
                }
                break;
            case !!switchTest.match(/^dupeitem$/):
                {
                    eventData.cancel = true;
                    let args = evaluateParametersOld(
                        ["presetText", "presetText"],
                        switchTestB
                    ).args;
                    if ((args[1] ?? "").trim() == "~" ||
                        (args[1] ?? "").trim() == "") {
                        args[1] = player.selectedSlotIndex;
                    }
                    //console.warn(args)
                    let slot = getSlotFromParsedSlot(
                        parseSlot(String(args[1])),
                        {
                            container: player?.getComponent("inventory")?.container,
                            equipment: player?.getComponent("equippable"),
                            selectedSlotIndex: player?.selectedSlotIndex,
                        }
                    );
                    system.run(() => {
                        if (String(args[1]).match(/^\d+$/)) {
                            player
                                .getComponent("inventory")
                                .container.addItem(
                                    player
                                        .getComponent("inventory")
                                        .container.getItem(Number(args[1]))
                                );
                        } else {
                            player
                                .getComponent("inventory")
                                .container.addItem(
                                    slot instanceof
                                        PlayerCursorInventoryComponent
                                        ? slot.item
                                        : slot.getItem()
                                );
                        }
                        player.sendMessageB(
                            `Successfully duped item in slot ${String(
                                args[1]
                            )}. `
                        );
                    }); /*
            system.run(()=>{let slot = [EquipmentSlot.Head, EquipmentSlot.Chest,  EquipmentSlot.Legs, EquipmentSlot.Feet, EquipmentSlot.Mainhand, EquipmentSlot.Offhand][["head", "chest", "legs", "feet", "mainhand", "offhand", "helmet", "chestplate", "leggings", "boots", "hand", "otherhand", "cap", "tunic", "pants", "shoes", "righthand", "lefthand"].findIndex(v=>v==switchTestB.split(" ")[1]?.trim()?.toLowerCase())%6]??Number((!!!switchTestB.split(" ")[1]?.trim()?"~":switchTestB.split(" ")[1].trim()).replaceAll("~", String(player.selectedSlotIndex))); let fromSlot = typeof slot == "string"?player.getComponent("equippable").getEquipmentSlot(slot):player.getComponent("inventory").container.getSlot(slot); player.getComponent("inventory").container.addItem(player.getComponent("inventory").container.getItem(event.sender.selectedSlotIndex).clone())})*/

                }
                break;
            case !!switchTest.match(/^transferitem$/):
                {
                    eventData.cancel = true;
                    system.run(() => {
                        let args = evaluateParameters(switchTestB, [
                            "presetText",
                            "targetSelector",
                        ]).args;
                        if (switchTestB.split(/\s+/g)[1]?.trim() == "~") {
                            args[1] = player.name;
                        }
                        if ((switchTestB.split(/\s+/g)[1] ?? "").trim() == "") {
                            args[1] = player.name;
                        }
                        let target = targetSelectorAllListC(
                            args[1],
                            "",
                            vTStr(player.location),
                            player
                        ).find((v) => v.typeId == "minecraft:player") as Player;
                        if (!!!target) {
                            player.sendError(
                                `§cError: No player matching the specified target selector was found. `,
                                true
                            );
                        } else {
                            player
                                .getComponent("inventory")
                                .container.transferItem(
                                    player.selectedSlotIndex,
                                    target.getComponent("inventory").container
                                );
                        }
                    });
                }
                break;
            case !!switchTest.match(/^shuffleinventory$/) ||
                !!switchTest.match(/^invshuffle$/):
                {
                    eventData.cancel = true;
                    system.run(() => {
                        let args = evaluateParameters(switchTestB, [
                            "presetText",
                            "targetSelector",
                        ]).args;
                        if (switchTestB.split(/\s+/g)[1]?.trim() == "~") {
                            args[1] = player.name;
                        }
                        let targets = targetSelectorAllListC(
                            args[1],
                            "",
                            vTStr(player.location),
                            player
                        ).filter(
                            (v) => v.typeId == "minecraft:player"
                        ) as Player[];
                        if (targets.length == 0) {
                            player.sendError(
                                `§cError: No player matching the specified target selector was found. `,
                                true
                            );
                        } else {
                            let successes = [] as Player[];
                            targets.forEach((target) => {
                                try {
                                    let items = shuffle(
                                        containerToItemStackArray(
                                            target.getComponent("inventory")
                                                .container
                                        )
                                    );
                                    containerToContainerSlotArray(
                                        target.getComponent("inventory")
                                            .container
                                    ).forEach((s, i) => {
                                        s.setItem(items[i]);
                                    });
                                    successes.push(target);
                                } catch (e) {
                                    player.sendError(e + " " + e.stack, true);
                                }
                            });
                            if (successes.length == 0) {
                                player.sendError(
                                    `§cError: Some other error occured and no inventories were successfully shuffled. `,
                                    true
                                );
                            } else {
                                player.sendMessageB(
                                    `Successfully shuffled the ${successes.length == 1
                                        ? "inventory"
                                        : "inventories"} of ${successes
                                            .map((v) => v.name)
                                            .join(", ")}. `
                                );
                            }
                        }
                    });
                }
                break;
            case !!switchTest.match(/^swapitems$/):
                {
                    eventData.cancel = true;
                    system.run(() => {
                        let args = evaluateParameters(switchTestB, [
                            "presetText",
                            "presetText",
                            "presetText",
                            "targetSelector",
                            "targetSelector",
                        ]).args;
                        if ((args[4] ?? "").trim() == "") {
                            args[4] = player.name;
                        } else {
                            if ((args[4] ?? "").trim() == "~") {
                                args[4] = player.name;
                            }
                        }
                        if ((args[3] ?? "").trim() == "") {
                            args[3] = player.name;
                        } else {
                            if ((args[3] ?? "").trim() == "~") {
                                args[3] = player.name;
                            }
                        }
                        let target = targetSelectorAllListC(
                            args[1],
                            "",
                            vTStr(player.location),
                            player
                        ).find((v) => v.typeId == "minecraft:player") as Player;
                        let targetb = targetSelectorAllListC(
                            args[1],
                            "",
                            vTStr(player.location),
                            player
                        ).find((v) => v.typeId == "minecraft:player") as Player;
                        if ((args[2] ?? "").trim() == "") {
                            args[2] = String(targetb?.selectedSlotIndex);
                        }
                        if ((args[1] ?? "").trim() == "") {
                            args[1] = String(target?.selectedSlotIndex);
                        }
                        if (!!!target) {
                            player.sendError(
                                `§cError: No player matching the first specified target selector was found. `,
                                true
                            );
                        } else if (!!!targetb) {
                            player.sendError(
                                `§cError: No player matching the second specified target selector was found. `,
                                true
                            );
                        } else {
                            system.run(() => {
                                target
                                    .getComponent("inventory")
                                    .container.swapItems(
                                        Number(
                                            args[1].replace(
                                                /^~$/,
                                                String(target.selectedSlotIndex)
                                            )
                                        ),
                                        Number(
                                            args[2].replace(
                                                /^~$/,
                                                String(
                                                    targetb.selectedSlotIndex
                                                )
                                            )
                                        ),
                                        targetb.getComponent("inventory")
                                            .container
                                    );
                            });
                            player.sendMessageB(
                                `Successfully swapped slot ${args[1]} of ${target.name}'s inventory with slot ${args[2]} of ${targetb.name}'s inventory. `
                            );
                        }
                    });
                }
                break;
            case !!switchTest.match(/^clear$/):
                {
                    eventData.cancel = true;
                    let args = evaluateParametersOld(
                        [
                            "presetText",
                            "string",
                            "presetText",
                            "number",
                            "number",
                        ],
                        switchTestB
                    ).args;
                    let target = world
                        .getAllPlayers()
                        .find((_) => _.name == args[2]);
                    if (!!!target) {
                        player.sendError(
                            `§cError: Unable to find player with the name ${args[2]}. `,
                            true
                        );
                    } else {
                        let itemType = new ItemStack(args[2].trim(), 1).typeId;
                        if ((args[2] ?? "") == "") {
                            system.run(() => {
                                containerToContainerSlotArray(
                                    target.getComponent("inventory").container
                                ).forEach((v) => v.setItem());
                            });
                        } else {
                            system.run(() => {
                                containerToContainerSlotArray(
                                    target.getComponent("inventory").container
                                )
                                    .filter((v) => v.typeId == itemType)
                                    .forEach((v) => v.setItem());
                            });
                        }
                    }
                }
                break;
            case !!switchTest.match(/^takeitem$/):
                {
                    eventData.cancel = true;
                    let args = evaluateParametersOld(
                        ["presetText", "presetText", "string"],
                        switchTestB
                    ).args;
                    if (switchTestB.split(/\s+/g)[2].trim() == "~") {
                        args[2] = player.name;
                    }
                    let target = world
                        .getAllPlayers()
                        .find((_) => _.name == args[2]);
                    if (!!!target) {
                        player.sendError(
                            `§cError: Unable to find player with the name ${args[2]}. `,
                            true
                        );
                    } else {
                        if (switchTestB.split(/\s+/g)[1].trim() == "~") {
                            args[1] = target.selectedSlotIndex;
                        }
                        let slot = getSlotFromParsedSlot(
                            parseSlot(String(args[1])),
                            {
                                container: target?.getComponent("inventory")
                                    ?.container,
                                equipment: target?.getComponent("equippable"),
                                selectedSlotIndex: target?.selectedSlotIndex,
                            }
                        );
                        system.run(() => {
                            if (String(args[1]).match(/^\d+$/)) {
                                target
                                    .getComponent("inventory")
                                    .container.transferItem(
                                        Number(args[1]),
                                        player.getComponent("inventory")
                                            .container
                                    );
                            } else {
                                player
                                    .getComponent("inventory")
                                    .container.addItem(
                                        slot instanceof
                                            PlayerCursorInventoryComponent
                                            ? slot.item
                                            : slot.getItem()
                                    );
                                (slot instanceof PlayerCursorInventoryComponent
                                    ? slot.clear
                                    : slot.setItem)();
                            }
                            player.sendMessageB(
                                `Successfully took item from ${args[2]}'s inventory. `
                            );
                        });
                    }
                }
                break;
            case !!switchTest.match(/^swapinventories$/) ||
                !!switchTest.match(/^invswap$/):
                {
                    eventData.cancel = true;
                    let args = evaluateParametersOld(
                        ["presetText", "string", "string"],
                        switchTestB
                    ).args;
                    if (switchTestB.split(/\s+/g)[1]?.trim() == "~") {
                        args[1] = player.name;
                    }
                    if ((switchTestB.split(/\s+/g)[1] ?? "").trim() == "") {
                        args[1] = player.name;
                    }
                    if (switchTestB.split(/\s+/g)[2]?.trim() == "~") {
                        args[2] = player.name;
                    }
                    if ((switchTestB.split(/\s+/g)[2] ?? "").trim() == "") {
                        args[2] = player.name;
                    }
                    let target = world
                        .getAllPlayers()
                        .find((_) => _.name == args[1]);
                    let targetb = world
                        .getAllPlayers()
                        .find((_) => _.name == args[2]);
                    if (!!!target) {
                        player.sendError(
                            `§cError: Unable to find player with the name ${args[1]}. `,
                            true
                        );
                    } else if (!!!targetb) {
                        player.sendError(
                            `§cError: Unable to find player with the name ${args[2]}. `,
                            true
                        );
                    } else {
                        system.run(() => {
                            inventorySwap(target, targetb);
                            player.sendMessageB(
                                `Successfully swapped ${args[1]}'s inventory with ${args[2]}'s inventory. `
                            );
                        });
                    }
                }
                break;
            case !!switchTest.match(/^swapinventoriesb$/) ||
                !!switchTest.match(/^invswapb$/):
                {
                    eventData.cancel = true;
                    system.run(() => {
                        inventorySwapB(
                            world
                                .getAllPlayers()
                                .find(
                                    (_) => _.name == switchTestB.split('"')[1]
                                )
                                .getComponent("inventory").container,
                            world
                                .getAllPlayers()
                                .find(
                                    (_) => _.name == switchTestB.split('"')[3]
                                )
                                .getComponent("inventory").container
                        );
                    });
                }
                break;
            case !!switchTest.match(/^swaprows$/) ||
                !!switchTest.match(/^rowswap$/) ||
                !!switchTest.match(/^rs$/):
                {
                    eventData.cancel = true;
                    let args = evaluateParameters(switchTestB, [
                        "presetText",
                        "presetText",
                        "presetText",
                        "string",
                        "string",
                    ]).args;
                    if (args[3] == "~") {
                        args[3] = player.name;
                    }
                    if (!!!args[3]) {
                        args[3] = player.name;
                    }
                    if (args[4] == "~") {
                        args[4] = player.name;
                    }
                    if (!!!args[4]) {
                        args[4] = player.name;
                    }
                    const target = world
                        .getAllPlayers()
                        .find((_) => _.name == args[3]);
                    const targetb = world
                        .getAllPlayers()
                        .find((_) => _.name == args[4]);
                    args[1] ??= "0";
                    args[2] ??= "0";
                    if (!!!target) {
                        player.sendError(
                            `§cError: Unable to find player with the name ${args[3]}. `,
                            true
                        );
                    } else if (!!!targetb) {
                        player.sendError(
                            `§cError: Unable to find player with the name ${args[4]}. `,
                            true
                        );
                    } else {
                        system.run(() => {
                            const targetInventory = target.inventory;
                            const targetInventoryB = targetb.inventory;
                            if (args[1].toLowerCase() == "equipment" ||
                                args[2].toLowerCase() == "equipment") {
                                const items = args[1].toLowerCase() == "equipment"
                                    ? equippableToItemStackArray(
                                        target.equippable,
                                        true
                                    )
                                    : containerToItemStackArray(
                                        target.inventory.container
                                    ).slice(
                                        Math.round(
                                            args[1].toNumber() * 9
                                        ),
                                        Math.round(
                                            args[1].toNumber() * 9
                                        ) + 6
                                    );
                                const itemsb = args[2].toLowerCase() == "equipment"
                                    ? equippableToItemStackArray(
                                        targetb.equippable,
                                        true
                                    )
                                    : containerToItemStackArray(
                                        targetb.inventory.container
                                    ).slice(
                                        Math.round(
                                            args[1].toNumber() * 9
                                        ),
                                        Math.round(
                                            args[1].toNumber() * 9
                                        ) + 6
                                    );
                                const slotsb = args[2].toLowerCase() == "equipment"
                                    ? equippableToContainerSlotArray(
                                        targetb.equippable,
                                        true
                                    )
                                    : containerToContainerSlotArray(
                                        targetb.inventory.container
                                    ).slice(
                                        Math.round(
                                            args[2].toNumber() * 9
                                        ),
                                        Math.round(
                                            args[2].toNumber() * 9
                                        ) + 6
                                    );
                                (args[1].toLowerCase() == "equipment"
                                    ? equippableToContainerSlotArray(
                                        target.equippable,
                                        true
                                    )
                                    : containerToContainerSlotArray(
                                        target.inventory.container
                                    ).slice(
                                        Math.round(args[1].toNumber() * 9),
                                        Math.round(args[1].toNumber() * 9) + 6
                                    )
                                ).forEach((s, i) => {
                                    slotsb[i].setItem(items[i]);
                                    s.setItem(itemsb[i]);
                                });
                            } else {
                                const index = Math.round(
                                    args[1].toNumber() * 9
                                );
                                const indexb = Math.round(
                                    args[2].toNumber() * 9
                                );
                                for (let i = 0; i < 9; i++) {
                                    targetInventory.container.swapItems(
                                        i + index,
                                        i + indexb,
                                        targetInventoryB.container
                                    );
                                }
                            }
                            player.sendMessageB(
                                `Successfully swapped row ${args[1]} of ${args[3]}'s inventory with row ${args[2]} of ${args[4]}'s inventory.`
                            );
                        });
                    }
                }
                break;
            case !!switchTest.match(/^compressitems$/):
                {
                    eventData.cancel = true;
                    let args = evaluateParametersOld(
                        ["presetText", "presetText", "string"],
                        switchTestB
                    ).args;
                    if (switchTestB.split(/\s+/g)[2]?.trim() == "~") {
                        args[2] = player.name;
                    }
                    if ((switchTestB.split(/\s+/g)[2] ?? "").trim() == "") {
                        args[2] = player.name;
                    }
                    let target = world
                        .getAllPlayers()
                        .find((_) => _.name == args[2]);
                    if (!!!target) {
                        player.sendError(
                            `§cError: Unable to find player with the name ${args[2]}. `,
                            true
                        );
                    } else {
                        if ((args[1] ?? "").trim() == "" ||
                            (args[1] ?? "").trim() == "all") {
                            system.run(() => {
                                let block = player.dimension.getBlock(
                                    player.location
                                );
                                block.setType("chest");
                                inventorySwapC(
                                    target.getComponent("inventory").container,
                                    block.getComponent("inventory").container,
                                    [0, 27],
                                    [0, 27]
                                );
                                let item = block.getItemStack(1, true);
                                item.nameTag = `§r§a${target.name}'s Items: Slots 0-26§b\n${new Date(
                                    Date.now()
                                ).toUTCString()}`;
                                clearContainer(
                                    block.getComponent("inventory").container
                                );
                                inventorySwapC(
                                    target.getComponent("inventory").container,
                                    block.getComponent("inventory").container,
                                    [27, 36],
                                    [0, 27]
                                );
                                [
                                    EquipmentSlot.Head,
                                    EquipmentSlot.Chest,
                                    EquipmentSlot.Legs,
                                    EquipmentSlot.Feet,
                                    EquipmentSlot.Offhand,
                                ].forEach((v, i) => {
                                    block
                                        .getComponent("inventory")
                                        .container.setItem(
                                            9 + i,
                                            target
                                                .getComponent("equippable")
                                                .getEquipment(v)
                                        );
                                    target
                                        .getComponent("equippable")
                                        .setEquipment(v);
                                });
                                let item2 = block.getItemStack(1, true);
                                item2.nameTag = `§r§a${target.name}'s Items: Slots 27-35, Armor, and Offhand\n§b${new Date(
                                    Date.now()
                                ).toUTCString()}`;
                                clearContainer(
                                    block.getComponent("inventory").container
                                );
                                block.setType("air");
                                target
                                    .getComponent("inventory")
                                    .container.addItem(item);
                                target
                                    .getComponent("inventory")
                                    .container.addItem(item2);
                            });
                        } else if ((args[1] ?? "").trim() == "inventory") {
                            system.run(() => {
                                let block = player.dimension.getBlock(
                                    player.location
                                );
                                block.setType("chest");
                                inventorySwapC(
                                    target.getComponent("inventory").container,
                                    block.getComponent("inventory").container,
                                    [9, 36],
                                    [0, 27]
                                );
                                let item = block.getItemStack(1, true);
                                item.nameTag = `§r§a${target.name}'s Items: Slots 9-35§b\n${new Date(
                                    Date.now()
                                ).toUTCString()}`;
                                clearContainer(
                                    block.getComponent("inventory").container
                                );
                                block.setType("air");
                                target
                                    .getComponent("inventory")
                                    .container.addItem(item);
                            });
                        } else if ((args[1] ?? "").trim() == "hotbar") {
                            system.run(() => {
                                let block = player.dimension.getBlock(
                                    player.location
                                );
                                block.setType("chest");
                                inventorySwapC(
                                    target.getComponent("inventory").container,
                                    block.getComponent("inventory").container,
                                    [0, 9],
                                    [0, 9]
                                );
                                let item = block.getItemStack(1, true);
                                item.nameTag = `§r§a${target.name}'s Hotbar: Slots 0-8§b\n${new Date(
                                    Date.now()
                                ).toUTCString()}`;
                                clearContainer(
                                    block.getComponent("inventory").container
                                );
                                block.setType("air");
                                target
                                    .getComponent("inventory")
                                    .container.addItem(item);
                            });
                        } else if ((args[1] ?? "").trim() == "armor" ||
                            (args[1] ?? "").trim() == "equipment") {
                            system.run(() => {
                                let block = player.dimension.getBlock(
                                    player.location
                                );
                                block.setType("chest");
                                [
                                    EquipmentSlot.Head,
                                    EquipmentSlot.Chest,
                                    EquipmentSlot.Legs,
                                    EquipmentSlot.Feet,
                                    EquipmentSlot.Offhand,
                                ].forEach((v, i) => {
                                    block
                                        .getComponent("inventory")
                                        .container.setItem(
                                            9 + i,
                                            target
                                                .getComponent("equippable")
                                                .getEquipment(v)
                                        );
                                    target
                                        .getComponent("equippable")
                                        .setEquipment(v);
                                });
                                let item = block.getItemStack(1, true);
                                item.nameTag = `§r§a${target.name}'s Equipment: Armor and Offhand§b\n${new Date(
                                    Date.now()
                                ).toUTCString()}`;
                                clearContainer(
                                    block.getComponent("inventory").container
                                );
                                block.setType("air");
                                target
                                    .getComponent("inventory")
                                    .container.addItem(item);
                            });
                        }
                    }
                }
                break;
            case !!switchTest.match(/^compressitemsshulker$/):
                {
                    eventData.cancel = true;
                    let args = evaluateParametersOld(
                        ["presetText", "presetText", "string"],
                        switchTestB
                    ).args;
                    if (switchTestB.split(/\s+/g)[2]?.trim() == "~") {
                        args[2] = player.name;
                    }
                    if ((switchTestB.split(/\s+/g)[2] ?? "").trim() == "") {
                        args[2] = player.name;
                    }
                    let target = world
                        .getAllPlayers()
                        .find((_) => _.name == args[2]);
                    if (!!!target) {
                        player.sendError(
                            `§cError: Unable to find player with the name ${args[2]}. `,
                            true
                        );
                    } else {
                        if ((args[1] ?? "").trim() == "" ||
                            (args[1] ?? "").trim() == "all") {
                            system.run(() => {
                                let block = player.dimension.getBlock(
                                    player.location
                                );
                                block.setType("shulker_box");
                                inventorySwapC(
                                    target.getComponent("inventory").container,
                                    block.getComponent("inventory").container,
                                    [0, 27],
                                    [0, 27]
                                );
                                let item = block.getItemStack(1, true);
                                item.nameTag = `§r§a${target.name}'s Items: Slots 0-26§b\n${new Date(
                                    Date.now()
                                ).toUTCString()}`;
                                clearContainer(
                                    block.getComponent("inventory").container
                                );
                                inventorySwapC(
                                    target.getComponent("inventory").container,
                                    block.getComponent("inventory").container,
                                    [27, 36],
                                    [0, 27]
                                );
                                [
                                    EquipmentSlot.Head,
                                    EquipmentSlot.Chest,
                                    EquipmentSlot.Legs,
                                    EquipmentSlot.Feet,
                                    EquipmentSlot.Offhand,
                                ].forEach((v, i) => {
                                    block
                                        .getComponent("inventory")
                                        .container.setItem(
                                            9 + i,
                                            target
                                                .getComponent("equippable")
                                                .getEquipment(v)
                                        );
                                    target
                                        .getComponent("equippable")
                                        .setEquipment(v);
                                });
                                let item2 = block.getItemStack(1, true);
                                item2.nameTag = `§r§a${target.name}'s Items: Slots 27-35, Armor, and Offhand\n§b${new Date(
                                    Date.now()
                                ).toUTCString()}`;
                                clearContainer(
                                    block.getComponent("inventory").container
                                );
                                block.setType("air");
                                target
                                    .getComponent("inventory")
                                    .container.addItem(item);
                                target
                                    .getComponent("inventory")
                                    .container.addItem(item2);
                            });
                        } else if ((args[1] ?? "").trim() == "inventory") {
                            system.run(() => {
                                let block = player.dimension.getBlock(
                                    player.location
                                );
                                block.setType("shulker_box");
                                inventorySwapC(
                                    target.getComponent("inventory").container,
                                    block.getComponent("inventory").container,
                                    [9, 36],
                                    [0, 27]
                                );
                                let item = block.getItemStack(1, true);
                                item.nameTag = `§r§a${target.name}'s Items: Slots 9-35§b\n${new Date(
                                    Date.now()
                                ).toUTCString()}`;
                                clearContainer(
                                    block.getComponent("inventory").container
                                );
                                block.setType("air");
                                target
                                    .getComponent("inventory")
                                    .container.addItem(item);
                            });
                        } else if ((args[1] ?? "").trim() == "hotbar") {
                            system.run(() => {
                                let block = player.dimension.getBlock(
                                    player.location
                                );
                                block.setType("shulker_box");
                                inventorySwapC(
                                    target.getComponent("inventory").container,
                                    block.getComponent("inventory").container,
                                    [0, 9],
                                    [0, 9]
                                );
                                let item = block.getItemStack(1, true);
                                item.nameTag = `§r§a${target.name}'s Hotbar: Slots 0-8§b\n${new Date(
                                    Date.now()
                                ).toUTCString()}`;
                                clearContainer(
                                    block.getComponent("inventory").container
                                );
                                block.setType("air");
                                target
                                    .getComponent("inventory")
                                    .container.addItem(item);
                            });
                        } else if ((args[1] ?? "").trim() == "armor" ||
                            (args[1] ?? "").trim() == "equipment") {
                            system.run(() => {
                                let block = player.dimension.getBlock(
                                    player.location
                                );
                                block.setType("shulker_box");
                                [
                                    EquipmentSlot.Head,
                                    EquipmentSlot.Chest,
                                    EquipmentSlot.Legs,
                                    EquipmentSlot.Feet,
                                    EquipmentSlot.Offhand,
                                ].forEach((v, i) => {
                                    block
                                        .getComponent("inventory")
                                        .container.setItem(
                                            9 + i,
                                            target
                                                .getComponent("equippable")
                                                .getEquipment(v)
                                        );
                                    target
                                        .getComponent("equippable")
                                        .setEquipment(v);
                                });
                                let item = block.getItemStack(1, true);
                                item.nameTag = `§r§a${target.name}'s Equipment: Armor and Offhand§b\n${new Date(
                                    Date.now()
                                ).toUTCString()}`;
                                clearContainer(
                                    block.getComponent("inventory").container
                                );
                                block.setType("air");
                                target
                                    .getComponent("inventory")
                                    .container.addItem(item);
                            });
                        }
                    }
                }
                break;
            case !!switchTest.match(/^compressitemscontainer$/):
                {
                    eventData.cancel = true;
                    let args = evaluateParametersOld(
                        ["presetText", "presetText", "presetText", "string"],
                        switchTestB
                    ).args;
                    if (switchTestB.split(/\s+/g)[3]?.trim() == "~") {
                        args[3] = player.name;
                    }
                    if ((switchTestB.split(/\s+/g)[3] ?? "").trim() == "") {
                        args[3] = player.name;
                    }
                    let target = world
                        .getAllPlayers()
                        .find((_) => _.name == args[3]);
                    if (!!!BlockTypes.get(args[1])) {
                        player.sendMessageB(
                            `§cSyntax error: Unexpected "${args[1]}": at ${switchTestB.slice(
                                0,
                                switchTestB.indexOf(args[1])
                            )}">>${args[1]}<<"`
                        );
                    } else if (!!!target) {
                        player.sendError(
                            `§cError: Unable to find player with the name ${args[3]}. `,
                            true
                        );
                    }
                    else
                        system.run(() => {
                            if (!!!(() => {
                                let block = player.dimension.getBlock(
                                    player.location
                                );
                                block.setType(args[1]);
                                let component = block.getComponent("inventory");
                                block.setType("air");
                                return component;
                            })()) {
                                player.sendError(
                                    `§cError: Block of type ${BlockTypes.get(args[1]).id} is not a container block. `,
                                    true
                                );
                            } else {
                                if ((args[2] ?? "").trim() == "" ||
                                    (args[2] ?? "").trim() == "all") {
                                    let block = player.dimension.getBlock(
                                        player.location
                                    );
                                    let items = [] as ItemStack[];
                                    block.setType(args[1]);
                                    let runSeparate = false;
                                    let runTogether = false;
                                    for (let i = 0; i <
                                        Math.max(
                                            0,
                                            36 /
                                            block.getComponent("inventory")
                                                .container.size
                                        ); i++) {
                                        inventorySwapC(
                                            target.getComponent("inventory")
                                                .container,
                                            block.getComponent("inventory")
                                                .container,
                                            [
                                                i *
                                                block.getComponent(
                                                    "inventory"
                                                ).container.size,
                                                Math.min(
                                                    (i + 1) *
                                                    block.getComponent(
                                                        "inventory"
                                                    ).container.size,
                                                    36
                                                ),
                                            ],
                                            [
                                                0,
                                                block.getComponent("inventory")
                                                    .container.size,
                                            ]
                                        );
                                        if ((i + 1) *
                                            block.getComponent("inventory")
                                                .container.size >
                                            41) {
                                            [
                                                EquipmentSlot.Head,
                                                EquipmentSlot.Chest,
                                                EquipmentSlot.Legs,
                                                EquipmentSlot.Feet,
                                                EquipmentSlot.Offhand,
                                            ].forEach((v, ib) => {
                                                block
                                                    .getComponent("inventory")
                                                    .container.setItem(
                                                        block.getComponent(
                                                            "inventory"
                                                        ).container.size -
                                                        (Math.min(
                                                            (i + 1) *
                                                            block.getComponent(
                                                                "inventory"
                                                            ).container
                                                                .size,
                                                            36
                                                        ) -
                                                            i *
                                                            block.getComponent(
                                                                "inventory"
                                                            ).container
                                                                .size) +
                                                        ib,
                                                        target
                                                            .getComponent(
                                                                "equippable"
                                                            )
                                                            .getEquipment(v)
                                                    );
                                                target
                                                    .getComponent("equippable")
                                                    .setEquipment(v);
                                            });
                                            runTogether = true;
                                        } else {
                                            if (i + 1 >=
                                                Math.max(
                                                    0,
                                                    36 /
                                                    block.getComponent(
                                                        "inventory"
                                                    ).container.size
                                                )) {
                                                runSeparate = true;
                                            }
                                        }
                                        let item = block.getItemStack(1, true);
                                        item.nameTag = `§r§a${target.name}'s Items: Slots ${i *
                                            block.getComponent("inventory")
                                                .container.size}-${Math.min(
                                                    (i + 1) *
                                                    block.getComponent("inventory")
                                                        .container.size,
                                                    36
                                                )}${runTogether
                                                ? ", Armor, and Offhand"
                                                : ""}§b\n${new Date(
                                                    Date.now()
                                                ).toUTCString()}`;
                                        clearContainer(
                                            block.getComponent("inventory")
                                                .container
                                        );
                                        items.push(item);
                                    }
                                    if (runSeparate) {
                                        for (let i = 0; i <
                                            Math.max(
                                                0,
                                                5 /
                                                block.getComponent(
                                                    "inventory"
                                                ).container.size
                                            ); i++) {
                                            [
                                                EquipmentSlot.Head,
                                                EquipmentSlot.Chest,
                                                EquipmentSlot.Legs,
                                                EquipmentSlot.Feet,
                                                EquipmentSlot.Offhand,
                                            ]
                                                .slice(
                                                    i *
                                                    block.getComponent(
                                                        "inventory"
                                                    ).container.size,
                                                    (i + 1) *
                                                    block.getComponent(
                                                        "inventory"
                                                    ).container.size
                                                )
                                                .forEach((v, ib) => {
                                                    block
                                                        .getComponent(
                                                            "inventory"
                                                        )
                                                        .container.setItem(
                                                            ib,
                                                            target
                                                                .getComponent(
                                                                    "equippable"
                                                                )
                                                                .getEquipment(v)
                                                        );
                                                    target
                                                        .getComponent(
                                                            "equippable"
                                                        )
                                                        .setEquipment(v);
                                                });
                                            let item2 = block.getItemStack(
                                                1,
                                                true
                                            );
                                            item2.nameTag = `§r§a${target.name}'s Equipment: Armor, and Offhand\n§b${new Date(
                                                Date.now()
                                            ).toUTCString()}`;
                                            clearContainer(
                                                block.getComponent("inventory")
                                                    .container
                                            );
                                            items.push(item2);
                                        }
                                    }
                                    block.setType("air");
                                    items.forEach((item) => target
                                        .getComponent("inventory")
                                        .container.addItem(item)
                                    );
                                } else if ((args[2] ?? "").trim() == "inventory") {
                                    let block = player.dimension.getBlock(
                                        player.location
                                    );
                                    block.setType(args[1]);
                                    inventorySwapC(
                                        target.getComponent("inventory")
                                            .container,
                                        block.getComponent("inventory")
                                            .container,
                                        [9, 36],
                                        [0, 27]
                                    );
                                    let item = block.getItemStack(1, true);
                                    item.nameTag = `§r§a${target.name}'s Items: Slots 9-35§b\n${new Date(
                                        Date.now()
                                    ).toUTCString()}`;
                                    clearContainer(
                                        block.getComponent("inventory")
                                            .container
                                    );
                                    block.setType("air");
                                    target
                                        .getComponent("inventory")
                                        .container.addItem(item);
                                } else if ((args[2] ?? "").trim() == "hotbar") {
                                    let block = player.dimension.getBlock(
                                        player.location
                                    );
                                    block.setType(args[1]);
                                    inventorySwapC(
                                        target.getComponent("inventory")
                                            .container,
                                        block.getComponent("inventory")
                                            .container,
                                        [0, 9],
                                        [0, 9]
                                    );
                                    let item = block.getItemStack(1, true);
                                    item.nameTag = `§r§a${target.name}'s Hotbar: Slots 0-8§b\n${new Date(
                                        Date.now()
                                    ).toUTCString()}`;
                                    clearContainer(
                                        block.getComponent("inventory")
                                            .container
                                    );
                                    block.setType("air");
                                    target
                                        .getComponent("inventory")
                                        .container.addItem(item);
                                } else if ((args[2] ?? "").trim() == "armor" ||
                                    (args[2] ?? "").trim() == "equipment") {
                                    let block = player.dimension.getBlock(
                                        player.location
                                    );
                                    block.setType(args[1]);
                                    [
                                        EquipmentSlot.Head,
                                        EquipmentSlot.Chest,
                                        EquipmentSlot.Legs,
                                        EquipmentSlot.Feet,
                                        EquipmentSlot.Offhand,
                                    ].forEach((v, i) => {
                                        block
                                            .getComponent("inventory")
                                            .container.setItem(
                                                9 + i,
                                                target
                                                    .getComponent("equippable")
                                                    .getEquipment(v)
                                            );
                                        target
                                            .getComponent("equippable")
                                            .setEquipment(v);
                                    });
                                    let item = block.getItemStack(1, true);
                                    item.nameTag = `§r§a${target.name}'s Equipment: Armor and Offhand§b\n${new Date(
                                        Date.now()
                                    ).toUTCString()}`;
                                    clearContainer(
                                        block.getComponent("inventory")
                                            .container
                                    );
                                    block.setType("air");
                                    target
                                        .getComponent("inventory")
                                        .container.addItem(item);
                                }
                            }
                        });
                }
                break;
            case !!switchTest.match(/^compressitemscontainerb$/):
                {
                    eventData.cancel = true;
                    let args = evaluateParametersOld(
                        ["presetText", "string"],
                        switchTestB.split(" ").slice(2).join(" ")
                    ).args;
                    if (switchTestB.split(/\s+/g)[3]?.trim() == "~") {
                        args[1] = player.name;
                    }
                    if ((switchTestB.split(/\s+/g)[3] ?? "").trim() == "") {
                        args[1] = player.name;
                    }
                    let target = world
                        .getAllPlayers()
                        .find((_) => _.name == args[1]);
                    if (!!!BlockTypes.get(
                        JSONParse(switchTestB.split(" ")[1])?.id
                    )) {
                        player.sendMessageB(
                            `§cSyntax error: Unexpected "${args[1]}": at ${switchTestB.slice(
                                0,
                                switchTestB.indexOf(args[1])
                            )}">>${args[1]}<<"`
                        );
                    } else if (!!!target) {
                        player.sendError(
                            `§cError: Unable to find player with the name ${args[1]}. `,
                            true
                        );
                    }
                    else
                        system.run(() => {
                            if (!!!(() => {
                                let block = player.dimension.getBlock(
                                    player.location
                                );
                                block.setPermutation(
                                    BlockPermutation.resolve(
                                        JSONParse(switchTestB.split(" ")[1])
                                            ?.id,
                                        JSONParse(switchTestB.split(" ")[1])
                                            ?.states
                                    )
                                );
                                let component = block.getComponent("inventory");
                                block.setType("air");
                                return component;
                            })()) {
                                player.sendError(
                                    `§cError: Block of type ${BlockTypes.get(
                                        JSONParse(switchTestB.split(" ")[1])
                                            ?.id
                                    ).id} is not a container block. `,
                                    true
                                );
                            } else {
                                if ((args[0] ?? "").trim() == "" ||
                                    (args[0] ?? "").trim() == "all") {
                                    let block = player.dimension.getBlock(
                                        player.location
                                    );
                                    let items = [] as ItemStack[];
                                    block.setPermutation(
                                        BlockPermutation.resolve(
                                            JSONParse(switchTestB.split(" ")[1])
                                                ?.id,
                                            JSONParse(switchTestB.split(" ")[1])
                                                ?.states
                                        )
                                    );
                                    let runSeparate = false;
                                    let runTogether = false;
                                    for (let i = 0; i <
                                        Math.max(
                                            0,
                                            36 /
                                            block.getComponent("inventory")
                                                .container.size
                                        ); i++) {
                                        inventorySwapC(
                                            target.getComponent("inventory")
                                                .container,
                                            block.getComponent("inventory")
                                                .container,
                                            [
                                                i *
                                                block.getComponent(
                                                    "inventory"
                                                ).container.size,
                                                Math.min(
                                                    (i + 1) *
                                                    block.getComponent(
                                                        "inventory"
                                                    ).container.size,
                                                    36
                                                ),
                                            ],
                                            [
                                                0,
                                                block.getComponent("inventory")
                                                    .container.size,
                                            ]
                                        );
                                        if ((i + 1) *
                                            block.getComponent("inventory")
                                                .container.size >
                                            41) {
                                            [
                                                EquipmentSlot.Head,
                                                EquipmentSlot.Chest,
                                                EquipmentSlot.Legs,
                                                EquipmentSlot.Feet,
                                                EquipmentSlot.Offhand,
                                            ].forEach((v, ib) => {
                                                block
                                                    .getComponent("inventory")
                                                    .container.setItem(
                                                        block.getComponent(
                                                            "inventory"
                                                        ).container.size -
                                                        (Math.min(
                                                            (i + 1) *
                                                            block.getComponent(
                                                                "inventory"
                                                            ).container
                                                                .size,
                                                            36
                                                        ) -
                                                            i *
                                                            block.getComponent(
                                                                "inventory"
                                                            ).container
                                                                .size) +
                                                        ib,
                                                        target
                                                            .getComponent(
                                                                "equippable"
                                                            )
                                                            .getEquipment(v)
                                                    );
                                                target
                                                    .getComponent("equippable")
                                                    .setEquipment(v);
                                            });
                                            runTogether = true;
                                        } else {
                                            if (i + 1 >=
                                                Math.max(
                                                    0,
                                                    36 /
                                                    block.getComponent(
                                                        "inventory"
                                                    ).container.size
                                                )) {
                                                runSeparate = true;
                                            }
                                        }
                                        let item = block.getItemStack(1, true);
                                        item.nameTag = `§r§a${target.name}'s Items: Slots ${i *
                                            block.getComponent("inventory")
                                                .container.size}-${Math.min(
                                                    (i + 1) *
                                                    block.getComponent("inventory")
                                                        .container.size,
                                                    36
                                                )}${runTogether
                                                ? ", Armor, and Offhand"
                                                : ""}§b\n${new Date(
                                                    Date.now()
                                                ).toUTCString()}`;
                                        clearContainer(
                                            block.getComponent("inventory")
                                                .container
                                        );
                                        items.push(item);
                                    }
                                    if (runSeparate) {
                                        [
                                            EquipmentSlot.Head,
                                            EquipmentSlot.Chest,
                                            EquipmentSlot.Legs,
                                            EquipmentSlot.Feet,
                                            EquipmentSlot.Offhand,
                                        ].forEach((v, ib) => {
                                            block
                                                .getComponent("inventory")
                                                .container.setItem(
                                                    ib,
                                                    target
                                                        .getComponent(
                                                            "equippable"
                                                        )
                                                        .getEquipment(v)
                                                );
                                            target
                                                .getComponent("equippable")
                                                .setEquipment(v);
                                        });
                                        let item2 = block.getItemStack(1, true);
                                        item2.nameTag = `§r§a${target.name}'s Equipment: Armor, and Offhand\n§b${new Date(
                                            Date.now()
                                        ).toUTCString()}`;
                                        clearContainer(
                                            block.getComponent("inventory")
                                                .container
                                        );
                                        items.push(item2);
                                    }
                                    block.setType("air");
                                    items.forEach((item) => target
                                        .getComponent("inventory")
                                        .container.addItem(item)
                                    );
                                } else if ((args[0] ?? "").trim() == "inventory") {
                                    let block = player.dimension.getBlock(
                                        player.location
                                    );
                                    block.setType(args[1]);
                                    inventorySwapC(
                                        target.getComponent("inventory")
                                            .container,
                                        block.getComponent("inventory")
                                            .container,
                                        [9, 36],
                                        [0, 27]
                                    );
                                    let item = block.getItemStack(1, true);
                                    item.nameTag = `§r§a${target.name}'s Items: Slots 9-35§b\n${new Date(
                                        Date.now()
                                    ).toUTCString()}`;
                                    clearContainer(
                                        block.getComponent("inventory")
                                            .container
                                    );
                                    block.setType("air");
                                    target
                                        .getComponent("inventory")
                                        .container.addItem(item);
                                } else if ((args[0] ?? "").trim() == "hotbar") {
                                    let block = player.dimension.getBlock(
                                        player.location
                                    );
                                    block.setType(args[1]);
                                    inventorySwapC(
                                        target.getComponent("inventory")
                                            .container,
                                        block.getComponent("inventory")
                                            .container,
                                        [0, 9],
                                        [0, 9]
                                    );
                                    let item = block.getItemStack(1, true);
                                    item.nameTag = `§r§a${target.name}'s Hotbar: Slots 0-8§b\n${new Date(
                                        Date.now()
                                    ).toUTCString()}`;
                                    clearContainer(
                                        block.getComponent("inventory")
                                            .container
                                    );
                                    block.setType("air");
                                    target
                                        .getComponent("inventory")
                                        .container.addItem(item);
                                } else if ((args[0] ?? "").trim() == "armor" ||
                                    (args[2] ?? "").trim() == "equipment") {
                                    let block = player.dimension.getBlock(
                                        player.location
                                    );
                                    block.setType(args[1]);
                                    [
                                        EquipmentSlot.Head,
                                        EquipmentSlot.Chest,
                                        EquipmentSlot.Legs,
                                        EquipmentSlot.Feet,
                                        EquipmentSlot.Offhand,
                                    ].forEach((v, i) => {
                                        block
                                            .getComponent("inventory")
                                            .container.setItem(
                                                9 + i,
                                                target
                                                    .getComponent("equippable")
                                                    .getEquipment(v)
                                            );
                                        target
                                            .getComponent("equippable")
                                            .setEquipment(v);
                                    });
                                    let item = block.getItemStack(1, true);
                                    item.nameTag = `§r§a${target.name}'s Equipment: Armor and Offhand§b\n${new Date(
                                        Date.now()
                                    ).toUTCString()}`;
                                    clearContainer(
                                        block.getComponent("inventory")
                                            .container
                                    );
                                    block.setType("air");
                                    target
                                        .getComponent("inventory")
                                        .container.addItem(item);
                                }
                            }
                        });
                }
                break;
            case !!switchTest.match(/^scanenderchest$/) ||
                !!switchTest.match(/^ecinvsee$/) ||
                !!switchTest.match(/^scnendchest$/):
                {
                    eventData.cancel = true;
                    system.run(() => {
                        let args = evaluateParameters(switchTestB, [
                            "presetText",
                            "targetSelector",
                        ]).args;
                        if (switchTestB.split(/\s+/g)[1]?.trim() == "~") {
                            args[1] = player.name;
                        }
                        if ((switchTestB.split(/\s+/g)[1] ?? "").trim() == "") {
                            args[1] = player.name;
                        }
                        let targets = targetSelectorAllListC(
                            args[1],
                            "",
                            vTStr(player.location),
                            player
                        ).filter(
                            (v) => v.typeId == "minecraft:player"
                        ) as Player[];
                        if (targets.length == 0) {
                            player.sendError(
                                `§cError: No players matching the specified target selector were found. `,
                                true
                            );
                        }
                        else
                            targets.forEach((target) => {
                                let slots = [] as string[];
                                for (let i = 0; i < 27; i++) {
                                    slots.push(
                                        `slot: ${i}, item: ${ItemTypes.getAll().find(
                                            (v) => (tryget(
                                                () => target.runCommand(
                                                    `testfor @s[hasitem={location=slot.enderchest,item=${v.id},slot=${i}}]`
                                                ).successCount
                                            ) ?? 0) != 0
                                        )?.id ?? "minecraft:air"}`
                                    );
                                }
                                player.sendMessageB(
                                    `${target.name}'s Ender Chest Contents: \n${slots.join(
                                        "§r§f\n"
                                    )}`
                                );
                            });
                    });
                }
                break;
            case !!switchTest.match(/^scanenderchestc$/) ||
                !!switchTest.match(/^ecinvseec$/) ||
                !!switchTest.match(/^scnendchestc$/):
                {
                    eventData.cancel = true;
                    let args = evaluateParameters(switchTestB, [
                        "presetText",
                        "string",
                    ]).args;
                    if (switchTestB.split(/\s+/g)[1]?.trim() == "~") {
                        args[1] = player.name;
                    }
                    if ((switchTestB.split(/\s+/g)[1] ?? "").trim() == "") {
                        args[1] = player.name;
                    }
                    let target = world
                        .getAllPlayers()
                        .find((_) => _.name == args[1]);
                    if (!!!target) {
                        player.sendError(
                            `§cError: Unable to find player with the name ${args[1]}. `,
                            true
                        );
                    }
                    else
                        system.run(() => {
                            let slots = [] as string[];
                            for (let i = 0; i < 27; i++) {
                                slots.push(
                                    `slot: ${i}, item: ${ItemTypes.getAll().find(
                                        (v) => (tryget(
                                            () => target.runCommand(
                                                `testfor @s[hasitem={location=slot.enderchest,item=${v.id},slot=${i}}]`
                                            ).successCount
                                        ) ?? 0) != 0
                                    )?.id ?? "minecraft:air"}, amount: ${rangeToIntArray([0, 255])
                                        .reverse()
                                        .find(
                                            (v) => (tryget(
                                                () => target.runCommand(
                                                    `testfor @s[hasitem={location=slot.enderchest,count=${v},slot=${i}}]`
                                                ).successCount
                                            ) ?? 0) != 0
                                        )}`
                                );
                            }
                            player.sendMessageB(
                                `${target.name}'s Ender Chest Contents: \n${slots.join(
                                    "§r§f\n"
                                )}`
                            );
                        });
                }
                break;
            case !!switchTest.match(/^clearenderchestslot$/):
                {
                    eventData.cancel = true;
                    let args = evaluateParametersOld(
                        ["presetText", "number", "string"],
                        switchTestB
                    ).args;
                    if (switchTestB.split(/\s+/g)[2]?.trim() == "~") {
                        args[2] = player.name;
                    }
                    if ((switchTestB.split(/\s+/g)[2] ?? "").trim() == "") {
                        args[2] = player.name;
                    }
                    let target = world
                        .getAllPlayers()
                        .find((_) => _.name == args[2]);
                    if (!!!target) {
                        player.sendError(
                            `§cError: Unable to find player with the name ${args[2]}. `,
                            true
                        );
                    }
                    else
                        system.run(() => {
                            let success = target.runCommand(
                                `replaceitem entity @s slot.enderchest ${args[1]} air`
                            ).successCount;
                            if (success != 0) {
                                player.sendMessageB(
                                    `Successfully cleared slot ${args[1]} of ${target.name}'s ender chest. `
                                );
                            } else {
                                player.sendError(
                                    `§cError: Failed to clear slot ${args[1]} of ${target.name}'s ender chest. `,
                                    true
                                );
                            }
                        });
                }
                break;
            case !!switchTest.match(/^clearenderchest$/):
                {
                    eventData.cancel = true;
                    let args = evaluateParametersOld(
                        ["presetText", "string"],
                        switchTestB
                    ).args;
                    if (switchTestB.split(/\s+/g)[1]?.trim() == "~") {
                        args[1] = player.name;
                    }
                    let target = world
                        .getAllPlayers()
                        .find((_) => _.name == args[1]);
                    if (!!!target) {
                        player.sendError(
                            `§cError: Unable to find player with the name ${args[1]}. `,
                            true
                        );
                    }
                    else
                        system.run(() => {
                            let success = 0;
                            for (let i = 0; i < 27; i++) {
                                success += target.runCommand(
                                    `replaceitem entity @s slot.enderchest ${i} air`
                                ).successCount;
                            }
                            if (success != 0) {
                                player.sendMessageB(
                                    `Successfully cleared ${success} slot(s) of ${target.name}'s ender chest. `
                                );
                            } else {
                                player.sendError(
                                    `§cError: Failed to clear ${target.name}'s ender chest. `,
                                    true
                                );
                            }
                        });
                }
                break;
            case !!switchTest.match(/^filljunk$/) ||
                !!switchTest.match(/^invfilljunk$/):
                {
                    eventData.cancel = true;
                    let args = evaluateParametersOld(
                        ["presetText", "presetText", "presetText", "string"],
                        switchTestB
                    ).args;
                    if (switchTestB.split(/\s+/g)[3]?.trim() == "~") {
                        args[3] = player.name;
                    }
                    if ((switchTestB.split(/\s+/g)[3] ?? "").trim() == "") {
                        args[3] = player.name;
                    }
                    let target = world
                        .getAllPlayers()
                        .find((_) => _.name == args[3]);
                    if (!!!target) {
                        player.sendError(
                            `§cError: Unable to find player with the name ${args[3]}. `,
                            true
                        );
                    }
                    else
                        system.run(() => {
                            if ((args[1] ?? "").trim().toLowerCase() == "" ||
                                (args[1] ?? "").trim().toLowerCase() == "fill") {
                                for (let i = 0; i <
                                    target.getComponent("inventory").container
                                        .size; i++) {
                                    let t = shuffle(JunkItemTypes)[0];
                                    target
                                        .getComponent("inventory")
                                        .container.addItem(
                                            new ItemStack(
                                                t,
                                                args[2].trim().toLowerCase() ==
                                                    ""
                                                    ? 255
                                                    : args[2]
                                                        .trim()
                                                        .toLowerCase() ==
                                                        "max"
                                                        ? new ItemStack(t).maxAmount
                                                        : Math.max(
                                                            1,
                                                            Number(
                                                                args[2]
                                                                    .trim()
                                                                    .toLowerCase()
                                                                    .replace(
                                                                        /~+/,
                                                                        "255"
                                                                    )
                                                            )
                                                        )
                                            )
                                        );
                                }
                            } else if ((args[1] ?? "").trim().toLowerCase() ==
                                "replacefill" ||
                                (args[1] ?? "").trim().toLowerCase() ==
                                "replaceall") {
                                for (let i = 0; i <
                                    target.getComponent("inventory").container
                                        .size; i++) {
                                    let t = shuffle(JunkItemTypes)[0];
                                    target
                                        .getComponent("inventory")
                                        .container.setItem(
                                            i,
                                            new ItemStack(
                                                t,
                                                args[2].trim().toLowerCase() ==
                                                    "max"
                                                    ? new ItemStack(t).maxAmount
                                                    : Number(
                                                        args[2]
                                                            .trim()
                                                            .toLowerCase()
                                                            .replace(
                                                                /~+/,
                                                                "255"
                                                            )
                                                    )
                                            )
                                        );
                                }
                            } else {
                                for (let i = 0; i <
                                    Number(
                                        args[1]
                                            .trim()
                                            .toLowerCase()
                                            .replace(/~+/, "36")
                                    ); i++) {
                                    let t = shuffle(JunkItemTypes)[0];
                                    target
                                        .getComponent("inventory")
                                        .container.addItem(
                                            new ItemStack(
                                                t,
                                                args[2].trim().toLowerCase() ==
                                                    "max"
                                                    ? new ItemStack(t).maxAmount
                                                    : Number(
                                                        args[2]
                                                            .trim()
                                                            .toLowerCase()
                                                            .replace(
                                                                /~+/,
                                                                "255"
                                                            )
                                                    )
                                            )
                                        );
                                }
                            }
                        });
                }
                break;
            case !!switchTest.match(/^fillrandom$/) ||
                !!switchTest.match(/^invfillrandom$/):
                {
                    eventData.cancel = true;
                    let args = evaluateParametersOld(
                        ["presetText", "presetText", "presetText", "string"],
                        switchTestB
                    ).args;
                    if (switchTestB.split(/\s+/g)[3]?.trim() == "~") {
                        args[3] = player.name;
                    }
                    if ((switchTestB.split(/\s+/g)[3] ?? "").trim() == "") {
                        args[3] = player.name;
                    }
                    let target = world
                        .getAllPlayers()
                        .find((_) => _.name == args[3]);
                    if (!!!target) {
                        player.sendError(
                            `§cError: Unable to find player with the name ${args[3]}. `,
                            true
                        );
                    }
                    else
                        system.run(() => {
                            if ((args[1] ?? "").trim().toLowerCase() == "" ||
                                (args[1] ?? "").trim().toLowerCase() == "fill") {
                                for (let i = 0; i <
                                    target.getComponent("inventory").container
                                        .size; i++) {
                                    let t = shuffle(ItemTypes.getAll())[0];
                                    target
                                        .getComponent("inventory")
                                        .container.addItem(
                                            new ItemStack(
                                                t,
                                                args[2].trim().toLowerCase() ==
                                                    ""
                                                    ? 255
                                                    : args[2]
                                                        .trim()
                                                        .toLowerCase() ==
                                                        "max"
                                                        ? new ItemStack(t).maxAmount
                                                        : Math.max(
                                                            1,
                                                            Number(
                                                                args[2]
                                                                    .trim()
                                                                    .toLowerCase()
                                                                    .replace(
                                                                        /~+/,
                                                                        "255"
                                                                    )
                                                            )
                                                        )
                                            )
                                        );
                                }
                            } else if ((args[1] ?? "").trim().toLowerCase() ==
                                "replacefill" ||
                                (args[1] ?? "").trim().toLowerCase() ==
                                "replaceall") {
                                for (let i = 0; i <
                                    target.getComponent("inventory").container
                                        .size; i++) {
                                    let t = shuffle(ItemTypes.getAll())[0];
                                    target
                                        .getComponent("inventory")
                                        .container.setItem(
                                            i,
                                            new ItemStack(
                                                t,
                                                args[2].trim().toLowerCase() ==
                                                    "max"
                                                    ? new ItemStack(t).maxAmount
                                                    : Number(
                                                        args[2]
                                                            .trim()
                                                            .toLowerCase()
                                                            .replace(
                                                                /~+/,
                                                                "255"
                                                            )
                                                    )
                                            )
                                        );
                                }
                            } else {
                                for (let i = 0; i <
                                    Number(
                                        args[1]
                                            .trim()
                                            .toLowerCase()
                                            .replace(/~+/, "36")
                                    ); i++) {
                                    let t = shuffle(ItemTypes.getAll())[0];
                                    target
                                        .getComponent("inventory")
                                        .container.addItem(
                                            new ItemStack(
                                                t,
                                                args[2].trim().toLowerCase() ==
                                                    "max"
                                                    ? new ItemStack(t).maxAmount
                                                    : Number(
                                                        args[2]
                                                            .trim()
                                                            .toLowerCase()
                                                            .replace(
                                                                /~+/,
                                                                "255"
                                                            )
                                                    )
                                            )
                                        );
                                }
                            }
                        });
                }
                break;
            case !!switchTest.match(/^fillop$/) ||
                !!switchTest.match(/^invfillop$/):
                {
                    eventData.cancel = true;
                    let args = evaluateParametersOld(
                        ["presetText", "presetText", "presetText", "string"],
                        switchTestB
                    ).args;
                    if (switchTestB.split(/\s+/g)[3]?.trim() == "~") {
                        args[3] = player.name;
                    }
                    if ((switchTestB.split(/\s+/g)[3] ?? "").trim() == "") {
                        args[3] = player.name;
                    }
                    let target = world
                        .getAllPlayers()
                        .find((_) => _.name == args[3]);
                    if (!!!target) {
                        player.sendError(
                            `§cError: Unable to find player with the name ${args[3]}. `,
                            true
                        );
                    }
                    else
                        system.run(() => {
                            if ((args[1] ?? "").trim().toLowerCase() == "" ||
                                (args[1] ?? "").trim().toLowerCase() == "fill") {
                                for (let i = 0; i <
                                    target.getComponent("inventory").container
                                        .size; i++) {
                                    let t = shuffle(OpItemTypes)[0];
                                    target
                                        .getComponent("inventory")
                                        .container.addItem(
                                            new ItemStack(
                                                t,
                                                args[2].trim().toLowerCase() ==
                                                    ""
                                                    ? 255
                                                    : args[2]
                                                        .trim()
                                                        .toLowerCase() ==
                                                        "max"
                                                        ? new ItemStack(t).maxAmount
                                                        : Math.max(
                                                            1,
                                                            Number(
                                                                args[2]
                                                                    .trim()
                                                                    .toLowerCase()
                                                                    .replace(
                                                                        /~+/,
                                                                        "255"
                                                                    )
                                                            )
                                                        )
                                            )
                                        );
                                }
                            } else if ((args[1] ?? "").trim().toLowerCase() ==
                                "replacefill" ||
                                (args[1] ?? "").trim().toLowerCase() ==
                                "replaceall") {
                                for (let i = 0; i <
                                    target.getComponent("inventory").container
                                        .size; i++) {
                                    let t = shuffle(OpItemTypes)[0];
                                    target
                                        .getComponent("inventory")
                                        .container.setItem(
                                            i,
                                            new ItemStack(
                                                t,
                                                args[2].trim().toLowerCase() ==
                                                    "max"
                                                    ? new ItemStack(t).maxAmount
                                                    : Number(
                                                        args[2]
                                                            .trim()
                                                            .toLowerCase()
                                                            .replace(
                                                                /~+/,
                                                                "255"
                                                            )
                                                    )
                                            )
                                        );
                                }
                            } else {
                                for (let i = 0; i <
                                    Number(
                                        args[1]
                                            .trim()
                                            .toLowerCase()
                                            .replace(/~+/, "36")
                                    ); i++) {
                                    let t = shuffle(OpItemTypes)[0];
                                    target
                                        .getComponent("inventory")
                                        .container.addItem(
                                            new ItemStack(
                                                t,
                                                args[2].trim().toLowerCase() ==
                                                    "max"
                                                    ? new ItemStack(t).maxAmount
                                                    : Number(
                                                        args[2]
                                                            .trim()
                                                            .toLowerCase()
                                                            .replace(
                                                                /~+/,
                                                                "255"
                                                            )
                                                    )
                                            )
                                        );
                                }
                            }
                        });
                }
                break;
            case !!switchTest.match(/^fillillegal$/) ||
                !!switchTest.match(/^invfillillegal$/):
                {
                    eventData.cancel = true;
                    let args = evaluateParametersOld(
                        ["presetText", "presetText", "presetText", "string"],
                        switchTestB
                    ).args;
                    if (switchTestB.split(/\s+/g)[3]?.trim() == "~") {
                        args[3] = player.name;
                    }
                    if ((switchTestB.split(/\s+/g)[3] ?? "").trim() == "") {
                        args[3] = player.name;
                    }
                    let target = world
                        .getAllPlayers()
                        .find((_) => _.name == args[3]);
                    if (!!!target) {
                        player.sendError(
                            `§cError: Unable to find player with the name ${args[3]}. `,
                            true
                        );
                    }
                    else
                        system.run(() => {
                            if ((args[1] ?? "").trim().toLowerCase() == "" ||
                                (args[1] ?? "").trim().toLowerCase() == "fill") {
                                for (let i = 0; i <
                                    target.getComponent("inventory").container
                                        .size; i++) {
                                    let t = shuffle(IllegalItemTypes)[0];
                                    target
                                        .getComponent("inventory")
                                        .container.addItem(
                                            new ItemStack(
                                                t,
                                                args[2].trim().toLowerCase() ==
                                                    ""
                                                    ? 255
                                                    : args[2]
                                                        .trim()
                                                        .toLowerCase() ==
                                                        "max"
                                                        ? new ItemStack(t).maxAmount
                                                        : Math.max(
                                                            1,
                                                            Number(
                                                                args[2]
                                                                    .trim()
                                                                    .toLowerCase()
                                                                    .replace(
                                                                        /~+/,
                                                                        "255"
                                                                    )
                                                            )
                                                        )
                                            )
                                        );
                                }
                            } else if ((args[1] ?? "").trim().toLowerCase() ==
                                "replacefill" ||
                                (args[1] ?? "").trim().toLowerCase() ==
                                "replaceall") {
                                for (let i = 0; i <
                                    target.getComponent("inventory").container
                                        .size; i++) {
                                    let t = shuffle(IllegalItemTypes)[0];
                                    target
                                        .getComponent("inventory")
                                        .container.setItem(
                                            i,
                                            new ItemStack(
                                                t,
                                                args[2].trim().toLowerCase() ==
                                                    "max"
                                                    ? new ItemStack(t).maxAmount
                                                    : Number(
                                                        args[2]
                                                            .trim()
                                                            .toLowerCase()
                                                            .replace(
                                                                /~+/,
                                                                "255"
                                                            )
                                                    )
                                            )
                                        );
                                }
                            } else {
                                for (let i = 0; i <
                                    Number(
                                        args[1]
                                            .trim()
                                            .toLowerCase()
                                            .replace(/~+/, "36")
                                    ); i++) {
                                    let t = shuffle(IllegalItemTypes)[0];
                                    target
                                        .getComponent("inventory")
                                        .container.addItem(
                                            new ItemStack(
                                                t,
                                                args[2].trim().toLowerCase() ==
                                                    "max"
                                                    ? new ItemStack(t).maxAmount
                                                    : Number(
                                                        args[2]
                                                            .trim()
                                                            .toLowerCase()
                                                            .replace(
                                                                /~+/,
                                                                "255"
                                                            )
                                                    )
                                            )
                                        );
                                }
                            }
                        });
                }
                break;
            case !!switchTest.match(/^fillinventory$/) ||
                !!switchTest.match(/^invfill$/):
                {
                    eventData.cancel = true; /*
            console.warn(switchTestB.split(" ")?.length)*/

                    if (switchTestB.split(" ")?.length == 1) {
                        player.sendMessageB(
                            `${switchTest} command format: ${switchTest} <itemJSON: itemJSON> [mode: fill|replacefill|replaceall] [playerTarget: targetSelector]\nfor the format for the itemJSON just type in "\\help itemjsonformat". `
                        );
                    } else {
                        system.run(() => {
                            let argsa = evaluateParameters(switchTestB, [
                                { type: "presetText" },
                                { type: "json" },
                                { type: "presetText" },
                                { type: "targetSelector" },
                            ]);
                            let args = argsa.args;
                            if (args[3]?.trim() == "~") {
                                args[3] = player.name;
                            }
                            if ((args[3] ?? "").trim() == "") {
                                args[3] = player.name;
                            }
                            let targets = targetSelectorAllListC(
                                args[3],
                                "",
                                vTStr(player.location),
                                player
                            ).filter(
                                (v) => v.typeId == "minecraft:player"
                            ) as Player[];
                            if (targets.length == 0) {
                                player.sendError(
                                    `§cError: No players matching the specified target selector were found. `,
                                    true
                                );
                            } else {
                                let item = !!(args[1]?.count ?? args[1]?.amount)
                                    ? Object.assign(
                                        itemJSONPropertiesEval(args[1]),
                                        { count: 255 }
                                    )
                                    : itemJSONPropertiesEval(args[1]);
                                let successes = [] as [string, number][];
                                targets.forEach((target) => {
                                    let successcount = 0;
                                    if ((args[2] ?? "").trim().toLowerCase() ==
                                        "" ||
                                        (args[2] ?? "").trim().toLowerCase() ==
                                        "fill") {
                                        entityToContainerSlotArray(
                                            target,
                                            true,
                                            false
                                        )
                                            .filter((v) => !!!v.getItem())
                                            .forEach((v) => {
                                                v.setItem(item);
                                                successcount++;
                                            });
                                        successes.push([
                                            target.name,
                                            successcount,
                                        ]);
                                    } else if ((args[2] ?? "").trim().toLowerCase() ==
                                        "replacefill" ||
                                        (args[2] ?? "").trim().toLowerCase() ==
                                        "replaceall") {
                                        entityToContainerSlotArray(
                                            target,
                                            true,
                                            false
                                        ).forEach((v) => {
                                            v.setItem(item);
                                            successcount++;
                                        });
                                        successes.push([
                                            target.name,
                                            successcount,
                                        ]);
                                    } else {
                                        entityToContainerSlotArray(
                                            target,
                                            true,
                                            false
                                        )
                                            .filter((v) => !!!v.getItem())
                                            .slice(0, Number(args[2]))
                                            .forEach((v) => {
                                                v.setItem(item);
                                                successcount++;
                                            });
                                        successes.push([
                                            target.name,
                                            successcount,
                                        ]);
                                    }
                                });
                                if (successes.filter((v) => v[1] != 0).length !=
                                    0) {
                                    player.sendMessageB(
                                        `Successfully filled the ${successes.filter((v) => v[1] != 0)
                                            .length == 1
                                            ? "inventory"
                                            : "inventories"} of ${successes
                                                .filter((v) => v[1] != 0)
                                                .map(
                                                    (v) => `${v[0]}{${v[1]} slots}`
                                                )
                                                .join(", ")} with ${item.typeId} * ${item.amount}`
                                    );
                                }
                            }
                        });
                    }
                }
                break;
            case !!switchTest.match(/^chunkban$/):
                {
                    eventData.cancel = true;
                    let args = evaluateParametersOld(
                        ["presetText", "presetText", "presetText", "string"],
                        switchTestB
                    ).args;
                    if (switchTestB.split(/\s+/g)[3]?.trim() == "~" ||
                        (switchTestB.split(/\s+/g)[3] ?? "").trim() == "") {
                        args[3] = player.name;
                    }
                    let target = world
                        .getAllPlayers()
                        .find((_) => _.name == args[3]);
                    if (!!!target) {
                        player.sendError(
                            `§cError: Unable to find player with the name ${args[3]}. `,
                            true
                        );
                    } else {
                        if (switchTestB.split(/\s+/g)[1]?.trim() == "~" ||
                            (switchTestB.split(/\s+/g)[1] ?? "").trim() == "") {
                            args[1] = target.selectedSlotIndex;
                        }
                        if (switchTestB.split(/\s+/g)[2]?.trim() == "~" ||
                            (switchTestB.split(/\s+/g)[2] ?? "").trim() == "") {
                            args[2] = 1;
                        }
                        let slot = Number(args[1]);
                        let loopCount = Number(args[2]);
                        system.run(() => {
                            try {
                                for (let ib = 0; ib < loopCount; ib++) {
                                    let block = player.dimension.getBlock(
                                        player.location
                                    );
                                    block.setType("shulker_box");
                                    !!target
                                        .getComponent("inventory")
                                        .container.getItem(slot)
                                        ? target
                                            .getComponent("inventory")
                                            .container.getItem(slot).amount <
                                            target
                                                .getComponent("inventory")
                                                .container.getItem(slot).maxAmount
                                            ? (target
                                                .getComponent("inventory")
                                                .container.getItem(
                                                    slot
                                                ).amount = target
                                                    .getComponent("inventory")
                                                    .container.getItem(
                                                        slot
                                                    ).maxAmount)
                                            : undefined
                                        : undefined;
                                    fillContainer(
                                        block.getComponent("inventory")
                                            .container,
                                        target
                                            .getComponent("inventory")
                                            .container.getItem(slot)
                                    );
                                    let item = block.getItemStack(64, true);
                                    item.nameTag = `§r§a${target.name}'s Items: Slots 0-26§b\n${new Date(
                                        Date.now()
                                    ).toUTCString()}`;
                                    clearContainer(
                                        block.getComponent("inventory")
                                            .container
                                    );
                                    clearContainer(
                                        block.getComponent("inventory")
                                            .container
                                    );
                                    block.setType("air");
                                    target
                                        .getComponent("inventory")
                                        .container.setItem(slot, item);
                                }
                            } catch (e) {
                                player.sendError(e + " " + e.stack, true);
                            }
                        });
                    }
                }
                break;
            case !!switchTest.match(/^rank$/):
                {
                    eventData.cancel = true;
                    let args = evaluateParameters(switchTestB, [
                        "presetText",
                        "targetSelector",
                        "presetText",
                        "string",
                    ]).args;
                    //console.warn(args)
                    if (args[1]?.trim() == "~") {
                        args[1] = player.name;
                    }
                    if ((args[1] ?? "").trim() == "") {
                        args[1] = player.name;
                    }
                    srun(() => {
                        try {
                            let targets = targetSelectorAllListC(
                                args[1],
                                "",
                                vTStr(player.location),
                                player
                            ).filter(
                                (v) => v.typeId == "minecraft:player"
                            ) as Player[];
                            if (targets.length == 0) {
                                player.sendError(
                                    `§cError: No players matching the specified target selector were found. `,
                                    true
                                );
                            } else {
                                switch (args[2]) {
                                    case "add":
                                        targets.forEach((v) => v.addTag(
                                            String(
                                                world.getDynamicProperty(
                                                    "andexdbSettings:chatRankPrefix"
                                                ) ?? "rank:"
                                            ) + args[3]
                                        )
                                        );
                                        psend(
                                            player,
                                            `Successfully added the rank "${args[3]}§r" to ${targets
                                                .map((t) => t.name)
                                                .join()}. `
                                        );
                                        break;
                                    case "remove":
                                        targets.forEach((v) => v.removeTag(
                                            String(
                                                world.getDynamicProperty(
                                                    "andexdbSettings:chatRankPrefix"
                                                ) ?? "rank:"
                                            ) + args[3]
                                        )
                                        );
                                        psend(
                                            player,
                                            `Successfully removed the rank "${args[3]}§r" from ${targets
                                                .map((t) => t.name)
                                                .join()}. `
                                        );
                                        break;
                                    case "clear":
                                        targets.forEach((v) => v
                                            .getTags()
                                            .filter((t) => t.startsWith(
                                                String(
                                                    world.getDynamicProperty(
                                                        "andexdbSettings:chatRankPrefix"
                                                    ) ?? "rank:"
                                                )
                                            )
                                            )
                                            .forEach((t) => v.removeTag(t))
                                        );
                                        psend(
                                            player,
                                            `Successfully cleared all ranks from ${targets
                                                .map((t) => t.name)
                                                .join()}. `
                                        );
                                        break;
                                    default:
                                        player.sendMessageB(
                                            `§cSyntax error: Unexpected "${args[2]}" at "${switchTest.slice(
                                                0,
                                                switchTest.indexOf(args[1]) +
                                                args[1].length +
                                                1
                                            )}>>${args[2]}<<${args[3]}"`
                                        );
                                }
                            }
                        } catch (e) {
                            player.sendMessageB("§c" + e + " " + e.stack);
                        }
                    });
                }
                break;
            case !!switchTest.match(/^timezone$/) || !!switchTest.match(/^tz$/):
                {
                    eventData.cancel = true;
                    const args = evaluateParameters(switchTestB, [
                        "presetText",
                        "number",
                    ]).args;
                    player.setDynamicProperty(
                        "andexdbPersonalSettings:timeZone",
                        args[1]
                    );
                    player.sendMessageB(
                        `Successfully set your timezone to ${args[1]}.`
                    );
                }
                break;
            case !!switchTest.match(/^\\pos1$/):
                {
                    eventData.cancel = true;
                    const args = evaluateParameters(switchTestB, [
                        "presetText",
                        "Vector",
                        "Vector",
                        "Vector",
                    ]).args;
                    const pos1 = Vector3Utils.floor(
                        (args[1] ?? "") == ""
                            ? player.location
                            : evaluateCoordinates(
                                args[1],
                                args[2],
                                args[3],
                                player.location,
                                player.getRotation()
                            )
                    );
                    player.setDynamicProperty("pos1", pos1);
                    player.setDynamicProperty("posD", player.dimension.id);
                    player.sendMessageB(
                        `Successfully set pos1 to ${vTStr(pos1)}.`
                    );
                }
                break;
            case !!switchTest.match(/^\\pos2$/):
                {
                    eventData.cancel = true;
                    const args = evaluateParameters(switchTestB, [
                        "presetText",
                        "Vector",
                        "Vector",
                        "Vector",
                    ]).args;
                    const pos2 = Vector3Utils.floor(
                        (args[1] ?? "") == ""
                            ? player.location
                            : evaluateCoordinates(
                                args[1],
                                args[2],
                                args[3],
                                player.location,
                                player.getRotation()
                            )
                    );
                    player.setDynamicProperty("pos2", pos2);
                    player.setDynamicProperty("posD", player.dimension.id);
                    player.sendMessageB(
                        `Successfully set pos2 to ${vTStr(pos2)}.`
                    );
                }
                break;
            case !!switchTest.match(/^\\hpos1$/):
                {
                    eventData.cancel = true;
                    const loc = player.getBlockFromViewDirection({
                        includeLiquidBlocks: true,
                        includePassableBlocks: true,
                    })?.block?.location;
                    if (!!!loc) {
                        player.sendMessageB(
                            "§cError: You must be facing a block to use this command."
                        );
                    } else {
                        const pos1 = Vector3Utils.floor(loc);
                        player.setDynamicProperty("pos1", pos1);
                        player.setDynamicProperty("posD", player.dimension.id);
                        player.sendMessageB(
                            `Successfully set pos1 to ${vTStr(pos1)}.`
                        );
                    }
                }
                break;
            case !!switchTest.match(/^\\hpos2$/):
                {
                    eventData.cancel = true;
                    const loc = player.getBlockFromViewDirection({
                        includeLiquidBlocks: true,
                        includePassableBlocks: true,
                    })?.block?.location;
                    if (!!!loc) {
                        player.sendMessageB(
                            "§cError: You must be facing a block to use this command."
                        );
                    } else {
                        const pos2 = Vector3Utils.floor(loc);
                        player.setDynamicProperty("pos2", pos2);
                        player.setDynamicProperty("posD", player.dimension.id);
                        player.sendMessageB(
                            `Successfully set pos2 to ${vTStr(pos2)}.`
                        );
                    }
                }
                break;
            case !!switchTest.match(/^\\selectmode$/):
                {
                    eventData.cancel = true;
                    const args = evaluateParameters(switchTestB, [
                        "presetText",
                        "string",
                    ]).args;
                    if (player
                        .getComponent("inventory")
                        .container.getItem(player.selectedSlotIndex)
                        .isStackable) {
                        player.sendMessageB(
                            "§cError: The held item is a stackable item."
                        );
                    } else {
                        player
                            .getComponent("inventory")
                            .container.getSlot(player.selectedSlotIndex)
                            .setDynamicProperty("selectmode", args[1]);
                        player.sendMessageB(
                            `Successfully set selectmode of the held item to ${args[1]}.`
                        );
                    }
                }
                break;
            case !!switchTest.match(/^\\chunk$/):
                {
                    eventData.cancel = true;
                    const chunk = chunkIndexToBoundingBox(
                        getChunkIndex(player.location)
                    );
                    player.setDynamicProperty("pos1", chunk.from);
                    player.setDynamicProperty("pos2", chunk.to);
                    player.setDynamicProperty("posD", player.dimension.id);
                    player.sendMessageB(
                        `Successfully set selection to the current chunk (${vTStr(
                            chunk.from
                        )} to ${vTStr(chunk.to)}).`
                    );
                }
                break;
            case !!switchTest.match(/^\\shift$/):
                {
                    eventData.cancel = true;
                    const args = evaluateParameters(switchTestB, [
                        "presetText",
                        "string",
                        "string",
                    ]).args;
                    const range = VSTR(
                        player.getDynamicProperty("pos1") as Vector3,
                        player.getDynamicProperty("pos2") as Vector3
                    );
                    player.setDynamicProperty(
                        "pos1",
                        Vector.add(
                            range.from,
                            Vector.scale(
                                diroffsetmapb(args[1].toLowerCase()),
                                Number(args[2])
                            )
                        )
                    );
                    player.setDynamicProperty(
                        "pos2",
                        Vector.add(
                            range.to,
                            Vector.scale(
                                diroffsetmapb(args[1].toLowerCase()),
                                Number(args[2])
                            )
                        )
                    );
                    player.sendMessageB(
                        `Successfully shifted the selection ${args[2]} blocks ${args[1]} (${vTStr(
                            player.getDynamicProperty("pos1") as Vector3
                        )} to ${vTStr(
                            player.getDynamicProperty("pos2") as Vector3
                        )}).`
                    );
                }
                break;
            case !!switchTest.match(/^\\offset$/):
                {
                    eventData.cancel = true;
                    const args = evaluateParameters(switchTestB, [
                        "presetText",
                        "number",
                        "number",
                        "number",
                    ]).args;
                    const offset = {
                        x: args[1] ?? 0,
                        y: args[2] ?? 0,
                        z: args[3] ?? 0,
                    };
                    const range = VSTR(
                        player.getDynamicProperty("pos1") as Vector3,
                        player.getDynamicProperty("pos2") as Vector3
                    );
                    player.setDynamicProperty(
                        "pos1",
                        Vector.add(range.from, offset)
                    );
                    player.setDynamicProperty(
                        "pos2",
                        Vector.add(range.to, offset)
                    );
                    player.sendMessageB(
                        `Successfully shifted the selection by ${vTStr(
                            offset
                        )} (${vTStr(
                            player.getDynamicProperty("pos1") as Vector3
                        )} to ${vTStr(
                            player.getDynamicProperty("pos2") as Vector3
                        )}).`
                    );
                }
                break;
            case !!switchTest.match(/^\\replace$/):
                {
                    eventData.cancel = true;
                    const args = evaluateParameters(switchTestB, [
                        "presetText",
                        "f-c",
                        "blockPattern",
                        "blockMask",
                    ]).args;
                    const firstblockpattern = args[2] as BlockPattern;
                    const mask = args[3];
                    const coordinatesa = player.getDynamicProperty("pos1") as Vector3 |
                        undefined;
                    const coordinatesb = player.getDynamicProperty("pos2") as Vector3 |
                        undefined;
                    const ca = {
                        x: Math.min(coordinatesa.x, coordinatesb.x),
                        y: Math.min(coordinatesa.y, coordinatesb.y),
                        z: Math.min(coordinatesa.z, coordinatesb.z),
                    };
                    const cb = {
                        x: Math.max(coordinatesa.x, coordinatesb.x),
                        y: Math.max(coordinatesa.y, coordinatesb.y),
                        z: Math.max(coordinatesa.z, coordinatesb.z),
                    };
                    const dimensiona = world.getDimension(
                        (player.getDynamicProperty("posD") ??
                            player.dimension.id) as string
                    ) as Dimension | undefined;
                    if (!!!coordinatesa) {
                        player.sendMessageB("§cError: pos1 is not set.");
                    } else {
                        if (!!!coordinatesb) {
                            player.sendMessageB("§cError: pos2 is not set.");
                        } else {
                            system.run(() => {
                                let ta: Entity[];
                                try {
                                    generateTickingAreaFillCoordinatesC(
                                        player.location,
                                        (() => {
                                            let a = new CompoundBlockVolume();
                                            a.pushVolume({
                                                volume: new BlockVolume(ca, cb),
                                            });
                                            return a;
                                        })(),
                                        dimensiona
                                    ).then((tac) => {
                                        ta = tac;
                                        try {
                                            undoClipboard.save(
                                                dimensiona,
                                                { from: ca, to: cb },
                                                Date.now(),
                                                {
                                                    includeBlocks: true,
                                                    includeEntities: false,
                                                    saveMode: config.undoClipboardMode,
                                                }
                                            );
                                        } catch (e) {
                                            player.sendMessageB(
                                                "§c" + e + " " + e.stack
                                            );
                                        }
                                        const blocktypes = BlockTypes.getAll();
                                        try {
                                            fillBlocksHFGBM(
                                                ca,
                                                cb,
                                                dimensiona,
                                                (l, i) => {
                                                    const b = firstblockpattern.generateBlock(
                                                        i
                                                    );
                                                    return b.type == "random"
                                                        ? BlockPermutation.resolve(
                                                            blocktypes[Math.floor(
                                                                blocktypes.length *
                                                                Math.random()
                                                            )].id
                                                        )
                                                        : BlockPermutation.resolve(
                                                            b.type,
                                                            b.states
                                                        );
                                                },
                                                {
                                                    blockMask: mask,
                                                    minMSBetweenYields: 2500,
                                                },
                                                args[1].c,
                                                100
                                            ).then(
                                                (a) => {
                                                    player.sendMessageB(
                                                        `${a.counter == 0
                                                            ? "§c"
                                                            : ""}${a.counter} blocks replaced in ${a.completionData
                                                            .endTime -
                                                        a.completionData
                                                            .startTime} ms over ${a.completionData
                                                            .endTick -
                                                        a.completionData
                                                            .startTick} tick${a.completionData
                                                            .endTick -
                                                            a.completionData
                                                                .startTick ==
                                                            1
                                                            ? ""
                                                            : "s"}${a.completionData
                                                            .containsUnloadedChunks
                                                            ? "; Some blocks were not generated because they were in unloaded chunks. "
                                                            : ""}`
                                                    );
                                                },
                                                (e) => {
                                                    player.sendError(
                                                        "§c" + e + e.stack,
                                                        true
                                                    );
                                                }
                                            );
                                        } catch (e) {
                                            player.sendError(
                                                "§c" + e + e.stack,
                                                true
                                            );
                                        } finally {
                                            tac.forEach((tab) => tab?.remove());
                                        }
                                    });
                                } catch (e) {
                                    player.sendError("§c" + e + e.stack, true);
                                }
                            });
                        }
                    }
                }
                break;
            case !!switchTest.match(/^\\set$/):
                {
                    eventData.cancel = true;
                    const args = evaluateParameters(switchTestB, [
                        "presetText",
                        "f-c",
                        "blockPattern",
                    ]).args;
                    const firstblockpattern = args[2] as BlockPattern;
                    const coordinatesa = player.getDynamicProperty("pos1") as Vector3 |
                        undefined;
                    const coordinatesb = player.getDynamicProperty("pos2") as Vector3 |
                        undefined;
                    const ca = {
                        x: Math.min(coordinatesa.x, coordinatesb.x),
                        y: Math.min(coordinatesa.y, coordinatesb.y),
                        z: Math.min(coordinatesa.z, coordinatesb.z),
                    };
                    const cb = {
                        x: Math.max(coordinatesa.x, coordinatesb.x),
                        y: Math.max(coordinatesa.y, coordinatesb.y),
                        z: Math.max(coordinatesa.z, coordinatesb.z),
                    };
                    const dimensiona = world.getDimension(
                        (player.getDynamicProperty("posD") ??
                            player.dimension.id) as string
                    ) as Dimension | undefined;
                    if (!!!coordinatesa) {
                        player.sendMessageB("§cError: pos1 is not set.");
                    } else {
                        if (!!!coordinatesb) {
                            player.sendMessageB("§cError: pos2 is not set.");
                        } else {
                            system.run(() => {
                                let ta: Entity[];
                                try {
                                    generateTickingAreaFillCoordinatesC(
                                        player.location,
                                        (() => {
                                            let a = new CompoundBlockVolume();
                                            a.pushVolume({
                                                volume: new BlockVolume(ca, cb),
                                            });
                                            return a;
                                        })(),
                                        dimensiona
                                    ).then((tac) => {
                                        ta = tac;
                                        try {
                                            undoClipboard.save(
                                                dimensiona,
                                                { from: ca, to: cb },
                                                Date.now(),
                                                {
                                                    includeBlocks: true,
                                                    includeEntities: false,
                                                    saveMode: config.undoClipboardMode,
                                                }
                                            );
                                        } catch (e) {
                                            player.sendMessageB(
                                                "§c" + e + " " + e.stack
                                            );
                                        }
                                        const blocktypes = BlockTypes.getAll();
                                        try {
                                            fillBlocksHFGB(
                                                ca,
                                                cb,
                                                dimensiona,
                                                (l, i) => {
                                                    const b = firstblockpattern.generateBlock(
                                                        i
                                                    );
                                                    return b.type == "random"
                                                        ? BlockPermutation.resolve(
                                                            blocktypes[Math.floor(
                                                                blocktypes.length *
                                                                Math.random()
                                                            )].id
                                                        )
                                                        : BlockPermutation.resolve(
                                                            b.type,
                                                            b.states
                                                        );
                                                },
                                                { minMSBetweenYields: 2500 },
                                                args[1].c,
                                                100
                                            ).then(
                                                (a) => {
                                                    player.sendMessageB(
                                                        `${a.counter == 0
                                                            ? "§c"
                                                            : ""}${a.counter} blocks replaced in ${a.completionData
                                                            .endTime -
                                                        a.completionData
                                                            .startTime} ms over ${a.completionData
                                                            .endTick -
                                                        a.completionData
                                                            .startTick} tick${a.completionData
                                                            .endTick -
                                                            a.completionData
                                                                .startTick ==
                                                            1
                                                            ? ""
                                                            : "s"}${a.completionData
                                                            .containsUnloadedChunks
                                                            ? "; Some blocks were not generated because they were in unloaded chunks. "
                                                            : ""}`
                                                    );
                                                },
                                                (e) => {
                                                    player.sendError(
                                                        "§c" + e + e.stack,
                                                        true
                                                    );
                                                }
                                            );
                                        } catch (e) {
                                            player.sendError(
                                                "§c" + e + e.stack,
                                                true
                                            );
                                        } finally {
                                            tac.forEach((tab) => tab?.remove());
                                        }
                                    });
                                } catch (e) {
                                    player.sendError("§c" + e + e.stack, true);
                                }
                            });
                        }
                    }
                }
                break;
            case !!switchTest.match(/^\\seti$/):
                {
                    eventData.cancel = true;
                    const args = evaluateParameters(switchTestB, [
                        "presetText",
                        "f-c",
                        "number",
                        "blockPattern",
                    ]).args;
                    const integrity = args[2] as number;
                    const firstblockpattern = args[3] as BlockPattern;
                    const coordinatesa = player.getDynamicProperty("pos1") as Vector3 |
                        undefined;
                    const coordinatesb = player.getDynamicProperty("pos2") as Vector3 |
                        undefined;
                    const ca = {
                        x: Math.min(coordinatesa.x, coordinatesb.x),
                        y: Math.min(coordinatesa.y, coordinatesb.y),
                        z: Math.min(coordinatesa.z, coordinatesb.z),
                    };
                    const cb = {
                        x: Math.max(coordinatesa.x, coordinatesb.x),
                        y: Math.max(coordinatesa.y, coordinatesb.y),
                        z: Math.max(coordinatesa.z, coordinatesb.z),
                    };
                    const dimensiona = world.getDimension(
                        (player.getDynamicProperty("posD") ??
                            player.dimension.id) as string
                    ) as Dimension | undefined;
                    if (!!!coordinatesa) {
                        player.sendMessageB("§cError: pos1 is not set.");
                    } else {
                        if (!!!coordinatesb) {
                            player.sendMessageB("§cError: pos2 is not set.");
                        } else {
                            system.run(() => {
                                let ta: Entity[];
                                try {
                                    generateTickingAreaFillCoordinatesC(
                                        player.location,
                                        (() => {
                                            let a = new CompoundBlockVolume();
                                            a.pushVolume({
                                                volume: new BlockVolume(ca, cb),
                                            });
                                            return a;
                                        })(),
                                        dimensiona
                                    ).then((tac) => {
                                        ta = tac;
                                        try {
                                            undoClipboard.save(
                                                dimensiona,
                                                { from: ca, to: cb },
                                                Date.now(),
                                                {
                                                    includeBlocks: true,
                                                    includeEntities: false,
                                                    saveMode: config.undoClipboardMode,
                                                }
                                            );
                                        } catch (e) {
                                            player.sendMessageB(
                                                "§c" + e + " " + e.stack
                                            );
                                        }
                                        const blocktypes = BlockTypes.getAll();
                                        try {
                                            fillBlocksHFGB(
                                                ca,
                                                cb,
                                                dimensiona,
                                                (l, i) => {
                                                    const b = firstblockpattern.generateBlock(
                                                        i
                                                    );
                                                    return b.type == "random"
                                                        ? BlockPermutation.resolve(
                                                            blocktypes[Math.floor(
                                                                blocktypes.length *
                                                                Math.random()
                                                            )].id
                                                        )
                                                        : BlockPermutation.resolve(
                                                            b.type,
                                                            b.states
                                                        );
                                                },
                                                { minMSBetweenYields: 2500 },
                                                args[1].c,
                                                integrity
                                            ).then(
                                                (a) => {
                                                    player.sendMessageB(
                                                        `${a.counter == 0
                                                            ? "§c"
                                                            : ""}${a.counter} blocks replaced in ${a.completionData
                                                            .endTime -
                                                        a.completionData
                                                            .startTime} ms over ${a.completionData
                                                            .endTick -
                                                        a.completionData
                                                            .startTick} tick${a.completionData
                                                            .endTick -
                                                            a.completionData
                                                                .startTick ==
                                                            1
                                                            ? ""
                                                            : "s"}${a.completionData
                                                            .containsUnloadedChunks
                                                            ? "; Some blocks were not generated because they were in unloaded chunks. "
                                                            : ""}`
                                                    );
                                                },
                                                (e) => {
                                                    player.sendError(
                                                        "§c" + e + e.stack,
                                                        true
                                                    );
                                                }
                                            );
                                        } catch (e) {
                                            player.sendError(
                                                "§c" + e + e.stack,
                                                true
                                            );
                                        } finally {
                                            tac.forEach((tab) => tab?.remove());
                                        }
                                    });
                                } catch (e) {
                                    player.sendError("§c" + e + e.stack, true);
                                }
                            });
                        }
                    }
                }
                break;
            case !!switchTest.match(/^\\flood$/):
                {
                    eventData.cancel = true;
                    const coordinatesa = player.getDynamicProperty("pos1") as Vector3 |
                        undefined;
                    const coordinatesb = player.getDynamicProperty("pos2") as Vector3 |
                        undefined;
                    const ca = {
                        x: Math.min(coordinatesa.x, coordinatesb.x),
                        y: Math.min(coordinatesa.y, coordinatesb.y),
                        z: Math.min(coordinatesa.z, coordinatesb.z),
                    };
                    const cb = {
                        x: Math.max(coordinatesa.x, coordinatesb.x),
                        y: Math.max(coordinatesa.y, coordinatesb.y),
                        z: Math.max(coordinatesa.z, coordinatesb.z),
                    };
                    const dimensiona = world.getDimension(
                        (player.getDynamicProperty("posD") ??
                            player.dimension.id) as string
                    ) as Dimension | undefined;
                    if (!!!coordinatesa) {
                        player.sendMessageB("§cError: pos1 is not set.");
                    } else {
                        if (!!!coordinatesb) {
                            player.sendMessageB("§cError: pos2 is not set.");
                        } else {
                            system.run(() => {
                                let ta: Entity[];
                                try {
                                    generateTickingAreaFillCoordinatesC(
                                        player.location,
                                        (() => {
                                            let a = new CompoundBlockVolume();
                                            a.pushVolume({
                                                volume: new BlockVolume(ca, cb),
                                            });
                                            return a;
                                        })(),
                                        dimensiona
                                    ).then((tac) => {
                                        ta = tac;
                                        try {
                                            undoClipboard.save(
                                                dimensiona,
                                                { from: ca, to: cb },
                                                Date.now(),
                                                {
                                                    includeBlocks: true,
                                                    includeEntities: false,
                                                    saveMode: config.undoClipboardMode,
                                                }
                                            );
                                        } catch (e) {
                                            perror(player, e);
                                        }
                                        try {
                                            fillBlocksHFFGB(
                                                ca,
                                                cb,
                                                dimensiona,
                                                { minMSBetweenYields: 2500 },
                                                100
                                            ).then(
                                                (a) => {
                                                    player.sendMessageB(
                                                        `${a.counter == 0
                                                            ? "§c"
                                                            : ""}${a.counter} blocks replaced in ${a.completionData
                                                            .endTime -
                                                        a.completionData
                                                            .startTime} ms over ${a.completionData
                                                            .endTick -
                                                        a.completionData
                                                            .startTick} tick${a.completionData
                                                            .endTick -
                                                            a.completionData
                                                                .startTick ==
                                                            1
                                                            ? ""
                                                            : "s"}${a.completionData
                                                            .containsUnloadedChunks
                                                            ? "; Some blocks were not generated because they were in unloaded chunks. "
                                                            : ""}`
                                                    );
                                                },
                                                (e) => {
                                                    player.sendError(
                                                        "§c" + e + e.stack,
                                                        true
                                                    );
                                                }
                                            );
                                        } catch (e) {
                                            player.sendError(
                                                "§c" + e + e.stack,
                                                true
                                            );
                                        } finally {
                                            tac.forEach((tab) => tab?.remove());
                                        }
                                    });
                                } catch (e) {
                                    player.sendError("§c" + e + e.stack, true);
                                }
                            });
                        }
                    }
                }
                break;
            case !!switchTest.match(/^\\drain$/):
                {
                    eventData.cancel = true;
                    const coordinatesa = player.getDynamicProperty("pos1") as Vector3 |
                        undefined;
                    const coordinatesb = player.getDynamicProperty("pos2") as Vector3 |
                        undefined;
                    const ca = {
                        x: Math.min(coordinatesa.x, coordinatesb.x),
                        y: Math.min(coordinatesa.y, coordinatesb.y),
                        z: Math.min(coordinatesa.z, coordinatesb.z),
                    };
                    const cb = {
                        x: Math.max(coordinatesa.x, coordinatesb.x),
                        y: Math.max(coordinatesa.y, coordinatesb.y),
                        z: Math.max(coordinatesa.z, coordinatesb.z),
                    };
                    const dimensiona = world.getDimension(
                        (player.getDynamicProperty("posD") ??
                            player.dimension.id) as string
                    ) as Dimension | undefined;
                    const airpermutation = BlockPermutation.resolve("air");
                    if (!!!coordinatesa) {
                        player.sendMessageB("§cError: pos1 is not set.");
                    } else {
                        if (!!!coordinatesb) {
                            player.sendMessageB("§cError: pos2 is not set.");
                        } else {
                            system.run(() => {
                                let ta: Entity[];
                                try {
                                    generateTickingAreaFillCoordinatesC(
                                        player.location,
                                        (() => {
                                            let a = new CompoundBlockVolume();
                                            a.pushVolume({
                                                volume: new BlockVolume(ca, cb),
                                            });
                                            return a;
                                        })(),
                                        dimensiona
                                    ).then((tac) => {
                                        ta = tac;
                                        try {
                                            undoClipboard.save(
                                                dimensiona,
                                                { from: ca, to: cb },
                                                Date.now(),
                                                {
                                                    includeBlocks: true,
                                                    includeEntities: false,
                                                    saveMode: config.undoClipboardMode,
                                                }
                                            );
                                        } catch (e) {
                                            perror(player, e);
                                        }
                                        try {
                                            fillBlocksHDFGB(
                                                ca,
                                                cb,
                                                dimensiona,
                                                { minMSBetweenYields: 2500 },
                                                100
                                            ).then(
                                                (a) => {
                                                    player.sendMessageB(
                                                        `${a.counter == 0
                                                            ? "§c"
                                                            : ""}${a.counter} blocks replaced in ${a.completionData
                                                            .endTime -
                                                        a.completionData
                                                            .startTime} ms over ${a.completionData
                                                            .endTick -
                                                        a.completionData
                                                            .startTick} tick${a.completionData
                                                            .endTick -
                                                            a.completionData
                                                                .startTick ==
                                                            1
                                                            ? ""
                                                            : "s"}${a.completionData
                                                            .containsUnloadedChunks
                                                            ? "; Some blocks were not generated because they were in unloaded chunks. "
                                                            : ""}`
                                                    );
                                                },
                                                (e) => {
                                                    player.sendError(
                                                        "§c" + e + e.stack,
                                                        true
                                                    );
                                                }
                                            );
                                        } catch (e) {
                                            player.sendError(
                                                "§c" + e + e.stack,
                                                true
                                            );
                                        } finally {
                                            tac.forEach((tab) => tab?.remove());
                                        }
                                    });
                                } catch (e) {
                                    player.sendError("§c" + e + e.stack, true);
                                } /*
                        try{
                            fillBlocksHFGB(ca, cb, dimensiona, ()=>airpermutation, {matchingBlock: "minecraft:water", minMSBetweenYields: 2500}).then(a=>{
                                fillBlocksHFGB(ca, cb, dimensiona, ()=>airpermutation, {matchingBlock: "minecraft:flowing_water", minMSBetweenYields: 2500}).then(b=>{
                                    fillBlocksHFGB(ca, cb, dimensiona, ()=>airpermutation, {matchingBlock: "minecraft:lava", minMSBetweenYields: 2500}).then(c=>{
                                        fillBlocksHFGB(ca, cb, dimensiona, ()=>airpermutation, {matchingBlock: "minecraft:flowing_lava", minMSBetweenYields: 2500}).then(d=>{
                                            player.sendMessageB(`${a.counter+b.counter+c.counter+d.counter==0?"§c":""}${a.counter} blocks replaced in ${(a.completionData.endTime-a.completionData.startTime)+(b.completionData.endTime-b.completionData.startTime)+(c.completionData.endTime-c.completionData.startTime)+(d.completionData.endTime-d.completionData.startTime)} ms over ${(a.completionData.endTick-a.completionData.startTick)+(b.completionData.endTick-b.completionData.startTick)+(c.completionData.endTick-c.completionData.startTick)+(d.completionData.endTick-d.completionData.startTick)} tick${((a.completionData.endTick-a.completionData.startTick)+(b.completionData.endTick-b.completionData.startTick)+(c.completionData.endTick-c.completionData.startTick)+(d.completionData.endTick-d.completionData.startTick))==1?"":"s"}${a.completionData.containsUnloadedChunks?"; Some blocks were not generated because they were in unloaded chunks. ":""}`);
                                        }, (e)=>{
                                            player.sendError("§c" + e + e.stack, true)
                                        })
                                    }, (e)=>{
                                        player.sendError("§c" + e + e.stack, true)
                                    })
                                }, (e)=>{
                                    player.sendError("§c" + e + e.stack, true)
                                })
                            }, (e)=>{
                                player.sendError("§c" + e + e.stack, true)
                            })
                        }catch(e){player.sendError("§c" + e + e.stack, true)}finally{tac.forEach(tab=>tab?.remove())}}); }catch(e){player.sendError("§c" + e + e.stack, true)}*/



















                            });
                        }
                    }
                }
                break;
            case !!switchTest.match(/^\\remove$/):
                {
                    eventData.cancel = true;
                    const args = evaluateParameters(switchTestB, [
                        "presetText",
                        "f-c",
                        "block",
                    ]).args;
                    const lastblockname = args[2]?.id;
                    const lastblockstates = args[2]?.states;
                    const matchingblock = (
                        (lastblockname ?? "") == ""
                            ? [undefined, undefined]
                            : lastblockname == "keep"
                                ? ["air"]
                                : [
                                    BlockTypes.get(lastblockname).id,
                                    lastblockstates,
                                ]
                    ) as [
                            string | undefined,
                            Record<string, string | number | boolean> | undefined
                        ];
                    const coordinatesa = player.getDynamicProperty("pos1") as Vector3 |
                        undefined;
                    const coordinatesb = player.getDynamicProperty("pos2") as Vector3 |
                        undefined;
                    const ca = {
                        x: Math.min(coordinatesa.x, coordinatesb.x),
                        y: Math.min(coordinatesa.y, coordinatesb.y),
                        z: Math.min(coordinatesa.z, coordinatesb.z),
                    };
                    const cb = {
                        x: Math.max(coordinatesa.x, coordinatesb.x),
                        y: Math.max(coordinatesa.y, coordinatesb.y),
                        z: Math.max(coordinatesa.z, coordinatesb.z),
                    };
                    const dimensiona = world.getDimension(
                        (player.getDynamicProperty("posD") ??
                            player.dimension.id) as string
                    ) as Dimension | undefined;
                    const airpermutation = BlockPermutation.resolve("air");
                    if (!!!coordinatesa) {
                        player.sendMessageB("§cError: pos1 is not set.");
                    } else {
                        if (!!!coordinatesb) {
                            player.sendMessageB("§cError: pos2 is not set.");
                        } else {
                            system.run(() => {
                                let ta: Entity[];
                                try {
                                    generateTickingAreaFillCoordinatesC(
                                        player.location,
                                        (() => {
                                            let a = new CompoundBlockVolume();
                                            a.pushVolume({
                                                volume: new BlockVolume(ca, cb),
                                            });
                                            return a;
                                        })(),
                                        dimensiona
                                    ).then((tac) => {
                                        ta = tac;
                                        try {
                                            undoClipboard.save(
                                                dimensiona,
                                                { from: ca, to: cb },
                                                Date.now(),
                                                {
                                                    includeBlocks: true,
                                                    includeEntities: false,
                                                    saveMode: config.undoClipboardMode,
                                                }
                                            );
                                        } catch (e) {
                                            player.sendMessageB(
                                                "§c" + e + " " + e.stack
                                            );
                                        }
                                        const blocktypes = BlockTypes.getAll();
                                        try {
                                            fillBlocksHFGB(
                                                ca,
                                                cb,
                                                dimensiona,
                                                () => airpermutation,
                                                {
                                                    matchingBlock: matchingblock[0],
                                                    matchingBlockStates: matchingblock[1],
                                                    minMSBetweenYields: 2500,
                                                },
                                                args[1].c,
                                                100
                                            ).then(
                                                (a) => {
                                                    player.sendMessageB(
                                                        `${a.counter == 0
                                                            ? "§c"
                                                            : ""}${a.counter} blocks replaced in ${a.completionData
                                                            .endTime -
                                                        a.completionData
                                                            .startTime} ms over ${a.completionData
                                                            .endTick -
                                                        a.completionData
                                                            .startTick} tick${a.completionData
                                                            .endTick -
                                                            a.completionData
                                                                .startTick ==
                                                            1
                                                            ? ""
                                                            : "s"}${a.completionData
                                                            .containsUnloadedChunks
                                                            ? "; Some blocks were not generated because they were in unloaded chunks. "
                                                            : ""}`
                                                    );
                                                },
                                                (e) => {
                                                    player.sendError(
                                                        "§c" + e + e.stack,
                                                        true
                                                    );
                                                }
                                            );
                                        } catch (e) {
                                            player.sendError(
                                                "§c" + e + e.stack,
                                                true
                                            );
                                        } finally {
                                            tac.forEach((tab) => tab?.remove());
                                        }
                                    });
                                } catch (e) {
                                    player.sendError("§c" + e + e.stack, true);
                                }
                            });
                        }
                    }
                }
                break;
            case !!switchTest.match(/^\\walls$/):
                {
                    eventData.cancel = true;
                    const args = evaluateParameters(switchTestB, [
                        "presetText",
                        "f-c",
                        "blockPattern",
                        "block",
                    ]).args;
                    const firstblockpattern = args[2] as BlockPattern;
                    const lastblockname = args[3]?.id;
                    const lastblockstates = args[3]?.states;
                    const matchingblock = (
                        (lastblockname ?? "") == ""
                            ? [undefined, undefined]
                            : lastblockname == "keep"
                                ? ["air"]
                                : [
                                    BlockTypes.get(lastblockname).id,
                                    lastblockstates,
                                ]
                    ) as [
                            string | undefined,
                            Record<string, string | number | boolean> | undefined
                        ];
                    const coordinatesa = player.getDynamicProperty("pos1") as Vector3 |
                        undefined;
                    const coordinatesb = player.getDynamicProperty("pos2") as Vector3 |
                        undefined;
                    const ca = {
                        x: Math.min(coordinatesa.x, coordinatesb.x),
                        y: Math.min(coordinatesa.y, coordinatesb.y),
                        z: Math.min(coordinatesa.z, coordinatesb.z),
                    };
                    const cb = {
                        x: Math.max(coordinatesa.x, coordinatesb.x),
                        y: Math.max(coordinatesa.y, coordinatesb.y),
                        z: Math.max(coordinatesa.z, coordinatesb.z),
                    };
                    const dimensiona = world.getDimension(
                        (player.getDynamicProperty("posD") ??
                            player.dimension.id) as string
                    ) as Dimension | undefined;
                    if (!!!coordinatesa) {
                        player.sendMessageB("§cError: pos1 is not set.");
                    } else {
                        if (!!!coordinatesb) {
                            player.sendMessageB("§cError: pos2 is not set.");
                        } else {
                            system.run(() => {
                                let ta: Entity[];
                                try {
                                    generateTickingAreaFillCoordinatesC(
                                        player.location,
                                        (() => {
                                            let a = new CompoundBlockVolume();
                                            a.pushVolume({
                                                volume: new BlockVolume(ca, cb),
                                            });
                                            return a;
                                        })(),
                                        dimensiona
                                    ).then((tac) => {
                                        ta = tac;
                                        try {
                                            undoClipboard.save(
                                                dimensiona,
                                                { from: ca, to: cb },
                                                Date.now(),
                                                {
                                                    includeBlocks: true,
                                                    includeEntities: false,
                                                    saveMode: config.undoClipboardMode,
                                                }
                                            );
                                        } catch (e) {
                                            player.sendMessageB(
                                                "§c" + e + " " + e.stack
                                            );
                                        }
                                        const blocktypes = BlockTypes.getAll();
                                        try {
                                            fillBlocksHWFGB(
                                                ca,
                                                cb,
                                                dimensiona,
                                                (l, i) => {
                                                    const b = firstblockpattern.generateBlock(
                                                        i
                                                    );
                                                    return b.type == "random"
                                                        ? BlockPermutation.resolve(
                                                            blocktypes[Math.floor(
                                                                blocktypes.length *
                                                                Math.random()
                                                            )].id
                                                        )
                                                        : BlockPermutation.resolve(
                                                            b.type,
                                                            b.states
                                                        );
                                                },
                                                {
                                                    matchingBlock: matchingblock[0],
                                                    matchingBlockStates: matchingblock[1],
                                                    minMSBetweenYields: 2500,
                                                },
                                                args[1].c,
                                                100
                                            ).then(
                                                (a) => {
                                                    player.sendMessageB(
                                                        `${a.counter == 0
                                                            ? "§c"
                                                            : ""}${a.counter} blocks replaced in ${a.completionData
                                                            .endTime -
                                                        a.completionData
                                                            .startTime} ms over ${a.completionData
                                                            .endTick -
                                                        a.completionData
                                                            .startTick} tick${a.completionData
                                                            .endTick -
                                                            a.completionData
                                                                .startTick ==
                                                            1
                                                            ? ""
                                                            : "s"}${a.completionData
                                                            .containsUnloadedChunks
                                                            ? "; Some blocks were not generated because they were in unloaded chunks. "
                                                            : ""}`
                                                    );
                                                },
                                                (e) => {
                                                    player.sendError(
                                                        "§c" + e + e.stack,
                                                        true
                                                    );
                                                }
                                            );
                                        } catch (e) {
                                            player.sendError(
                                                "§c" + e + e.stack,
                                                true
                                            );
                                        } finally {
                                            tac.forEach((tab) => tab?.remove());
                                        }
                                    });
                                } catch (e) {
                                    player.sendError("§c" + e + e.stack, true);
                                }
                            });
                        }
                    }
                }
                break;
            case !!switchTest.match(/^\\sphere$/):
                {
                    eventData.cancel = true;
                    const args = evaluateParameters(switchTestB, [
                        "presetText",
                        "f-c",
                        "number",
                        "blockPattern",
                        "block",
                    ]).args;
                    const radius = args[2] as number;
                    const firstblockpattern = args[3] as BlockPattern;
                    const lastblockname = args[4]?.id;
                    const lastblockstates = args[4]?.states;
                    const matchingblock = (
                        (lastblockname ?? "") == ""
                            ? [undefined, undefined]
                            : lastblockname == "keep"
                                ? ["air"]
                                : [
                                    BlockTypes.get(lastblockname).id,
                                    lastblockstates,
                                ]
                    ) as [
                            string | undefined,
                            Record<string, string | number | boolean> | undefined
                        ];
                    const coordinatesa = roundVector3ToMiddleOfBlock(
                        player.getDynamicProperty("pos1") as Vector3 | undefined
                    );
                    const coordinatesb = roundVector3ToMiddleOfBlock(
                        player.getDynamicProperty("pos2") as Vector3 | undefined
                    );
                    const ca = {
                        x: Math.min(coordinatesa.x, coordinatesb.x),
                        y: Math.min(coordinatesa.y, coordinatesb.y),
                        z: Math.min(coordinatesa.z, coordinatesb.z),
                    };
                    const cb = {
                        x: Math.max(coordinatesa.x, coordinatesb.x),
                        y: Math.max(coordinatesa.y, coordinatesb.y),
                        z: Math.max(coordinatesa.z, coordinatesb.z),
                    };
                    const dimensiona = world.getDimension(
                        (player.getDynamicProperty("posD") ??
                            player.dimension.id) as string
                    ) as Dimension | undefined;
                    if (!!!coordinatesa) {
                        player.sendMessageB("§cError: pos1 is not set.");
                    } else {
                        if (!!!coordinatesb) {
                            player.sendMessageB("§cError: pos2 is not set.");
                        } else {
                            system.run(() => {
                                let ta: Entity[];
                                try {
                                    generateTickingAreaFillCoordinatesC(
                                        player.location,
                                        (() => {
                                            let a = new CompoundBlockVolume();
                                            a.pushVolume({
                                                volume: new BlockVolume(
                                                    Vector.subtract(
                                                        coordinatesa,
                                                        Vector.scale(
                                                            Vector.one,
                                                            Math.abs(radius)
                                                        )
                                                    ),
                                                    Vector.add(
                                                        coordinatesa,
                                                        Vector.scale(
                                                            Vector.one,
                                                            Math.abs(radius)
                                                        )
                                                    )
                                                ),
                                            });
                                            return a;
                                        })(),
                                        dimensiona
                                    ).then((tac) => {
                                        ta = tac;
                                        try {
                                            undoClipboard.save(
                                                dimensiona,
                                                {
                                                    from: Vector.subtract(
                                                        coordinatesa,
                                                        Vector.scale(
                                                            Vector.one,
                                                            Math.abs(radius)
                                                        )
                                                    ),
                                                    to: Vector.add(
                                                        coordinatesa,
                                                        Vector.scale(
                                                            Vector.one,
                                                            Math.abs(radius)
                                                        )
                                                    ),
                                                },
                                                Date.now(),
                                                {
                                                    includeBlocks: true,
                                                    includeEntities: false,
                                                    saveMode: config.undoClipboardMode,
                                                }
                                            );
                                        } catch (e) {
                                            player.sendMessageB(
                                                "§c" + e + " " + e.stack
                                            );
                                        }
                                        const blocktypes = BlockTypes.getAll();
                                        try {
                                            fillBlocksHSGB(
                                                coordinatesa,
                                                radius - 0.5,
                                                dimensiona,
                                                (l, i) => {
                                                    const b = firstblockpattern.generateBlock(
                                                        i
                                                    );
                                                    return b.type == "random"
                                                        ? BlockPermutation.resolve(
                                                            blocktypes[Math.floor(
                                                                blocktypes.length *
                                                                Math.random()
                                                            )].id
                                                        )
                                                        : BlockPermutation.resolve(
                                                            b.type,
                                                            b.states
                                                        );
                                                },
                                                {
                                                    matchingBlock: matchingblock[0],
                                                    matchingBlockStates: matchingblock[1],
                                                    minMSBetweenYields: 2500,
                                                },
                                                args[1].c,
                                                100
                                            ).then(
                                                (a) => {
                                                    player.sendMessageB(
                                                        `${a.counter == 0
                                                            ? "§c"
                                                            : ""}${a.counter} blocks filled in ${a.completionData
                                                            .endTime -
                                                        a.completionData
                                                            .startTime} ms over ${a.completionData
                                                            .endTick -
                                                        a.completionData
                                                            .startTick} tick${a.completionData
                                                            .endTick -
                                                            a.completionData
                                                                .startTick ==
                                                            1
                                                            ? ""
                                                            : "s"}${a.completionData
                                                            .containsUnloadedChunks
                                                            ? "; Some blocks were not generated because they were in unloaded chunks. "
                                                            : ""}`
                                                    );
                                                },
                                                (e) => {
                                                    player.sendError(
                                                        "§c" + e + e.stack,
                                                        true
                                                    );
                                                }
                                            );
                                        } catch (e) {
                                            player.sendError(
                                                "§c" + e + e.stack,
                                                true
                                            );
                                        } finally {
                                            tac.forEach((tab) => tab?.remove());
                                        }
                                    });
                                } catch (e) {
                                    player.sendError("§c" + e + e.stack, true);
                                }
                            });
                        }
                    }
                }
                break;
            case !!switchTest.match(/^\\hsphere$/) ||
                !!switchTest.match(/^\\hollowsphere$/):
                {
                    eventData.cancel = true;
                    const args = evaluateParameters(switchTestB, [
                        "presetText",
                        "f-c",
                        "number",
                        "number",
                        "blockPattern",
                        "block",
                    ]).args;
                    const radius = args[2] as number;
                    const thickness = args[3] as number;
                    const firstblockpattern = args[4] as BlockPattern;
                    const lastblockname = args[5]?.id;
                    const lastblockstates = args[5]?.states;
                    const matchingblock = (
                        (lastblockname ?? "") == ""
                            ? [undefined, undefined]
                            : lastblockname == "keep"
                                ? ["air"]
                                : [
                                    BlockTypes.get(lastblockname).id,
                                    lastblockstates,
                                ]
                    ) as [
                            string | undefined,
                            Record<string, string | number | boolean> | undefined
                        ];
                    const coordinatesa = roundVector3ToMiddleOfBlock(
                        player.getDynamicProperty("pos1") as Vector3 | undefined
                    );
                    const coordinatesb = roundVector3ToMiddleOfBlock(
                        player.getDynamicProperty("pos2") as Vector3 | undefined
                    );
                    const ca = {
                        x: Math.min(coordinatesa.x, coordinatesb.x),
                        y: Math.min(coordinatesa.y, coordinatesb.y),
                        z: Math.min(coordinatesa.z, coordinatesb.z),
                    };
                    const cb = {
                        x: Math.max(coordinatesa.x, coordinatesb.x),
                        y: Math.max(coordinatesa.y, coordinatesb.y),
                        z: Math.max(coordinatesa.z, coordinatesb.z),
                    };
                    const dimensiona = world.getDimension(
                        (player.getDynamicProperty("posD") ??
                            player.dimension.id) as string
                    ) as Dimension | undefined;
                    if (!!!coordinatesa) {
                        player.sendMessageB("§cError: pos1 is not set.");
                    } else {
                        if (!!!coordinatesb) {
                            player.sendMessageB("§cError: pos2 is not set.");
                        } else {
                            system.run(() => {
                                let ta: Entity[];
                                try {
                                    generateTickingAreaFillCoordinatesC(
                                        player.location,
                                        (() => {
                                            let a = new CompoundBlockVolume();
                                            a.pushVolume({
                                                volume: new BlockVolume(
                                                    Vector.subtract(
                                                        coordinatesa,
                                                        Vector.scale(
                                                            Vector.one,
                                                            Math.abs(radius)
                                                        )
                                                    ),
                                                    Vector.add(
                                                        coordinatesa,
                                                        Vector.scale(
                                                            Vector.one,
                                                            Math.abs(radius)
                                                        )
                                                    )
                                                ),
                                            });
                                            return a;
                                        })(),
                                        dimensiona
                                    ).then((tac) => {
                                        ta = tac;
                                        try {
                                            undoClipboard.save(
                                                dimensiona,
                                                {
                                                    from: Vector.subtract(
                                                        coordinatesa,
                                                        Vector.scale(
                                                            Vector.one,
                                                            Math.abs(radius)
                                                        )
                                                    ),
                                                    to: Vector.add(
                                                        coordinatesa,
                                                        Vector.scale(
                                                            Vector.one,
                                                            Math.abs(radius)
                                                        )
                                                    ),
                                                },
                                                Date.now(),
                                                {
                                                    includeBlocks: true,
                                                    includeEntities: false,
                                                    saveMode: config.undoClipboardMode,
                                                }
                                            );
                                        } catch (e) {
                                            player.sendMessageB(
                                                "§c" + e + " " + e.stack
                                            );
                                        }
                                        const blocktypes = BlockTypes.getAll();
                                        try {
                                            fillBlocksHHSGB(
                                                coordinatesa,
                                                radius - 0.5,
                                                thickness,
                                                dimensiona,
                                                (l, i) => {
                                                    const b = firstblockpattern.generateBlock(
                                                        i
                                                    );
                                                    return b.type == "random"
                                                        ? BlockPermutation.resolve(
                                                            blocktypes[Math.floor(
                                                                blocktypes.length *
                                                                Math.random()
                                                            )].id
                                                        )
                                                        : BlockPermutation.resolve(
                                                            b.type,
                                                            b.states
                                                        );
                                                },
                                                {
                                                    matchingBlock: matchingblock[0],
                                                    matchingBlockStates: matchingblock[1],
                                                    minMSBetweenYields: 2500,
                                                },
                                                args[1].c,
                                                100
                                            ).then(
                                                (a) => {
                                                    player.sendMessageB(
                                                        `${a.counter == 0
                                                            ? "§c"
                                                            : ""}${a.counter} blocks filled in ${a.completionData
                                                            .endTime -
                                                        a.completionData
                                                            .startTime} ms over ${a.completionData
                                                            .endTick -
                                                        a.completionData
                                                            .startTick} tick${a.completionData
                                                            .endTick -
                                                            a.completionData
                                                                .startTick ==
                                                            1
                                                            ? ""
                                                            : "s"}${a.completionData
                                                            .containsUnloadedChunks
                                                            ? "; Some blocks were not generated because they were in unloaded chunks. "
                                                            : ""}`
                                                    );
                                                },
                                                (e) => {
                                                    player.sendError(
                                                        "§c" + e + e.stack,
                                                        true
                                                    );
                                                }
                                            );
                                        } catch (e) {
                                            player.sendError(
                                                "§c" + e + e.stack,
                                                true
                                            );
                                        } finally {
                                            tac.forEach((tab) => tab?.remove());
                                        }
                                    });
                                } catch (e) {
                                    player.sendError("§c" + e + e.stack, true);
                                }
                            });
                        }
                    }
                }
                break;
            case !!switchTest.match(/^\\cone$/):
                {
                    eventData.cancel = true;
                    const args = evaluateParameters(switchTestB, [
                        "presetText",
                        "f-c",
                        "number",
                        "number",
                        "blockPattern",
                        "block",
                    ]).args;
                    const radius = args[2] as number;
                    const height = args[3] as number;
                    const firstblockpattern = args[4] as BlockPattern;
                    const lastblockname = args[5]?.id;
                    const lastblockstates = args[5]?.states;
                    const matchingblock = (
                        (lastblockname ?? "") == ""
                            ? [undefined, undefined]
                            : lastblockname == "keep"
                                ? ["air"]
                                : [
                                    BlockTypes.get(lastblockname).id,
                                    lastblockstates,
                                ]
                    ) as [
                            string | undefined,
                            Record<string, string | number | boolean> | undefined
                        ];
                    const coordinatesa = roundVector3ToMiddleOfBlockFloorY(
                        player.getDynamicProperty("pos1") as Vector3 | undefined
                    );
                    const coordinatesb = roundVector3ToMiddleOfBlockFloorY(
                        player.getDynamicProperty("pos2") as Vector3 | undefined
                    );
                    const ca = {
                        x: Math.min(coordinatesa.x, coordinatesb.x),
                        y: Math.min(coordinatesa.y, coordinatesb.y),
                        z: Math.min(coordinatesa.z, coordinatesb.z),
                    };
                    const cb = {
                        x: Math.max(coordinatesa.x, coordinatesb.x),
                        y: Math.max(coordinatesa.y, coordinatesb.y),
                        z: Math.max(coordinatesa.z, coordinatesb.z),
                    };
                    const dimensiona = world.getDimension(
                        (player.getDynamicProperty("posD") ??
                            player.dimension.id) as string
                    ) as Dimension | undefined;
                    if (!!!coordinatesa) {
                        player.sendMessageB("§cError: pos1 is not set.");
                    } else {
                        if (!!!coordinatesb) {
                            player.sendMessageB("§cError: pos2 is not set.");
                        } else {
                            system.run(() => {
                                let ta: Entity[];
                                try {
                                    generateTickingAreaFillCoordinatesC(
                                        player.location,
                                        (() => {
                                            let a = new CompoundBlockVolume();
                                            a.pushVolume({
                                                volume: new BlockVolume(
                                                    Vector.subtract(
                                                        coordinatesa,
                                                        {
                                                            x: Math.abs(radius),
                                                            y: 0,
                                                            z: Math.abs(radius),
                                                        }
                                                    ),
                                                    Vector.add(coordinatesa, {
                                                        x: Math.abs(radius),
                                                        y: height,
                                                        z: Math.abs(radius),
                                                    })
                                                ),
                                            });
                                            return a;
                                        })(),
                                        dimensiona
                                    ).then((tac) => {
                                        ta = tac;
                                        try {
                                            undoClipboard.save(
                                                dimensiona,
                                                {
                                                    from: Vector.subtract(
                                                        coordinatesa,
                                                        {
                                                            x: Math.abs(radius),
                                                            y: 0,
                                                            z: Math.abs(radius),
                                                        }
                                                    ),
                                                    to: Vector.add(
                                                        coordinatesa,
                                                        {
                                                            x: Math.abs(radius),
                                                            y: height,
                                                            z: Math.abs(radius),
                                                        }
                                                    ),
                                                },
                                                Date.now(),
                                                {
                                                    includeBlocks: true,
                                                    includeEntities: false,
                                                    saveMode: config.undoClipboardMode,
                                                }
                                            );
                                        } catch (e) {
                                            player.sendMessageB(
                                                "§c" + e + " " + e.stack
                                            );
                                        }
                                        const blocktypes = BlockTypes.getAll();
                                        try {
                                            fillBlocksHCGB(
                                                coordinatesa,
                                                radius,
                                                height,
                                                dimensiona,
                                                (l, i) => {
                                                    const b = firstblockpattern.generateBlock(
                                                        i
                                                    );
                                                    return b.type == "random"
                                                        ? BlockPermutation.resolve(
                                                            blocktypes[Math.floor(
                                                                blocktypes.length *
                                                                Math.random()
                                                            )].id
                                                        )
                                                        : BlockPermutation.resolve(
                                                            b.type,
                                                            b.states
                                                        );
                                                },
                                                {
                                                    matchingBlock: matchingblock[0],
                                                    matchingBlockStates: matchingblock[1],
                                                    minMSBetweenYields: 2500,
                                                },
                                                args[1].c,
                                                100
                                            ).then(
                                                (a) => {
                                                    player.sendMessageB(
                                                        `${a.counter == 0
                                                            ? "§c"
                                                            : ""}${a.counter} blocks filled in ${a.completionData
                                                            .endTime -
                                                        a.completionData
                                                            .startTime} ms over ${a.completionData
                                                            .endTick -
                                                        a.completionData
                                                            .startTick} tick${a.completionData
                                                            .endTick -
                                                            a.completionData
                                                                .startTick ==
                                                            1
                                                            ? ""
                                                            : "s"}${a.completionData
                                                            .containsUnloadedChunks
                                                            ? "; Some blocks were not generated because they were in unloaded chunks. "
                                                            : ""}`
                                                    );
                                                },
                                                (e) => {
                                                    player.sendError(
                                                        "§c" + e + e.stack,
                                                        true
                                                    );
                                                }
                                            );
                                        } catch (e) {
                                            player.sendError(
                                                "§c" + e + e.stack,
                                                true
                                            );
                                        } finally {
                                            tac.forEach((tab) => tab?.remove());
                                        }
                                    });
                                } catch (e) {
                                    player.sendError("§c" + e + e.stack, true);
                                }
                            });
                        }
                    }
                }
                break;
            case !!switchTest.match(/^\\generatef$/):
                {
                    eventData.cancel = true;
                    const argsa = evaluateParameters(switchTestB, [
                        "presetText",
                        "-sr",
                        "blockPattern",
                    ]);
                    const args = [...argsa.args, argsa.extra];
                    const firstblockpattern = args[2] as BlockPattern;
                    const expression = (
                        (args[1] as string).includes("r")
                            ? parseExpressionR
                            : (args[3] as string).includes("s")
                                ? parseExpressionKE
                                : parseExpression
                    )(args[3] as string);
                    const coordinatesa = player.getDynamicProperty("pos1") as Vector3 |
                        undefined;
                    const coordinatesb = player.getDynamicProperty("pos2") as Vector3 |
                        undefined;
                    const dimensiona = world.getDimension(
                        (player.getDynamicProperty("posD") ??
                            player.dimension.id) as string
                    ) as Dimension | undefined;
                    if (!!!coordinatesa) {
                        player.sendMessageB("§cError: pos1 is not set.");
                    } else {
                        if (!!!coordinatesb) {
                            player.sendMessageB("§cError: pos2 is not set.");
                        } else {
                            const blocktypes = BlockTypes.getAll();
                            system.run(() => {
                                let ta: Entity[];
                                try {
                                    generateTickingAreaFillCoordinatesC(
                                        player.location,
                                        (() => {
                                            let a = new CompoundBlockVolume();
                                            a.pushVolume({
                                                volume: new BlockVolume(
                                                    coordinatesa,
                                                    coordinatesb
                                                ),
                                            });
                                            return a;
                                        })(),
                                        player.dimension
                                    ).then((tac) => {
                                        ta = tac;
                                        try {
                                            completeGeneratorB(
                                                generateMathExpression(
                                                    expression as () => boolean,
                                                    (l) => {
                                                        const b = firstblockpattern.generateBlock(
                                                            l.count
                                                        );
                                                        const t = b.type == "random"
                                                            ? BlockPermutation.resolve(
                                                                blocktypes[Math.floor(
                                                                    blocktypes.length *
                                                                    Math.random()
                                                                )].id
                                                            )
                                                            : BlockPermutation.resolve(
                                                                b.type,
                                                                b.states
                                                            );
                                                        dimensiona.setBlockPermutation(
                                                            l,
                                                            t
                                                        );
                                                    },
                                                    coordinatesa,
                                                    coordinatesb,
                                                    coordinatesa,
                                                    coordinatesb
                                                ),
                                                2500
                                            ).then(
                                                (a) => {
                                                    player.sendMessageB(
                                                        `${a.return == 0n
                                                            ? "§c"
                                                            : ""}${a.return} blocks replaced`
                                                    );
                                                },
                                                (e) => {
                                                    player.sendError(
                                                        "§c" + e + e.stack,
                                                        true
                                                    );
                                                }
                                            );
                                        } catch (e) {
                                            player.sendError(
                                                "§c" + e + e.stack,
                                                true
                                            );
                                        } finally {
                                            tac.forEach((tab) => tab?.remove());
                                        }
                                    });
                                } catch (e) {
                                    player.sendError("§c" + e + e.stack, true);
                                }
                            });
                        }
                    }
                }
                break;
            case !!switchTest.match(/^\\generate$/):
                {
                    eventData.cancel = true;
                    const argsa = evaluateParameters(switchTestB, [
                        "presetText",
                        "-sr",
                        "blockPattern",
                    ]);
                    const args = [...argsa.args, argsa.extra];
                    const firstblockpattern = args[2] as BlockPattern;
                    const expression = (
                        (args[1] as string).includes("r")
                            ? parseExpressionBR
                            : (args[3] as string).includes("s")
                                ? parseExpressionBKE
                                : parseExpressionB
                    )(args[3] as string);
                    const coordinatesa = player.getDynamicProperty("pos1") as Vector3 |
                        undefined;
                    const coordinatesb = player.getDynamicProperty("pos2") as Vector3 |
                        undefined;
                    const dimensiona = world.getDimension(
                        (player.getDynamicProperty("posD") ??
                            player.dimension.id) as string
                    ) as Dimension | undefined;
                    if (!!!coordinatesa) {
                        player.sendMessageB("§cError: pos1 is not set.");
                    } else {
                        if (!!!coordinatesb) {
                            player.sendMessageB("§cError: pos2 is not set.");
                        } else {
                            const blocktypes = BlockTypes.getAll();
                            system.run(() => {
                                let ta: Entity[];
                                try {
                                    generateTickingAreaFillCoordinatesC(
                                        player.location,
                                        (() => {
                                            let a = new CompoundBlockVolume();
                                            a.pushVolume({
                                                volume: new BlockVolume(
                                                    coordinatesa,
                                                    coordinatesb
                                                ),
                                            });
                                            return a;
                                        })(),
                                        player.dimension
                                    ).then((tac) => {
                                        ta = tac;
                                        try {
                                            completeGeneratorB(
                                                generateMathExpression(
                                                    expression as () => boolean,
                                                    (l) => {
                                                        const b = firstblockpattern.generateBlock(
                                                            l.count
                                                        );
                                                        const t = b.type == "random"
                                                            ? BlockPermutation.resolve(
                                                                blocktypes[Math.floor(
                                                                    blocktypes.length *
                                                                    Math.random()
                                                                )].id
                                                            )
                                                            : BlockPermutation.resolve(
                                                                b.type,
                                                                b.states
                                                            );
                                                        dimensiona.setBlockPermutation(
                                                            l,
                                                            t
                                                        );
                                                    },
                                                    coordinatesa,
                                                    coordinatesb,
                                                    coordinatesa,
                                                    coordinatesb
                                                ),
                                                2500
                                            ).then(
                                                (a) => {
                                                    player.sendMessageB(
                                                        `${a.return == 0n
                                                            ? "§c"
                                                            : ""}${a.return} blocks replaced`
                                                    );
                                                },
                                                (e) => {
                                                    player.sendError(
                                                        "§c" + e + e.stack,
                                                        true
                                                    );
                                                }
                                            );
                                        } catch (e) {
                                            player.sendError(
                                                "§c" + e + e.stack,
                                                true
                                            );
                                        } finally {
                                            tac.forEach((tab) => tab?.remove());
                                        }
                                    });
                                } catch (e) {
                                    player.sendError("§c" + e + e.stack, true);
                                }
                            });
                        }
                    }
                }
                break;
            case !!switchTest.match(/^\\generates$/):
                {
                    eventData.cancel = true;
                    const argsa = evaluateParameters(switchTestB, [
                        "presetText",
                        "number",
                        "-sr",
                        "blockPattern",
                    ]);
                    const args = [...argsa.args, argsa.extra] as [
                        ...typeof argsa.args,
                        string
                    ];
                    const firstblockpattern = args[3] as BlockPattern;
                    const expression = (
                        (args[2] as string).includes("r")
                            ? parseExpressionBR
                            : (args[4] as string).includes("s")
                                ? parseExpressionBKE
                                : parseExpressionB
                    )(args[4] as string);
                    const coordinatesa = player.getDynamicProperty("pos1") as Vector3 |
                        undefined;
                    const coordinatesb = player.getDynamicProperty("pos2") as Vector3 |
                        undefined;
                    const dimensiona = world.getDimension(
                        (player.getDynamicProperty("posD") ??
                            player.dimension.id) as string
                    ) as Dimension | undefined;
                    if (!!!coordinatesa) {
                        player.sendMessageB("§cError: pos1 is not set.");
                    } else {
                        if (!!!coordinatesb) {
                            player.sendMessageB("§cError: pos2 is not set.");
                        } else {
                            const blocktypes = BlockTypes.getAll();
                            system.run(() => {
                                let ta: Entity[];
                                try {
                                    generateTickingAreaFillCoordinatesC(
                                        player.location,
                                        (() => {
                                            let a = new CompoundBlockVolume();
                                            a.pushVolume({
                                                volume: new BlockVolume(
                                                    coordinatesa,
                                                    coordinatesb
                                                ),
                                            });
                                            return a;
                                        })(),
                                        player.dimension
                                    ).then((tac) => {
                                        ta = tac;
                                        try {
                                            completeGeneratorB(
                                                generateMathExpression(
                                                    expression as () => boolean,
                                                    (l) => {
                                                        const b = firstblockpattern.generateBlock(
                                                            l.count
                                                        );
                                                        const t = b.type == "random"
                                                            ? BlockPermutation.resolve(
                                                                blocktypes[Math.floor(
                                                                    blocktypes.length *
                                                                    Math.random()
                                                                )].id
                                                            )
                                                            : BlockPermutation.resolve(
                                                                b.type,
                                                                b.states
                                                            );
                                                        dimensiona.setBlockPermutation(
                                                            l,
                                                            t
                                                        );
                                                    },
                                                    coordinatesa,
                                                    coordinatesb,
                                                    coordinatesa,
                                                    coordinatesb,
                                                    args[1]
                                                ),
                                                2500
                                            ).then(
                                                (a) => {
                                                    player.sendMessageB(
                                                        `${a.return == 0n
                                                            ? "§c"
                                                            : ""}${a.return} blocks replaced`
                                                    );
                                                },
                                                (e) => {
                                                    player.sendError(
                                                        "§c" + e + e.stack,
                                                        true
                                                    );
                                                }
                                            );
                                        } catch (e) {
                                            player.sendError(
                                                "§c" + e + e.stack,
                                                true
                                            );
                                        } finally {
                                            tac.forEach((tab) => tab?.remove());
                                        }
                                    });
                                } catch (e) {
                                    player.sendError("§c" + e + e.stack, true);
                                }
                            });
                        }
                    }
                }
                break;
            case !!switchTest.match(/^\\stack$/):
                {
                    try {
                        eventData.cancel = true;
                        const args = evaluateParameters(switchTestB, [
                            "presetText",
                            "number",
                        ]).args;
                        const coordinatesa = player.getDynamicProperty(
                            "pos1"
                        ) as Vector3 | undefined;
                        const coordinatesb = player.getDynamicProperty(
                            "pos2"
                        ) as Vector3 | undefined;
                        const ca = {
                            x: Math.min(coordinatesa.x, coordinatesb.x),
                            y: Math.min(coordinatesa.y, coordinatesb.y),
                            z: Math.min(coordinatesa.z, coordinatesb.z),
                        };
                        const cb = {
                            x: Math.max(coordinatesa.x, coordinatesb.x),
                            y: Math.max(coordinatesa.y, coordinatesb.y),
                            z: Math.max(coordinatesa.z, coordinatesb.z),
                        };
                        const height = Math.abs(coordinatesa.y - coordinatesb.y) + 1;
                        //console.warn(vTStr(ca), vTStr(cb))
                        const dimensiona = world.getDimension(
                            (player.getDynamicProperty("posD") ??
                                player.dimension.id) as string
                        ) as Dimension | undefined;
                        if (!!!coordinatesa) {
                            player.sendMessageB("§cError: pos1 is not set.");
                        } else {
                            if (!!!coordinatesb) {
                                player.sendMessageB(
                                    "§cError: pos2 is not set."
                                );
                            } else {
                                system.run(() => {
                                    let ta: Entity[];
                                    try {
                                        generateTickingAreaFillCoordinatesC(
                                            player.location,
                                            (() => {
                                                let a = new CompoundBlockVolume();
                                                a.pushVolume({
                                                    volume: new BlockVolume(
                                                        ca,
                                                        cb
                                                    ),
                                                });
                                                return a;
                                            })(),
                                            player.dimension
                                        ).then((tac) => {
                                            ta = tac;
                                            try {
                                                try {
                                                    undoClipboard.save(
                                                        dimensiona,
                                                        {
                                                            from: ca,
                                                            to: Vector.add(cb, {
                                                                x: 0,
                                                                y: height *
                                                                    args[1],
                                                                z: 0,
                                                            }),
                                                        },
                                                        Date.now(),
                                                        {
                                                            includeBlocks: true,
                                                            includeEntities: false,
                                                            saveMode: config.undoClipboardMode,
                                                        }
                                                    );
                                                } catch (e) {
                                                    player.sendMessageB(
                                                        "§c" + e + " " + e.stack
                                                    );
                                                }
                                                for (let i = 0; i < args[1]; i++) {
                                                    //console.warn(`/clone ${vTStr(ca)} ${vTStr(cb)} ${vTStr({x: ca.x, y: ca.y+(height*(i+1)), z: ca.z})}`)
                                                    dimensiona.runCommand(
                                                        `/clone ${vTStr(
                                                            ca
                                                        )} ${vTStr(cb)} ${vTStr(
                                                            {
                                                                x: ca.x,
                                                                y: ca.y +
                                                                    height *
                                                                    (i + 1),
                                                                z: ca.z,
                                                            }
                                                        )}`
                                                    );
                                                }
                                            } catch (e) {
                                                player.sendError(
                                                    "§c" + e + e.stack,
                                                    true
                                                );
                                            } finally {
                                                tac.forEach((tab) => tab?.remove()
                                                );
                                            }
                                        });
                                    } catch (e) {
                                        player.sendError(
                                            "§c" + e + e.stack,
                                            true
                                        );
                                    }
                                });
                            }
                        }
                    } catch (e) {
                        perror(player, e);
                    }
                }
                break;
            case !!switchTest.match(/^\\cut$/):
                {
                    try {
                        eventData.cancel = true;
                        const args = evaluateParameters(switchTestB, [
                            "presetText",
                            "-meb",
                        ]).args as [string, string];
                        args[1] ??= "";
                        const coordinatesa = player.getDynamicProperty(
                            "pos1"
                        ) as Vector3 | undefined;
                        const coordinatesb = player.getDynamicProperty(
                            "pos2"
                        ) as Vector3 | undefined;
                        const ca = {
                            x: Math.min(coordinatesa.x, coordinatesb.x),
                            y: Math.min(coordinatesa.y, coordinatesb.y),
                            z: Math.min(coordinatesa.z, coordinatesb.z),
                        };
                        const cb = {
                            x: Math.max(coordinatesa.x, coordinatesb.x),
                            y: Math.max(coordinatesa.y, coordinatesb.y),
                            z: Math.max(coordinatesa.z, coordinatesb.z),
                        };
                        const dimensiona = world.getDimension(
                            (player.getDynamicProperty("posD") ??
                                player.dimension.id) as string
                        ) as Dimension | undefined;
                        if (!!!coordinatesa) {
                            player.sendMessageB("§cError: pos1 is not set.");
                        } else {
                            if (!!!coordinatesb) {
                                player.sendMessageB(
                                    "§cError: pos2 is not set."
                                );
                            } else {
                                system.run(() => {
                                    try {
                                        undoClipboard.save(
                                            dimensiona,
                                            { from: ca, to: cb },
                                            Date.now(),
                                            {
                                                includeBlocks: true,
                                                includeEntities: false,
                                                saveMode: config.undoClipboardMode,
                                            }
                                        );
                                    } catch (e) {
                                        player.sendMessageB(
                                            "§c" + e + " " + e.stack
                                        );
                                    }
                                    tryrun(() => blockClipboard.clear());
                                    try {
                                        blockClipboard.save(
                                            dimensiona,
                                            { from: ca, to: cb },
                                            {
                                                includeBlocks: !args[1].includes("b"),
                                                includeEntities: !args[1].includes("e"),
                                                saveMode: args[1].includes("m")
                                                    ? StructureSaveMode.Memory
                                                    : StructureSaveMode.World,
                                            }
                                        );
                                        player.sendMessageB(
                                            "The selected area has been cut to the clipboard."
                                        );
                                    } catch (e) {
                                        player.sendMessageB(
                                            "§c" + e + " " + e.stack
                                        );
                                    }
                                    system.run(() => {
                                        let ta: Entity[];
                                        try {
                                            generateTickingAreaFillCoordinatesC(
                                                player.location,
                                                (() => {
                                                    let a = new CompoundBlockVolume();
                                                    a.pushVolume({
                                                        volume: new BlockVolume(
                                                            coordinatesa,
                                                            coordinatesb
                                                        ),
                                                    });
                                                    return a;
                                                })(),
                                                player.dimension
                                            ).then((tac) => {
                                                ta = tac;
                                                try {
                                                    fillBlocksHFG(
                                                        coordinatesa,
                                                        coordinatesb,
                                                        player.dimension,
                                                        "air",
                                                        undefined,
                                                        {
                                                            minMSBetweenYields: 5000,
                                                        },
                                                        undefined,
                                                        true,
                                                        100
                                                    ).then(
                                                        () => undefined,
                                                        (e) => {
                                                            player.sendMessageB(
                                                                "§c" +
                                                                e +
                                                                e.stack
                                                            );
                                                        }
                                                    );
                                                } catch (e) {
                                                    player.sendMessageB(
                                                        "§c" + e + e.stack
                                                    );
                                                } finally {
                                                    tac.forEach((tab) => tab?.remove()
                                                    );
                                                }
                                            });
                                        } catch (e) {
                                            player.sendMessageB(
                                                "§c" + e + e.stack
                                            );
                                        }
                                    });
                                });
                            }
                        }
                    } catch (e) {
                        perror(player, e);
                    }
                }
                break;
            case !!switchTest.match(/^\\copy$/):
                {
                    try {
                        eventData.cancel = true;
                        const args = evaluateParameters(switchTestB, [
                            "presetText",
                            "-meb",
                        ]).args as [string, string];
                        args[1] ??= "";
                        const coordinatesa = player.getDynamicProperty(
                            "pos1"
                        ) as Vector3 | undefined;
                        const coordinatesb = player.getDynamicProperty(
                            "pos2"
                        ) as Vector3 | undefined;
                        const ca = {
                            x: Math.min(coordinatesa.x, coordinatesb.x),
                            y: Math.min(coordinatesa.y, coordinatesb.y),
                            z: Math.min(coordinatesa.z, coordinatesb.z),
                        };
                        const cb = {
                            x: Math.max(coordinatesa.x, coordinatesb.x),
                            y: Math.max(coordinatesa.y, coordinatesb.y),
                            z: Math.max(coordinatesa.z, coordinatesb.z),
                        };
                        const dimensiona = world.getDimension(
                            (player.getDynamicProperty("posD") ??
                                player.dimension.id) as string
                        ) as Dimension | undefined;
                        if (!!!coordinatesa) {
                            player.sendMessageB("§cError: pos1 is not set.");
                        } else {
                            if (!!!coordinatesb) {
                                player.sendMessageB(
                                    "§cError: pos2 is not set."
                                );
                            } else {
                                system.run(() => {
                                    tryrun(() => blockClipboard.clear());
                                    try {
                                        blockClipboard.save(
                                            dimensiona,
                                            { from: ca, to: cb },
                                            {
                                                includeBlocks: !args[1].includes("b"),
                                                includeEntities: !args[1].includes("e"),
                                                saveMode: args[1].includes("m")
                                                    ? StructureSaveMode.Memory
                                                    : StructureSaveMode.World,
                                            }
                                        );
                                        player.sendMessageB(
                                            "The selected area has been copied to the clipboard."
                                        );
                                    } catch (e) {
                                        player.sendMessageB(
                                            "§c" + e + " " + e.stack
                                        );
                                    }
                                });
                            }
                        }
                    } catch (e) {
                        perror(player, e);
                    }
                }
                break;
            case !!switchTest.match(/^\\paste$/):
                {
                    try {
                        eventData.cancel = true;
                        system.run(() => {
                            try {
                                const args = evaluateParameters(switchTestB, [
                                    "presetText",
                                    "-webxzh",
                                    "number",
                                    "string",
                                    "number",
                                    "string",
                                    "number",
                                ]).args as [
                                        commandText: string,
                                        flags: string,
                                        integrity: number,
                                        integritySeed: string,
                                        rotation: number,
                                        animationMode: "none" | "blocks" | "layers",
                                        animationSeconds: number
                                    ];
                                //console.warn(JSON.stringify(args[1]))
                                args[1] ??= "";
                                args[2] ??= 1;
                                args[3] == "undefined" ||
                                    args[3] == "null" ||
                                    args[3] == "random"
                                    ? (args[3] = undefined)
                                    : undefined;
                                args[4] ??= 0;
                                args[5] ??= "none";
                                args[5] = args[5].toLowerCase() as "none" |
                                    "blocks" |
                                    "layers";
                                args[6] ??= 0;
                                const coordinatesa = args[1].includes("h")
                                    ? player.location
                                    : (player.getDynamicProperty("pos1") as Vector3 |
                                        undefined);
                                const coordinatesb = args[1].includes("h")
                                    ? player.location
                                    : (player.getDynamicProperty("pos2") as Vector3 |
                                        undefined);
                                const ca = {
                                    x: Math.min(coordinatesa.x, coordinatesb.x),
                                    y: Math.min(coordinatesa.y, coordinatesb.y),
                                    z: Math.min(coordinatesa.z, coordinatesb.z),
                                };
                                //const cb = {x: Math.max(coordinatesa.x, coordinatesb.x), y: Math.max(coordinatesa.y, coordinatesb.y), z: Math.max(coordinatesa.z, coordinatesb.z)}
                                const dimensiona = world.getDimension(
                                    (player.getDynamicProperty("posD") ??
                                        player.dimension.id) as string
                                ) as Dimension | undefined;
                                if (!!!coordinatesa) {
                                    player.sendMessageB(
                                        "§cError: pos1 is not set."
                                    );
                                } else if (!!!coordinatesb) {
                                    player.sendMessageB(
                                        "§cError: pos2 is not set."
                                    );
                                } else if (blockClipboard.ids.length == 0) {
                                    player.sendMessageB(
                                        "§cError: The clipboard is currently empty."
                                    );
                                } else {
                                    try {
                                        try {
                                            undoClipboard.save(
                                                dimensiona,
                                                {
                                                    from: ca,
                                                    to: Vector.add(
                                                        ca,
                                                        blockClipboard.saveSize
                                                    ),
                                                },
                                                Date.now(),
                                                {
                                                    includeBlocks: true,
                                                    includeEntities: false,
                                                    saveMode: config.undoClipboardMode,
                                                }
                                            );
                                        } catch (e) {
                                            player.sendMessageB(
                                                "§c" + e + " " + e.stack
                                            );
                                        }
                                        blockClipboard.place(
                                            Object.assign(
                                                { dimension: dimensiona },
                                                ca
                                            ),
                                            {
                                                includeBlocks: !args[1].includes("b"),
                                                includeEntities: !args[1].includes("e"),
                                                waterlogged: args[1].includes("w"),
                                                animationMode: args[5] == "blocks"
                                                    ? StructureAnimationMode.Blocks
                                                    : args[5] == "none"
                                                        ? StructureAnimationMode.None
                                                        : args[5] == "layers"
                                                            ? StructureAnimationMode.Layers
                                                            : undefined,
                                                animationSeconds: args[6],
                                                mirror: args[1].includes("x")
                                                    ? args[1].includes("z")
                                                        ? StructureMirrorAxis.XZ
                                                        : StructureMirrorAxis.X
                                                    : args[1].includes("z")
                                                        ? StructureMirrorAxis.Z
                                                        : StructureMirrorAxis.None,
                                                rotation: Math.round(args[4] / 90) ==
                                                    0
                                                    ? StructureRotation.None
                                                    : Math.round(
                                                        args[4] / 90
                                                    ) == 1
                                                        ? StructureRotation.Rotate90
                                                        : Math.round(
                                                            args[4] / 90
                                                        ) == 2
                                                            ? StructureRotation.Rotate180
                                                            : Math.round(
                                                                args[4] / 90
                                                            ) == 3
                                                                ? StructureRotation.Rotate270
                                                                : StructureRotation.None,
                                                integrity: args[2],
                                                integritySeed: args[3],
                                            }
                                        );
                                        player.sendMessageB(
                                            "The clipboard has been pasted to the selected area."
                                        );
                                    } catch (e) {
                                        player.sendError(
                                            e + " " + e.stack,
                                            true
                                        );
                                    }
                                }
                            } catch (e) {
                                perror(player, e);
                            }
                        });
                    } catch (e) {
                        perror(player, e);
                    }
                }
                break;
            case !!switchTest.match(/^\\undo$/):
                {
                    try {
                        eventData.cancel = true;
                        const args = evaluateParameters(switchTestB, [
                            "presetText",
                            "f-kt",
                        ]).args;
                        system.run(() => {
                            try {
                                if (undoClipboard.ids.length == 0) {
                                    player.sendMessageB("§cNothing to undo.");
                                } else if (!(args[1]?.t ?? false)) {
                                    try {
                                        if (undoClipboard.undo(
                                            undefined,
                                            undefined,
                                            !(args[1]?.k ?? false)
                                        ) == 0) {
                                            player.sendMessageB(
                                                "§cNothing to undo."
                                            );
                                        } else {
                                            player.sendMessageB(
                                                "Successfully reverted the area."
                                            );
                                        }
                                    } catch (e) {
                                        player.sendError(
                                            e + " " + e.stack,
                                            true
                                        );
                                    }
                                } else {
                                    let ta: Entity[];
                                    try {
                                        generateTickingAreaFillCoordinatesC(
                                            player.location,
                                            (() => {
                                                let a = new CompoundBlockVolume();
                                                a.pushVolume({
                                                    volume: new BlockVolume(
                                                        world.getDynamicProperty(
                                                            `andexdb:undoclipboard;${undoClipboard.newestSaveTime}`
                                                        ) as Vector3,
                                                        Vector.add(
                                                            world.getDynamicProperty(
                                                                `andexdb:undoclipboard;${undoClipboard.newestSaveTime}`
                                                            ) as Vector3,
                                                            undoClipboard.saveSize(
                                                                undoClipboard.newestSaveTime
                                                            )
                                                        )
                                                    ),
                                                });
                                                return a;
                                            })(),
                                            dimensionsb[String(
                                                world.getDynamicProperty(
                                                    `andexdb:undoclipboardd;${undoClipboard.newestSaveTime}`
                                                )
                                            )] ??
                                            dimensionsb["minecraft:overworld"]
                                        ).then((tac) => {
                                            ta = tac;
                                            try {
                                                if (undoClipboard.undo(
                                                    undefined,
                                                    undefined,
                                                    !(args[1]?.k ?? false)
                                                ) == 0) {
                                                    player.sendMessageB(
                                                        "§cNothing to undo. "
                                                    );
                                                } else {
                                                    player.sendMessageB(
                                                        "Successfully reverted the area. "
                                                    );
                                                }
                                            } catch (e) {
                                                player.sendError(
                                                    e + " " + e.stack,
                                                    true
                                                );
                                            } finally {
                                                tac.forEach((tab) => tab?.remove()
                                                );
                                            }
                                        });
                                    } catch (e) {
                                        player.sendError(
                                            "§c" + e + e.stack,
                                            true
                                        );
                                    }
                                }
                            } catch (e) {
                                perror(player, e);
                            }
                        });
                    } catch (e) {
                        perror(player, e);
                    }
                }
                break;
            case !!switchTest.match(/^\\protectarea$/):
                {
                    try {
                        eventData.cancel = true;
                        system.run(() => {
                            try {
                                const args = evaluateParameters(switchTestB, [
                                    "presetText",
                                    "string",
                                    "string",
                                    "number",
                                    "string",
                                ]).args as [
                                        commandText: string,
                                        areaType: string,
                                        name: string,
                                        mode: number,
                                        icon_path: string
                                    ];
                                if (!spawnProtectionTypeList.includes(args[1])) {
                                    player.sendError(
                                        `§cError: "${args[1]}" is not a valid protected area type, please use one of the following protected area types: ${JSON.stringify(
                                            spawnProtectionTypeList
                                        )}.`,
                                        true
                                    );
                                    return;
                                }
                                const coordinatesa = player.getDynamicProperty(
                                    "pos1"
                                ) as Vector3 | undefined;
                                const coordinatesb = player.getDynamicProperty(
                                    "pos2"
                                ) as Vector3 | undefined;
                                const ca = {
                                    x: Math.min(coordinatesa.x, coordinatesb.x),
                                    y: Math.min(coordinatesa.y, coordinatesb.y),
                                    z: Math.min(coordinatesa.z, coordinatesb.z),
                                };
                                const cb = {
                                    x: Math.max(coordinatesa.x, coordinatesb.x),
                                    y: Math.max(coordinatesa.y, coordinatesb.y),
                                    z: Math.max(coordinatesa.z, coordinatesb.z),
                                };
                                const dimensiona = world.getDimension(
                                    (player.getDynamicProperty("posD") ??
                                        player.dimension.id) as string
                                ) as Dimension | undefined;
                                if (!!!coordinatesa) {
                                    player.sendMessageB(
                                        "§cError: pos1 is not set."
                                    );
                                } else if (!!!coordinatesb) {
                                    player.sendMessageB(
                                        "§cError: pos2 is not set."
                                    );
                                } else {
                                    world.setDynamicProperty(
                                        "v2:" + args[1] + args[2],
                                        JSON.stringify({
                                            from: ca,
                                            to: cb,
                                            dimension: dimensions.indexOf(dimensiona),
                                            mode: args[3] ?? 0,
                                            icon_path: args[4],
                                        })
                                    );
                                    player.sendMessageB(
                                        "The protected area has been saved."
                                    );
                                }
                            } catch (e) {
                                perror(player, e);
                            }
                        });
                    } catch (e) {
                        perror(player, e);
                    }
                }
                break;
            case !!switchTest.match(/^\\backuparea$/):
                {
                    try {
                        eventData.cancel = true;
                        system.run(() => {
                            try {
                                const args = evaluateParameters(switchTestB, [
                                    "presetText",
                                    "string",
                                ]).args as [commandText: string, id: string];
                                const coordinatesa = player.getDynamicProperty(
                                    "pos1"
                                ) as Vector3 | undefined;
                                const coordinatesb = player.getDynamicProperty(
                                    "pos2"
                                ) as Vector3 | undefined;
                                const ca = {
                                    x: Math.min(coordinatesa.x, coordinatesb.x),
                                    y: Math.min(coordinatesa.y, coordinatesb.y),
                                    z: Math.min(coordinatesa.z, coordinatesb.z),
                                };
                                const cb = {
                                    x: Math.max(coordinatesa.x, coordinatesb.x),
                                    y: Math.max(coordinatesa.y, coordinatesb.y),
                                    z: Math.max(coordinatesa.z, coordinatesb.z),
                                };
                                const dimensiona = world.getDimension(
                                    (player.getDynamicProperty("posD") ??
                                        player.dimension.id) as string
                                ) as Dimension | undefined;
                                if (!!!coordinatesa) {
                                    player.sendMessageB(
                                        "§cError: pos1 is not set."
                                    );
                                } else if (!!!coordinatesb) {
                                    player.sendMessageB(
                                        "§cError: pos2 is not set."
                                    );
                                } else {
                                    AreaBackups.createAreaBackup(
                                        args[1],
                                        dimensiona,
                                        { from: ca, to: cb }
                                    );
                                    player.sendMessageB(
                                        `The backup area has been created with the id "${args[1]}".`
                                    );
                                }
                            } catch (e) {
                                perror(player, e);
                            }
                        });
                    } catch (e) {
                        perror(player, e);
                    }
                }
                break;
            case !!switchTest.match(/^\\itfill$/):
                {
                    eventData.cancel = true;
                    eventData.cancel = true;
                    if (switchTestB.trim().split(" ").length == 1) {
                        player.sendMessageB(`itfill command format: 
${command.dp}\\itfill <tileName: Block> <blockStates: block states> <ifillMode: replace|fill|cube|keep|walls|hollow|outline|pillars§c|floor|ceilling|diamond|hourglass§r> <replaceTileName: Block> [replaceBlockStates: block states] [clearContainers: boolean]
${command.dp}\\itfill <tileName: Block> <blockStates: block states> <ifillMode: replace|fill|cube|keep|walls|hollow|outline|pillars§c|floor|ceilling|diamond|hourglass§r> <reaplceTileName: Block> [clearContainers: boolean]
${command.dp}\\itfill <tileName: Block> <blockStates: block states> [ifillMode: replace|fill|cube|keep|walls|hollow|outline|pillars§c|floor|ceilling|diamond|hourglass§r] [clearContainers: boolean]
${command.dp}\\itfill <tileName: Block> <blockStates: block states> [clearContainers: boolean]
${command.dp}\\itfill <tileName: Block> <ifillMode: replace|fill|cube|keep|walls|hollow|outline|pillars§c|floor|ceilling|diamond|hourglass§r> <replaceTileName: Block> [replaceBlockStates: block states] [clearContainers: boolean]
${command.dp}\\itfill <tileName: Block> <ifillMode: replace|fill|cube|keep|walls|hollow|outline|pillars§c|floor|ceilling|diamond|hourglass§r> <reaplceTileName: Block> [clearContainers: boolean]
${command.dp}\\itfill <tileName: Block> [ifillMode: replace|fill|cube|keep|walls|hollow|outline|pillars§c|floor|ceilling|diamond|hourglass§r] [clearContainers: boolean]
${command.dp}\\itfill <tileName: Block> [clearContainers: boolean]
${command.dp}\\itfill <skygridSize: float> <tileName: Block> <blockStates: block states> <mode: skygrid|inverseskygrid> <replaceTileName: Block> [replaceBlockStates: block states] [clearContainers: boolean]
${command.dp}\\itfill <skygridSize: float> <tileName: Block> <blockStates: block states> <mode: skygrid|inverseskygrid> <reaplceTileName: Block> [clearContainers: boolean]
${command.dp}\\itfill <skygridSize: float> <tileName: Block> <blockStates: block states> <mode: skygrid|inverseskygrid> [clearContainers: boolean]
${command.dp}\\itfill <skygridSize: float> <tileName: Block> <blockStates: block states> <mode: skygrid|inverseskygrid> [clearContainers: boolean]
${command.dp}\\itfill <skygridSize: float> <tileName: Block> <mode: skygrid|inverseskygrid> <replaceTileName: Block> [replaceBlockStates: block states] [clearContainers: boolean]
${command.dp}\\itfill <skygridSize: float> <tileName: Block> <mode: skygrid|inverseskygrid> <reaplceTileName: Block> [clearContainers: boolean]
${command.dp}\\itfill <skygridSize: float> <tileName: Block> <mode: skygrid|inverseskygrid> [clearContainers: boolean]
${command.dp}\\itfill <tileName: Block> [clearContainers: boolean]
${command.dp}\\itfill clear [clearContainers: boolean]
${command.dp}\\itfill drain
${command.dp}\\itfill <axis: {x}|{y}|{z}|{xy}|{yz}|{xz}|{xyz}> <tileName: Block> <blockStates: block states> circle [replaceTileName: Block] [replaceBlockStates: block states] [clearContainers: boolean]
${command.dp}\\itfill <axis: {x}|{y}|{z}|{xy}|{yz}|{xz}|{xyz}> <tileName: Block> <blockStates: block states> circle [replaceTileName: Block] [clearContainers: boolean]
${command.dp}\\itfill <axis: {x}|{y}|{z}|{xy}|{yz}|{xz}|{xyz}> <tileName: Block> <blockStates: block states> circle [clearContainers: boolean]
${command.dp}\\itfill <axis: {x}|{y}|{z}|{xy}|{yz}|{xz}|{xyz}> <tileName: Block> circle [replaceTileName: Block] [replaceBlockStates: block states] [clearContainers: boolean]
${command.dp}\\itfill <axis: {x}|{y}|{z}|{xy}|{yz}|{xz}|{xyz}> <tileName: Block> circle [replaceTileName: Block] [clearContainers: boolean]
${command.dp}\\itfill <axis: {x}|{y}|{z}|{xy}|{yz}|{xz}|{xyz}> <tileName: Block> circle [clearContainers: boolean]
${command.dp}\\itfill <tileName: Block> <blockStates: block states> <mode: {circlex}|{circley}|{circlez}|{circlexy}|{circleyz}|{circlexyz}|{sphere}|{semisphere}> <replaceTileName: Block> [replaceBlockStates: block states] [clearContainers: boolean]
${command.dp}\\itfill <tileName: Block> <blockStates: block states> <mode: {circlex}|{circley}|{circlez}|{circlexy}|{circleyz}|{circlexyz}|{sphere}|{semisphere}> <replaceTileName: Block> [clearContainers: boolean]
${command.dp}\\itfill <tileName: Block> <blockStates: block states> <mode: {circlex}|{circley}|{circlez}|{circlexy}|{circleyz}|{circlexyz}|{sphere}|{semisphere}> [clearContainers: boolean]
${command.dp}\\itfill <tileName: Block> <mode: {circlex}|{circley}|{circlez}|{circlexy}|{circleyz}|{circlexyz}|{sphere}|{semisphere}> <replaceTileName: Block> [replaceBlockStates: block states] [clearContainers: boolean]
${command.dp}\\itfill <tileName: Block> <mode: {circlex}|{circley}|{circlez}|{circlexy}|{circleyz}|{circlexyz}|{sphere}|{semisphere}> <replaceTileName: Block> [clearContainers: boolean]
${command.dp}\\itfill <tileName: Block> <mode: {circlex}|{circley}|{circlez}|{circlexy}|{circleyz}|{circlexyz}|{sphere}|{semisphere}> [clearContainers: boolean]
${command.dp}\\itfill <thickness: float> <tileName: Block> <blockStates: block states> <mode: hollowsphere|dome> <replaceTileName: Block> [replaceBlockStates: block states] [clearContainers: boolean]
${command.dp}\\itfill <thickness: float> <tileName: Block> <blockStates: block states> <mode: hollowsphere|dome> <replaceTileName: Block> [clearContainers: boolean]
${command.dp}\\itfill <thickness: float> <tileName: Block> <blockStates: block states> <mode: hollowsphere|dome> [clearContainers: boolean]
${command.dp}\\itfill <thickness: float> <tileName: Block> <mode: hollowsphere|dome> <replaceTileName: Block> [replaceBlockStates: block states] [clearContainers: boolean]
${command.dp}\\itfill <thickness: float> <tileName: Block> <mode: hollowsphere|dome> <replaceTileName: Block> [clearContainers: boolean]
${command.dp}\\itfill <thickness: float> <tileName: Block> <mode: hollowsphere|dome> [clearContainers: boolean]
${command.dp}\\itfill <length: float> <tileName: Block> <blockStates: block states> <mode: cylinderx|cylindery|cylinderz|cylinderxy|cylinderyz|cylinderxz|cylinderxyz> <replaceTileName: Block> [replaceBlockStates: block states] [clearContainers: boolean]
${command.dp}\\itfill <length: float> <tileName: Block> <blockStates: block states> <mode: cylinderx|cylindery|cylinderz|cylinderxy|cylinderyz|cylinderxz|cylinderxyz> <replaceTileName: Block> [clearContainers: boolean]
${command.dp}\\itfill <length: float> <tileName: Block> <blockStates: block states> <mode: cylinderx|cylindery|cylinderz|cylinderxy|cylinderyz|cylinderxz|cylinderxyz> [clearContainers: boolean]
${command.dp}\\itfill <length: float> <tileName: Block> <mode: cylinderx|cylindery|cylinderz|cylinderxy|cylinderyz|cylinderxz|cylinderxyz> <replaceTileName: Block> [replaceBlockStates: block states] [clearContainers: boolean]
${command.dp}\\itfill <length: float> <tileName: Block> <mode: cylinderx|cylindery|cylinderz|cylinderxy|cylinderyz|cylinderxz|cylinderxyz> <replaceTileName: Block> [clearContainers: boolean]
${command.dp}\\itfill <length: float> <tileName: Block> <mode: cylinderx|cylindery|cylinderz|cylinderxy|cylinderyz|cylinderxz|cylinderxyz> [clearContainers: boolean]
${command.dp}\\itfill <length: float> <axis: {x}|{y}|{z}|{xy}|{yz}|{xz}|{xyz}> <tileName: Block> <blockStates: block states> <mode: tunnel|cylinder> [replaceTileName: Block] [replaceBlockStates: block states] [clearContainers: boolean]
${command.dp}\\itfill <length: float> <axis: {x}|{y}|{z}|{xy}|{yz}|{xz}|{xyz}> <tileName: Block> <blockStates: block states> <mode: tunnel|cylinder> [replaceTileName: Block] [clearContainers: boolean]
${command.dp}\\itfill <length: float> <axis: {x}|{y}|{z}|{xy}|{yz}|{xz}|{xyz}> <tileName: Block> <blockStates: block states> <mode: tunnel|cylinder> [clearContainers: boolean]
${command.dp}\\itfill <length: float> <axis: {x}|{y}|{z}|{xy}|{yz}|{xz}|{xyz}> <tileName: Block> <mode: tunnel|cylinder> [replaceTileName: Block] [replaceBlockStates: block states] [clearContainers: boolean]
${command.dp}\\itfill <length: float> <axis: {x}|{y}|{z}|{xy}|{yz}|{xz}|{xyz}> <tileName: Block> <mode: tunnel|cylinder> [replaceTileName: Block] [clearContainers: boolean]
${command.dp}\\itfill <length: float> <axis: {x}|{y}|{z}|{xy}|{yz}|{xz}|{xyz}> <tileName: Block> <mode: tunnel|cylinder> [clearContainers: boolean]
${command.dp}\\itfill <offsetx: float> <offsety: float> <offsetz: float> <thickness: float> <tileName: Block> <blockStates: block states> hollowovoid [replaceTileName: Block] [replaceBlockStates: block states] [clearContainers: boolean]
${command.dp}\\itfill <offsetx: float> <offsety: float> <offsetz: float> <thickness: float> <tileName: Block> <blockStates: block states> hollowovoid [replaceTileName: Block] [clearContainers: boolean]
${command.dp}\\itfill <offsetx: float> <offsety: float> <offsetz: float> <thickness: float> <tileName: Block> <blockStates: block states> hollowovoid [clearContainers: boolean]
${command.dp}\\itfill <offsetx: float> <offsety: float> <offsetz: float> <thickness: float> <tileName: Block> hollowovoid [replaceTileName: Block] [replaceBlockStates: block states] [clearContainers: boolean]
${command.dp}\\itfill <offsetx: float> <offsety: float> <offsetz: float> <thickness: float> <tileName: Block> hollowovoid [replaceTileName: Block] [clearContainers: boolean]
${command.dp}\\itfill <offsetx: float> <offsety: float> <offsetz: float> <thickness: float> <tileName: Block> hollowovoid [clearContainers: boolean]`);
                    } else {
                        let argsa = evaluateParameters(switchTestB, [
                            "presetText",
                            "string",
                            "blockStates",
                            "presetText",
                            "non-booleanString",
                            "blockStates",
                            "neboolean",
                        ]);
                        let argsb = evaluateParameters(switchTestB, [
                            "presetText",
                            "string",
                            "presetText",
                            "blockStates",
                            "presetText",
                            "non-booleanString",
                            "blockStates",
                            "neboolean",
                        ]);
                        let argsd = evaluateParameters(switchTestB, [
                            "presetText",
                            "string",
                            "blockStates",
                            "presetText",
                            "non-booleanString",
                            "blockStates",
                            "neboolean",
                        ]);
                        let argsf = evaluateParameters(switchTestB, [
                            "presetText",
                            "number",
                            "string",
                            "blockStates",
                            "presetText",
                            "non-booleanString",
                            "blockStates",
                            "neboolean",
                        ]);
                        let argsh = evaluateParameters(switchTestB, [
                            "presetText",
                            "number",
                            "string",
                            "string",
                            "blockStates",
                            "presetText",
                            "non-booleanString",
                            "blockStates",
                            "neboolean",
                        ]);
                        let argsj = evaluateParameters(switchTestB, [
                            "presetText",
                            "number",
                            "number",
                            "number",
                            "number",
                            "string",
                            "blockStates",
                            "presetText",
                            "non-booleanString",
                            "blockStates",
                            "neboolean",
                        ]);
                        let argsl = evaluateParameters(switchTestB, [
                            "presetText",
                            "number",
                            "number",
                            "number",
                            "string",
                            "blockStates",
                            "presetText",
                            "non-booleanString",
                            "blockStates",
                            "neboolean",
                        ]);
                        let argsn = evaluateParameters(switchTestB, [
                            "presetText",
                            "number",
                            "string",
                            "blockStates",
                            "presetText",
                            "non-booleanString",
                            "blockStates",
                            "neboolean",
                        ]);
                        //console.warn(argsh.args)
                        let args = argsa.args;
                        let argsc = argsb.args;
                        let argse = argsd.args;
                        let argsg = argsf.args;
                        let argsi = argsh.args;
                        let argsk = argsj.args;
                        let argsm = argsl.args;
                        let argso = argsn.args;
                        let argsaextra = argsa.extra;
                        let argsbextra = argsb.extra;
                        let argsdextra = argsd.extra;
                        let argsfextra = argsf.extra;
                        let argshextra = argsh.extra;
                        let argsjextra = argsj.extra;
                        let argslextra = argsl.extra;
                        let argsnextra = argsn.extra;
                        //console.warn(JSONStringify(args), JSONStringify(argsaextra))
                        let center = player.getDynamicProperty(
                            "pos1"
                        ) as Vector3; //evaluateCoordinates(argsc[1], argsc[2], argsc[3], roundVector3ToMiddleOfBlock(player.location), player.getRotation());
                        let radius = Vector.distance(
                            player.getDynamicProperty("pos1") as Vector3,
                            player.getDynamicProperty("pos2") as Vector3
                        );
                        let axis = argsc[1];
                        let cfirstblockname = argsc[2];
                        let cfirstblockstates = argsc[3];
                        let cmode = argsc[4] as string;
                        let clastblockname = argsc[5];
                        let clastblockstates = argsc[6];
                        let creplacemode = argsc[7] ?? false;
                        let ccfirstblockname = argse[1];
                        let ccfirstblockstates = argse[2];
                        let ccmode = argse[3] as string;
                        let cclastblockname = argse[4];
                        let cclastblockstates = argse[5];
                        let ccreplacemode = argse[6] ?? false;
                        let thickness = argsg[1];
                        let hsfirstblockname = argsg[2];
                        let hsfirstblockstates = argsg[3];
                        let hsmode = argsg[4] as string;
                        let hslastblockname = argsg[5];
                        let hslastblockstates = argsg[6];
                        let hsreplacemode = argsg[7] ?? false;
                        let taxis = argsi[2];
                        let tfirstblockname = argsi[3];
                        let tfirstblockstates = argsi[4];
                        let tmode = argsi[5] as string;
                        let tlastblockname = argsi[6];
                        let tlastblockstates = argsi[7];
                        let treplacemode = argsi[8] ?? false;
                        let sgskygridsize = argso[1];
                        let sgfirstblockname = argso[2];
                        let sgfirstblockstates = argso[3];
                        let sgmode = argso[4] as string;
                        let sglastblockname = argso[5];
                        let sglastblockstates = argso[6];
                        let sgreplacemode = argso[7] ?? false;
                        let circlemode = false;
                        new Date(Date.now()).getMilliseconds();
                        let ccirclemode = false;
                        let hspheremode = false;
                        let tunnelmode = false;
                        let ovoidmode = false;
                        let hovoidmode = false;
                        let skygridmode = false;
                        if (["circle"].includes(
                            fillmodetypeenum[argsc[4] ??
                            "undefined"?.toLowerCase()?.trim()]
                        )) {
                            circlemode = true;
                        }
                        if ([
                            "circlex",
                            "circley",
                            "circlez",
                            "circlexy",
                            "circleyz",
                            "circlexz",
                            "circlexyz",
                            "sphere",
                            "semisphere",
                        ].includes(
                            fillmodetypeenum[argse[3] ??
                            "undefined"?.toLowerCase()?.trim()]
                        )) {
                            ccirclemode = true;
                        }
                        if ([
                            "hollowsphere",
                            "cylinderx",
                            "cylindery",
                            "cylinderz",
                            "cylinderxy",
                            "cylinderyz",
                            "cylinderxz",
                            "cylinderxyz",
                            "dome",
                        ].includes(
                            fillmodetypeenum[argsg[4] ??
                            "undefined"?.toLowerCase()?.trim()]
                        )) {
                            hspheremode = true;
                        }
                        if (["tunnel", "cylinder"].includes(
                            fillmodetypeenum[argsi[5] ??
                            "undefined"?.toLowerCase()?.trim()]
                        )) {
                            tunnelmode = true;
                        }
                        if (["ovoid"].includes(
                            fillmodetypeenum[argsm[6] ??
                            "undefined"?.toLowerCase()?.trim()]
                        )) {
                            ovoidmode = true;
                        }
                        if (["hollowovoid"].includes(
                            fillmodetypeenum[argsk[7] ??
                            "undefined"?.toLowerCase()?.trim()]
                        )) {
                            hovoidmode = true;
                        }
                        if (["skygrid", "inverseskygrid"].includes(
                            fillmodetypeenum[argso[4] ??
                            "undefined"?.toLowerCase()?.trim()]
                        )) {
                            skygridmode = true;
                        }
                        let coordinatesa: Vector3; /*
            console.warn(circlemode, ccirclemode, hspheremode)*/

                        if (!circlemode &&
                            !ccirclemode &&
                            !hspheremode &&
                            !tunnelmode) {
                            coordinatesa = player.getDynamicProperty(
                                "pos1"
                            ) as Vector3; /*evaluateCoordinates(args[1], args[2], args[3], roundVector3ToMiddleOfBlock(player.location), player.getRotation()); */
                        }
                        let coordinatesb: Vector3;
                        if (!circlemode &&
                            !ccirclemode &&
                            !hspheremode &&
                            !tunnelmode) {
                            coordinatesb = player.getDynamicProperty(
                                "pos2"
                            ) as Vector3; /*evaluateCoordinates(args[4], args[5], args[6], roundVector3ToMiddleOfBlock(player.location), player.getRotation()); */
                        }
                        let horadi: Vector3;
                        let hooffset: Vector3;
                        let hothickness = argsk[4];
                        let hofirstblockname = argsk[5];
                        let hofirstblockstates = argsk[6];
                        let homode = argsk[7] as string;
                        let holastblockname = argsk[8];
                        let holastblockstates = argsk[9];
                        let horeplacemode = argsk[10] ?? false;
                        if (hovoidmode) {
                            const oradia = Vector.subtract(
                                player.getDynamicProperty("pos1") as Vector3,
                                player.getDynamicProperty("pos2") as Vector3
                            );
                            horadi = {
                                x: Math.abs(oradia.x),
                                y: Math.abs(oradia.y),
                                z: Math.abs(oradia.z),
                            };
                            hooffset = Vector.add(
                                { x: argsk[1], y: argsk[2], z: argsk[3] },
                                center
                            );
                        }
                        let oradi: Vector3;
                        let ooffset: Vector3;
                        let ofirstblockname = argsm[4];
                        let ofirstblockstates = argsm[5];
                        let omode = argsm[6] as string;
                        let olastblockname = argsm[7];
                        let olastblockstates = argsm[8];
                        let oreplacemode = argsm[9] ?? false;
                        if (ovoidmode) {
                            const oradia = Vector.subtract(
                                player.getDynamicProperty("pos1") as Vector3,
                                player.getDynamicProperty("pos2") as Vector3
                            );
                            oradi = {
                                x: Math.abs(oradia.x),
                                y: Math.abs(oradia.y),
                                z: Math.abs(oradia.z),
                            };
                            ooffset = Vector.add(
                                { x: argsm[1], y: argsm[2], z: argsm[3] },
                                center
                            );
                        }
                        let firstblockname = args[1];
                        let firstblockstates = args[2];
                        let mode = args[3] as string;
                        let lastblockname = args[4];
                        let lastblockstates = args[5];
                        let replacemode = args[6] ?? false;
                        let matchingblock: [
                            string,
                            { [id: string]: string | number | boolean; }?
                        ] = (lastblockname ?? "") == ""
                                ? [undefined, undefined]
                                : lastblockname == "keep" || mode == "keep"
                                    ? ["air"]
                                    : [
                                        BlockTypes.get(lastblockname).id,
                                        lastblockstates,
                                    ];
                        let cmatchingblock: [
                            string,
                            { [id: string]: string | number | boolean; }?
                        ] = (clastblockname ?? "") == ""
                                ? [undefined, undefined]
                                : clastblockname == "keep"
                                    ? ["air"]
                                    : [clastblockname, clastblockstates];
                        let ccmatchingblock: [
                            string,
                            { [id: string]: string | number | boolean; }?
                        ] = (cclastblockname ?? "") == ""
                                ? [undefined, undefined]
                                : cclastblockname == "keep"
                                    ? ["air"]
                                    : [cclastblockname, cclastblockstates];
                        let hsmatchingblock: [
                            string,
                            { [id: string]: string | number | boolean; }?
                        ] = (hslastblockname ?? "") == ""
                                ? [undefined, undefined]
                                : hslastblockname == "keep"
                                    ? ["air"]
                                    : [hslastblockname, hslastblockstates];
                        let tmatchingblock: [
                            string,
                            { [id: string]: string | number | boolean; }?
                        ] = (tlastblockname ?? "") == ""
                                ? [undefined, undefined]
                                : tlastblockname == "keep"
                                    ? ["air"]
                                    : [tlastblockname, tlastblockstates];
                        let omatchingblock: [
                            string,
                            { [id: string]: string | number | boolean; }?
                        ] = (olastblockname ?? "") == ""
                                ? [undefined, undefined]
                                : olastblockname == "keep"
                                    ? ["air"]
                                    : [olastblockname, olastblockstates];
                        let homatchingblock: [
                            string,
                            { [id: string]: string | number | boolean; }?
                        ] = (holastblockname ?? "") == ""
                                ? [undefined, undefined]
                                : holastblockname == "keep"
                                    ? ["air"]
                                    : [holastblockname, holastblockstates];
                        let sgmatchingblock: [
                            string,
                            { [id: string]: string | number | boolean; }?
                        ] = (sglastblockname ?? "") == ""
                                ? [undefined, undefined]
                                : sglastblockname == "keep"
                                    ? ["air"]
                                    : [sglastblockname, sglastblockstates]; /*
    console.warn(JSONStringify({coordinatesa, coordinatesb, firstblockname, firstblocknameindex, reststringaftercoordinates, firstblockstates, lastblockname, somethingtest, lastblockstates, matchingblock}))*/

                        switch (fillmodetypeenum[skygridmode
                            ? sgmode
                            : hovoidmode
                                ? homode
                                : ovoidmode
                                    ? omode
                                    : tunnelmode
                                        ? tmode
                                        : hspheremode
                                            ? hsmode
                                            : circlemode
                                                ? cmode
                                                : ccirclemode
                                                    ? ccmode
                                                    : mode ?? ""]) {
                            case "":
                                system.run(() => {
                                    let ta: Entity;
                                    try {
                                        let location = {
                                            x: (coordinatesa.x +
                                                coordinatesb.x) /
                                                2,
                                            y: (coordinatesa.y +
                                                coordinatesb.y) /
                                                2,
                                            z: (coordinatesa.z +
                                                coordinatesb.z) /
                                                2,
                                        };
                                        player.dimension.runCommand(
                                            "summon andexdb:tickingarea_6 itwalls " +
                                            vTStr(location)
                                        );
                                        ta = player.dimension
                                            .getEntitiesAtBlockLocation(
                                                location
                                            )
                                            .find(
                                                (v) => v.typeId ==
                                                    "andexdb:tickingarea_6"
                                            );
                                        system.runTimeout(() => {
                                            try {
                                                let startTime = Date.now();
                                                if (replacemode) {
                                                    clearAllContainerBlocks(
                                                        scanForContainerBlocks(
                                                            coordinatesa,
                                                            coordinatesb,
                                                            player.dimension,
                                                            "Block"
                                                        ) as Block[]
                                                    );
                                                }
                                                let a = fillBlocksH(
                                                    coordinatesa,
                                                    coordinatesb,
                                                    player.dimension,
                                                    firstblockname,
                                                    firstblockstates,
                                                    {
                                                        matchingBlock: matchingblock[0],
                                                        matchingBlockStates: matchingblock[1],
                                                    }
                                                );
                                                let endTime = Date.now();
                                                player.sendMessageB(
                                                    `${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`
                                                );
                                            } catch (e) {
                                                player.sendError(
                                                    "§c" + e + e.stack,
                                                    true
                                                );
                                            } finally {
                                                ta?.remove();
                                            }
                                        }, 2);
                                    } catch (e) {
                                        player.sendError(
                                            "§c" + e + e.stack,
                                            true
                                        );
                                    }
                                });
                                break;
                            case "replace":
                                system.run(() => {
                                    let ta: Entity;
                                    try {
                                        let location = {
                                            x: (coordinatesa.x +
                                                coordinatesb.x) /
                                                2,
                                            y: (coordinatesa.y +
                                                coordinatesb.y) /
                                                2,
                                            z: (coordinatesa.z +
                                                coordinatesb.z) /
                                                2,
                                        };
                                        player.dimension.runCommand(
                                            "summon andexdb:tickingarea_6 itwalls " +
                                            vTStr(location)
                                        );
                                        ta = player.dimension
                                            .getEntitiesAtBlockLocation(
                                                location
                                            )
                                            .find(
                                                (v) => v.typeId ==
                                                    "andexdb:tickingarea_6"
                                            );
                                        system.runTimeout(() => {
                                            try {
                                                let startTime = Date.now();
                                                if (replacemode) {
                                                    clearAllContainerBlocks(
                                                        scanForContainerBlocks(
                                                            coordinatesa,
                                                            coordinatesb,
                                                            player.dimension,
                                                            "Block"
                                                        ) as Block[]
                                                    );
                                                }
                                                let a = fillBlocksH(
                                                    coordinatesa,
                                                    coordinatesb,
                                                    player.dimension,
                                                    firstblockname,
                                                    firstblockstates,
                                                    {
                                                        matchingBlock: matchingblock[0],
                                                        matchingBlockStates: matchingblock[1],
                                                    }
                                                );
                                                let endTime = Date.now();
                                                player.sendMessageB(
                                                    `${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`
                                                );
                                            } catch (e) {
                                                player.sendError(
                                                    "§c" + e + e.stack,
                                                    true
                                                );
                                            } finally {
                                                ta?.remove();
                                            }
                                        }, 2);
                                    } catch (e) {
                                        player.sendError(
                                            "§c" + e + e.stack,
                                            true
                                        );
                                    }
                                });
                                break;
                            case "clear":
                                system.run(() => {
                                    let ta: Entity[];
                                    try {
                                        generateTickingAreaFillCoordinatesC(
                                            player.location,
                                            (() => {
                                                let a = new CompoundBlockVolume();
                                                a.pushVolume({
                                                    volume: new BlockVolume(
                                                        coordinatesa,
                                                        coordinatesb
                                                    ),
                                                });
                                                return a;
                                            })(),
                                            player.dimension
                                        ).then((tac) => {
                                            ta = tac;
                                            try {
                                                let startTime = Date.now();
                                                if (replacemode) {
                                                    clearAllContainerBlocks(
                                                        scanForContainerBlocks(
                                                            coordinatesa,
                                                            coordinatesb,
                                                            player.dimension,
                                                            "Block"
                                                        ) as Block[]
                                                    );
                                                }
                                                let a = fillBlocksH(
                                                    coordinatesa,
                                                    coordinatesb,
                                                    player.dimension,
                                                    "air"
                                                );
                                                let endTime = Date.now();
                                                player.sendMessageB(
                                                    `${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`
                                                );
                                            } catch (e) {
                                                player.sendError(
                                                    "§c" + e + e.stack,
                                                    true
                                                );
                                            } finally {
                                                tac.forEach((tab) => tab?.remove()
                                                );
                                            }
                                        });
                                    } catch (e) {
                                        player.sendError(
                                            "§c" + e + e.stack,
                                            true
                                        );
                                    }
                                });
                                break;
                            case "drain":
                                system.run(() => {
                                    let ta: Entity[];
                                    try {
                                        generateTickingAreaFillCoordinatesC(
                                            player.location,
                                            (() => {
                                                let a = new CompoundBlockVolume();
                                                a.pushVolume({
                                                    volume: new BlockVolume(
                                                        coordinatesa,
                                                        coordinatesb
                                                    ),
                                                });
                                                return a;
                                            })(),
                                            player.dimension
                                        ).then((tac) => {
                                            ta = tac;
                                            try {
                                                let startTime = Date.now();
                                                let a = fillBlocksH(
                                                    coordinatesa,
                                                    coordinatesb,
                                                    player.dimension,
                                                    "air",
                                                    undefined,
                                                    { matchingBlock: "water" }
                                                );
                                                let endTime = Date.now();
                                                player.sendMessageB(
                                                    `${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`
                                                );
                                            } catch (e) {
                                                player.sendError(
                                                    "§c" + e + e.stack,
                                                    true
                                                );
                                            } finally {
                                                tac.forEach((tab) => tab?.remove()
                                                );
                                            }
                                        });
                                    } catch (e) {
                                        player.sendError(
                                            "§c" + e + e.stack,
                                            true
                                        );
                                    }
                                });
                                break;
                            case "fill":
                                system.run(() => {
                                    let ta: Entity[];
                                    try {
                                        generateTickingAreaFillCoordinatesC(
                                            player.location,
                                            (() => {
                                                let a = new CompoundBlockVolume();
                                                a.pushVolume({
                                                    volume: new BlockVolume(
                                                        coordinatesa,
                                                        coordinatesb
                                                    ),
                                                });
                                                return a;
                                            })(),
                                            player.dimension
                                        ).then((tac) => {
                                            ta = tac;
                                            try {
                                                let startTime = Date.now();
                                                if (replacemode) {
                                                    clearAllContainerBlocks(
                                                        scanForContainerBlocks(
                                                            coordinatesa,
                                                            coordinatesb,
                                                            player.dimension,
                                                            "Block"
                                                        ) as Block[]
                                                    );
                                                }
                                                let a = fillBlocksH(
                                                    coordinatesa,
                                                    coordinatesb,
                                                    player.dimension,
                                                    firstblockname,
                                                    firstblockstates,
                                                    {
                                                        matchingBlock: matchingblock[0],
                                                        matchingBlockStates: matchingblock[1],
                                                    }
                                                );
                                                let endTime = Date.now();
                                                player.sendMessageB(
                                                    `${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`
                                                );
                                            } catch (e) {
                                                player.sendError(
                                                    "§c" + e + e.stack,
                                                    true
                                                );
                                            } finally {
                                                tac.forEach((tab) => tab?.remove()
                                                );
                                            }
                                        });
                                    } catch (e) {
                                        player.sendError(
                                            "§c" + e + e.stack,
                                            true
                                        );
                                    }
                                });
                                break;
                            case "keep":
                                system.run(() => {
                                    let ta: Entity[];
                                    try {
                                        generateTickingAreaFillCoordinatesC(
                                            player.location,
                                            (() => {
                                                let a = new CompoundBlockVolume();
                                                a.pushVolume({
                                                    volume: new BlockVolume(
                                                        coordinatesa,
                                                        coordinatesb
                                                    ),
                                                });
                                                return a;
                                            })(),
                                            player.dimension
                                        ).then((tac) => {
                                            ta = tac;
                                            try {
                                                let startTime = Date.now();
                                                let a = fillBlocksH(
                                                    coordinatesa,
                                                    coordinatesb,
                                                    player.dimension,
                                                    firstblockname,
                                                    firstblockstates,
                                                    { matchingBlock: "air" }
                                                );
                                                let endTime = Date.now();
                                                player.sendMessageB(
                                                    `${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`
                                                );
                                            } catch (e) {
                                                player.sendError(
                                                    "§c" + e + e.stack,
                                                    true
                                                );
                                            } finally {
                                                tac.forEach((tab) => tab?.remove()
                                                );
                                            }
                                        });
                                    } catch (e) {
                                        player.sendError(
                                            "§c" + e + e.stack,
                                            true
                                        );
                                    }
                                });
                                break;
                            case "walls":
                                system.run(() => {
                                    let ta: Entity[];
                                    try {
                                        generateTickingAreaFillCoordinatesC(
                                            player.location,
                                            (() => {
                                                let a = new CompoundBlockVolume();
                                                a.pushVolume({
                                                    volume: new BlockVolume(
                                                        coordinatesa,
                                                        coordinatesb
                                                    ),
                                                });
                                                return a;
                                            })(),
                                            player.dimension
                                        ).then((tac) => {
                                            ta = tac;
                                            try {
                                                let startTime = Date.now();
                                                let a = fillBlocksHW(
                                                    coordinatesa,
                                                    coordinatesb,
                                                    player.dimension,
                                                    firstblockname,
                                                    firstblockstates,
                                                    {
                                                        matchingBlock: matchingblock[0],
                                                        matchingBlockStates: matchingblock[1],
                                                    },
                                                    undefined,
                                                    replacemode
                                                );
                                                let endTime = Date.now();
                                                player.sendMessageB(
                                                    `${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`
                                                );
                                            } catch (e) {
                                                player.sendError(
                                                    "§c" + e + e.stack,
                                                    true
                                                );
                                            } finally {
                                                tac.forEach((tab) => tab?.remove()
                                                );
                                            }
                                        });
                                    } catch (e) {
                                        player.sendError(
                                            "§c" + e + e.stack,
                                            true
                                        );
                                    }
                                });
                                break;
                            case "hollow":
                                system.run(() => {
                                    let ta: Entity[];
                                    try {
                                        generateTickingAreaFillCoordinatesC(
                                            player.location,
                                            (() => {
                                                let a = new CompoundBlockVolume();
                                                a.pushVolume({
                                                    volume: new BlockVolume(
                                                        coordinatesa,
                                                        coordinatesb
                                                    ),
                                                });
                                                return a;
                                            })(),
                                            player.dimension
                                        ).then((tac) => {
                                            ta = tac;
                                            try {
                                                let startTime = Date.now();
                                                let a = fillBlocksHH(
                                                    coordinatesa,
                                                    coordinatesb,
                                                    player.dimension,
                                                    firstblockname,
                                                    firstblockstates,
                                                    {
                                                        matchingBlock: matchingblock[0],
                                                        matchingBlockStates: matchingblock[1],
                                                    },
                                                    undefined,
                                                    replacemode
                                                );
                                                let endTime = Date.now();
                                                player.sendMessageB(
                                                    `${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`
                                                );
                                            } catch (e) {
                                                player.sendError(
                                                    "§c" + e + e.stack,
                                                    true
                                                );
                                            } finally {
                                                tac.forEach((tab) => tab?.remove()
                                                );
                                            }
                                        });
                                    } catch (e) {
                                        player.sendError(
                                            "§c" + e + e.stack,
                                            true
                                        );
                                    }
                                });
                                break;
                            case "outline":
                                system.run(() => {
                                    let ta: Entity[];
                                    try {
                                        generateTickingAreaFillCoordinatesC(
                                            player.location,
                                            (() => {
                                                let a = new CompoundBlockVolume();
                                                a.pushVolume({
                                                    volume: new BlockVolume(
                                                        coordinatesa,
                                                        coordinatesb
                                                    ),
                                                });
                                                return a;
                                            })(),
                                            player.dimension
                                        ).then((tac) => {
                                            ta = tac;
                                            try {
                                                let startTime = Date.now();
                                                let a = fillBlocksHO(
                                                    coordinatesa,
                                                    coordinatesb,
                                                    player.dimension,
                                                    firstblockname,
                                                    firstblockstates,
                                                    {
                                                        matchingBlock: matchingblock[0],
                                                        matchingBlockStates: matchingblock[1],
                                                    },
                                                    undefined,
                                                    replacemode
                                                );
                                                let endTime = Date.now();
                                                player.sendMessageB(
                                                    `${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`
                                                );
                                            } catch (e) {
                                                player.sendError(
                                                    "§c" + e + e.stack,
                                                    true
                                                );
                                            } finally {
                                                tac.forEach((tab) => tab?.remove()
                                                );
                                            }
                                        });
                                    } catch (e) {
                                        player.sendError(
                                            "§c" + e + e.stack,
                                            true
                                        );
                                    }
                                });
                                break;
                            case "pillars":
                                system.run(() => {
                                    let ta: Entity[];
                                    try {
                                        generateTickingAreaFillCoordinatesC(
                                            player.location,
                                            (() => {
                                                let a = new CompoundBlockVolume();
                                                a.pushVolume({
                                                    volume: new BlockVolume(
                                                        coordinatesa,
                                                        coordinatesb
                                                    ),
                                                });
                                                return a;
                                            })(),
                                            player.dimension
                                        ).then((tac) => {
                                            ta = tac;
                                            try {
                                                let startTime = Date.now();
                                                let a = fillBlocksHP(
                                                    coordinatesa,
                                                    coordinatesb,
                                                    player.dimension,
                                                    firstblockname,
                                                    firstblockstates,
                                                    {
                                                        matchingBlock: matchingblock[0],
                                                        matchingBlockStates: matchingblock[1],
                                                    },
                                                    undefined,
                                                    replacemode
                                                );
                                                let endTime = Date.now();
                                                player.sendMessageB(
                                                    `${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`
                                                );
                                            } catch (e) {
                                                player.sendError(
                                                    "§c" + e + e.stack,
                                                    true
                                                );
                                            } finally {
                                                tac.forEach((tab) => tab?.remove()
                                                );
                                            }
                                        });
                                    } catch (e) {
                                        player.sendError(
                                            "§c" + e + e.stack,
                                            true
                                        );
                                    }
                                });
                                break;
                            case "skygrid":
                                system.run(() => {
                                    let ta: Entity[];
                                    try {
                                        generateTickingAreaFillCoordinatesC(
                                            player.location,
                                            (() => {
                                                let a = new CompoundBlockVolume();
                                                a.pushVolume({
                                                    volume: new BlockVolume(
                                                        coordinatesa,
                                                        coordinatesb
                                                    ),
                                                });
                                                return a;
                                            })(),
                                            player.dimension
                                        ).then((tac) => {
                                            ta = tac;
                                            try {
                                                fillBlocksHSGG(
                                                    coordinatesa,
                                                    coordinatesb,
                                                    sgskygridsize,
                                                    player.dimension,
                                                    sgfirstblockname,
                                                    sgfirstblockstates,
                                                    {
                                                        matchingBlock: sgmatchingblock[0],
                                                        matchingBlockStates: sgmatchingblock[1],
                                                        minMSBetweenYields: 5000,
                                                    },
                                                    undefined,
                                                    sgreplacemode,
                                                    100
                                                ).then(
                                                    (a) => {
                                                        player.sendMessageB(
                                                            `${a.counter == 0
                                                                ? "§c"
                                                                : ""}${a.counter} blocks filled in ${a.completionData
                                                                .endTime -
                                                            a.completionData
                                                                .startTime} ms over ${a.completionData
                                                                .endTick -
                                                            a.completionData
                                                                .startTick} tick${a.completionData
                                                                .endTick -
                                                                a
                                                                    .completionData
                                                                    .startTick ==
                                                                1
                                                                ? ""
                                                                : "s"}${a.completionData
                                                                .containsUnloadedChunks
                                                                ? "; Some blocks were not generated because they were in unloaded chunks. "
                                                                : ""}`
                                                        );
                                                    },
                                                    (e) => {
                                                        player.sendError(
                                                            "§c" + e + e.stack,
                                                            true
                                                        );
                                                    }
                                                );
                                            } catch (e) {
                                                player.sendError(
                                                    "§c" + e + e.stack,
                                                    true
                                                );
                                            } finally {
                                                tac.forEach((tab) => tab?.remove()
                                                );
                                            }
                                        });
                                    } catch (e) {
                                        player.sendError(
                                            "§c" + e + e.stack,
                                            true
                                        );
                                    }
                                });
                                break;
                            case "inverseskygrid":
                                system.run(() => {
                                    let ta: Entity[];
                                    try {
                                        generateTickingAreaFillCoordinatesC(
                                            player.location,
                                            (() => {
                                                let a = new CompoundBlockVolume();
                                                a.pushVolume({
                                                    volume: new BlockVolume(
                                                        coordinatesa,
                                                        coordinatesb
                                                    ),
                                                });
                                                return a;
                                            })(),
                                            player.dimension
                                        ).then((tac) => {
                                            ta = tac;
                                            try {
                                                fillBlocksHISGG(
                                                    coordinatesa,
                                                    coordinatesb,
                                                    sgskygridsize,
                                                    player.dimension,
                                                    sgfirstblockname,
                                                    sgfirstblockstates,
                                                    {
                                                        matchingBlock: sgmatchingblock[0],
                                                        matchingBlockStates: sgmatchingblock[1],
                                                        minMSBetweenYields: 5000,
                                                    },
                                                    undefined,
                                                    sgreplacemode,
                                                    100
                                                ).then(
                                                    (a) => {
                                                        player.sendMessageB(
                                                            `${a.counter == 0
                                                                ? "§c"
                                                                : ""}${a.counter} blocks filled in ${a.completionData
                                                                .endTime -
                                                            a.completionData
                                                                .startTime} ms over ${a.completionData
                                                                .endTick -
                                                            a.completionData
                                                                .startTick} tick${a.completionData
                                                                .endTick -
                                                                a
                                                                    .completionData
                                                                    .startTick ==
                                                                1
                                                                ? ""
                                                                : "s"}${a.completionData
                                                                .containsUnloadedChunks
                                                                ? "; Some blocks were not generated because they were in unloaded chunks. "
                                                                : ""}`
                                                        );
                                                    },
                                                    (e) => {
                                                        player.sendError(
                                                            "§c" + e + e.stack,
                                                            true
                                                        );
                                                    }
                                                );
                                            } catch (e) {
                                                player.sendError(
                                                    "§c" + e + e.stack,
                                                    true
                                                );
                                            } finally {
                                                tac.forEach((tab) => tab?.remove()
                                                );
                                            }
                                        });
                                    } catch (e) {
                                        player.sendError(
                                            "§c" + e + e.stack,
                                            true
                                        );
                                    }
                                });
                                break;
                            case "tunnel":
                                player.sendMessageB("§eComing Soon!");
                                break;
                            case "floor":
                                player.sendMessageB("§eComing Soon!");
                                break;
                            case "ceilling":
                                player.sendMessageB("§eComing Soon!");
                                break;
                            case "diamond":
                                player.sendMessageB("§eComing Soon!");
                                break;
                            case "hollowovoid":
                                system.run(() => {
                                    let ta: Entity[];
                                    try {
                                        generateTickingAreaFillCoordinatesC(
                                            player.location,
                                            (() => {
                                                let a = new CompoundBlockVolume();
                                                a.pushVolume({
                                                    volume: new BlockVolume(
                                                        Vector3Utils.subtract(
                                                            center,
                                                            Object.assign(
                                                                Vector3Utils.scale(
                                                                    VECTOR3_ONE,
                                                                    50
                                                                ),
                                                                { y: 0 }
                                                            )
                                                        ),
                                                        Vector3Utils.add(
                                                            center,
                                                            Object.assign(
                                                                Vector3Utils.scale(
                                                                    VECTOR3_ONE,
                                                                    50
                                                                ),
                                                                { y: 0 }
                                                            )
                                                        )
                                                    ),
                                                });
                                                return a;
                                            })(),
                                            player.dimension
                                        ).then((tac) => {
                                            ta = tac;
                                            try {
                                                fillBlocksHHOG(
                                                    center,
                                                    vTV3(
                                                        Vector3Utils.subtract(
                                                            horadi,
                                                            {
                                                                x: -0.5,
                                                                y: -0.5,
                                                                z: -0.5,
                                                            }
                                                        )
                                                    ),
                                                    hooffset,
                                                    hothickness,
                                                    player.dimension,
                                                    hofirstblockname,
                                                    hofirstblockstates,
                                                    {
                                                        matchingBlock: homatchingblock[0],
                                                        matchingBlockStates: homatchingblock[1],
                                                        minMSBetweenYields: 5000,
                                                    },
                                                    undefined,
                                                    horeplacemode,
                                                    100
                                                ).then(
                                                    (a) => {
                                                        player.sendMessageB(
                                                            `${a.counter == 0
                                                                ? "§c"
                                                                : ""}${a.counter} blocks filled in ${a.completionData
                                                                .endTime -
                                                            a.completionData
                                                                .startTime} ms over ${a.completionData
                                                                .endTick -
                                                            a.completionData
                                                                .startTick} tick${a.completionData
                                                                .endTick -
                                                                a
                                                                    .completionData
                                                                    .startTick ==
                                                                1
                                                                ? ""
                                                                : "s"}${a.completionData
                                                                .containsUnloadedChunks
                                                                ? "; Some blocks were not generated because they were in unloaded chunks. "
                                                                : ""}`
                                                        );
                                                    },
                                                    (e) => {
                                                        player.sendError(
                                                            "§c" + e + e.stack,
                                                            true
                                                        );
                                                    }
                                                );
                                            } catch (e) {
                                                player.sendError(
                                                    "§c" + e + e.stack,
                                                    true
                                                );
                                            } finally {
                                                tac.forEach((tab) => tab?.remove()
                                                );
                                            }
                                        });
                                    } catch (e) {
                                        player.sendError(
                                            "§c" + e + e.stack,
                                            true
                                        );
                                    }
                                });
                                break;
                            case "ovoid":
                                system.run(() => {
                                    let ta: Entity[];
                                    try {
                                        generateTickingAreaFillCoordinatesC(
                                            player.location,
                                            (() => {
                                                let a = new CompoundBlockVolume();
                                                a.pushVolume({
                                                    volume: new BlockVolume(
                                                        Vector3Utils.subtract(
                                                            center,
                                                            Object.assign(
                                                                Vector3Utils.scale(
                                                                    VECTOR3_ONE,
                                                                    50
                                                                ),
                                                                { y: 0 }
                                                            )
                                                        ),
                                                        Vector3Utils.add(
                                                            center,
                                                            Object.assign(
                                                                Vector3Utils.scale(
                                                                    VECTOR3_ONE,
                                                                    50
                                                                ),
                                                                { y: 0 }
                                                            )
                                                        )
                                                    ),
                                                });
                                                return a;
                                            })(),
                                            player.dimension
                                        ).then((tac) => {
                                            ta = tac;
                                            try {
                                                fillBlocksHOG(
                                                    center,
                                                    vTV3(
                                                        Vector3Utils.subtract(
                                                            oradi,
                                                            {
                                                                x: -0.5,
                                                                y: -0.5,
                                                                z: -0.5,
                                                            }
                                                        )
                                                    ),
                                                    ooffset,
                                                    player.dimension,
                                                    ofirstblockname,
                                                    ofirstblockstates,
                                                    {
                                                        matchingBlock: omatchingblock[0],
                                                        matchingBlockStates: omatchingblock[1],
                                                        minMSBetweenYields: 5000,
                                                    },
                                                    undefined,
                                                    oreplacemode,
                                                    100
                                                ).then(
                                                    (a) => {
                                                        player.sendMessageB(
                                                            `${a.counter == 0
                                                                ? "§c"
                                                                : ""}${a.counter} blocks filled in ${a.completionData
                                                                .endTime -
                                                            a.completionData
                                                                .startTime} ms over ${a.completionData
                                                                .endTick -
                                                            a.completionData
                                                                .startTick} tick${a.completionData
                                                                .endTick -
                                                                a
                                                                    .completionData
                                                                    .startTick ==
                                                                1
                                                                ? ""
                                                                : "s"}${a.completionData
                                                                .containsUnloadedChunks
                                                                ? "; Some blocks were not generated because they were in unloaded chunks. "
                                                                : ""}`
                                                        );
                                                    },
                                                    (e) => {
                                                        player.sendError(
                                                            "§c" + e + e.stack,
                                                            true
                                                        );
                                                    }
                                                );
                                            } catch (e) {
                                                player.sendError(
                                                    "§c" + e + e.stack,
                                                    true
                                                );
                                            } finally {
                                                tac.forEach((tab) => tab?.remove()
                                                );
                                            }
                                        });
                                    } catch (e) {
                                        player.sendError(
                                            "§c" + e + e.stack,
                                            true
                                        );
                                    }
                                });
                                break;
                            case "hollowsphere":
                                system.run(() => {
                                    let ta: Entity[];
                                    try {
                                        generateTickingAreaFillCoordinatesC(
                                            player.location,
                                            (() => {
                                                let a = new CompoundBlockVolume();
                                                a.pushVolume({
                                                    volume: new BlockVolume(
                                                        Vector3Utils.subtract(
                                                            center,
                                                            Object.assign(
                                                                Vector3Utils.scale(
                                                                    VECTOR3_ONE,
                                                                    50
                                                                ),
                                                                { y: 0 }
                                                            )
                                                        ),
                                                        Vector3Utils.add(
                                                            center,
                                                            Object.assign(
                                                                Vector3Utils.scale(
                                                                    VECTOR3_ONE,
                                                                    50
                                                                ),
                                                                { y: 0 }
                                                            )
                                                        )
                                                    ),
                                                });
                                                return a;
                                            })(),
                                            player.dimension
                                        ).then((tac) => {
                                            ta = tac;
                                            try {
                                                fillBlocksHHSG(
                                                    center,
                                                    radius - 0.5,
                                                    thickness,
                                                    player.dimension,
                                                    hsfirstblockname,
                                                    hsfirstblockstates,
                                                    {
                                                        matchingBlock: hsmatchingblock[0],
                                                        matchingBlockStates: hsmatchingblock[1],
                                                        minMSBetweenYields: 5000,
                                                    },
                                                    undefined,
                                                    hsreplacemode,
                                                    100
                                                ).then(
                                                    (a) => {
                                                        player.sendMessageB(
                                                            `${a.counter == 0
                                                                ? "§c"
                                                                : ""}${a.counter} blocks filled in ${a.completionData
                                                                .endTime -
                                                            a.completionData
                                                                .startTime} ms over ${a.completionData
                                                                .endTick -
                                                            a.completionData
                                                                .startTick} tick${a.completionData
                                                                .endTick -
                                                                a
                                                                    .completionData
                                                                    .startTick ==
                                                                1
                                                                ? ""
                                                                : "s"}${a.completionData
                                                                .containsUnloadedChunks
                                                                ? "; Some blocks were not generated because they were in unloaded chunks. "
                                                                : ""}`
                                                        );
                                                    },
                                                    (e) => {
                                                        player.sendError(
                                                            "§c" + e + e.stack,
                                                            true
                                                        );
                                                    }
                                                );
                                            } catch (e) {
                                                player.sendError(
                                                    "§c" + e + e.stack,
                                                    true
                                                );
                                            } finally {
                                                tac.forEach((tab) => tab?.remove()
                                                );
                                            }
                                        });
                                    } catch (e) {
                                        player.sendError(
                                            "§c" + e + e.stack,
                                            true
                                        );
                                    }
                                });
                                break;
                            case "dome":
                                system.run(() => {
                                    let ta: Entity[];
                                    try {
                                        generateTickingAreaFillCoordinatesC(
                                            player.location,
                                            (() => {
                                                let a = new CompoundBlockVolume();
                                                a.pushVolume({
                                                    volume: new BlockVolume(
                                                        Vector3Utils.subtract(
                                                            center,
                                                            Object.assign(
                                                                Vector3Utils.scale(
                                                                    VECTOR3_ONE,
                                                                    50
                                                                ),
                                                                { y: 0 }
                                                            )
                                                        ),
                                                        Vector3Utils.add(
                                                            center,
                                                            Object.assign(
                                                                Vector3Utils.scale(
                                                                    VECTOR3_ONE,
                                                                    50
                                                                ),
                                                                { y: 0 }
                                                            )
                                                        )
                                                    ),
                                                });
                                                return a;
                                            })(),
                                            player.dimension
                                        ).then((tac) => {
                                            ta = tac;
                                            try {
                                                fillBlocksHDG(
                                                    center,
                                                    radius - 0.5,
                                                    thickness,
                                                    player.dimension,
                                                    hsfirstblockname,
                                                    hsfirstblockstates,
                                                    {
                                                        matchingBlock: hsmatchingblock[0],
                                                        matchingBlockStates: hsmatchingblock[1],
                                                        minMSBetweenYields: 5000,
                                                    },
                                                    undefined,
                                                    hsreplacemode,
                                                    100
                                                ).then(
                                                    (a) => {
                                                        player.sendMessageB(
                                                            `${a.counter == 0
                                                                ? "§c"
                                                                : ""}${a.counter} blocks filled in ${a.completionData
                                                                .endTime -
                                                            a.completionData
                                                                .startTime} ms over ${a.completionData
                                                                .endTick -
                                                            a.completionData
                                                                .startTick} tick${a.completionData
                                                                .endTick -
                                                                a
                                                                    .completionData
                                                                    .startTick ==
                                                                1
                                                                ? ""
                                                                : "s"}${a.completionData
                                                                .containsUnloadedChunks
                                                                ? "; Some blocks were not generated because they were in unloaded chunks. "
                                                                : ""}`
                                                        );
                                                    },
                                                    (e) => {
                                                        player.sendError(
                                                            "§c" + e + e.stack,
                                                            true
                                                        );
                                                    }
                                                );
                                            } catch (e) {
                                                player.sendError(
                                                    "§c" + e + e.stack,
                                                    true
                                                );
                                            } finally {
                                                tac.forEach((tab) => tab?.remove()
                                                );
                                            }
                                        });
                                    } catch (e) {
                                        player.sendError(
                                            "§c" + e + e.stack,
                                            true
                                        );
                                    }
                                });
                                break;
                            case "sphere":
                                system.run(() => {
                                    let ta: Entity[];
                                    try {
                                        generateTickingAreaFillCoordinatesC(
                                            player.location,
                                            (() => {
                                                let a = new CompoundBlockVolume();
                                                a.pushVolume({
                                                    volume: new BlockVolume(
                                                        Vector3Utils.subtract(
                                                            center,
                                                            Object.assign(
                                                                Vector3Utils.scale(
                                                                    VECTOR3_ONE,
                                                                    50
                                                                ),
                                                                { y: 0 }
                                                            )
                                                        ),
                                                        Vector3Utils.add(
                                                            center,
                                                            Object.assign(
                                                                Vector3Utils.scale(
                                                                    VECTOR3_ONE,
                                                                    50
                                                                ),
                                                                { y: 0 }
                                                            )
                                                        )
                                                    ),
                                                });
                                                return a;
                                            })(),
                                            player.dimension
                                        ).then((tac) => {
                                            ta = tac;
                                            try {
                                                fillBlocksHSG(
                                                    center,
                                                    radius - 0.5,
                                                    player.dimension,
                                                    ccfirstblockname,
                                                    ccfirstblockstates,
                                                    {
                                                        matchingBlock: ccmatchingblock[0],
                                                        matchingBlockStates: ccmatchingblock[1],
                                                        minMSBetweenYields: 5000,
                                                    },
                                                    undefined,
                                                    ccreplacemode,
                                                    100
                                                ).then(
                                                    (a) => {
                                                        player.sendMessageB(
                                                            `${a.counter == 0
                                                                ? "§c"
                                                                : ""}${a.counter} blocks filled in ${a.completionData
                                                                .endTime -
                                                            a.completionData
                                                                .startTime} ms over ${a.completionData
                                                                .endTick -
                                                            a.completionData
                                                                .startTick} tick${a.completionData
                                                                .endTick -
                                                                a
                                                                    .completionData
                                                                    .startTick ==
                                                                1
                                                                ? ""
                                                                : "s"}`
                                                        );
                                                    },
                                                    (e) => {
                                                        player.sendError(
                                                            "§c" + e + e.stack,
                                                            true
                                                        );
                                                    }
                                                );
                                            } catch (e) {
                                                player.sendError(
                                                    "§c" + e + e.stack,
                                                    true
                                                );
                                            } finally {
                                                tac.forEach((tab) => tab?.remove()
                                                );
                                            }
                                        });
                                    } catch (e) {
                                        player.sendError(
                                            "§c" + e + e.stack,
                                            true
                                        );
                                    }
                                });
                                break;
                            case "semisphere":
                                system.run(() => {
                                    let ta: Entity[];
                                    try {
                                        generateTickingAreaFillCoordinatesC(
                                            player.location,
                                            (() => {
                                                let a = new CompoundBlockVolume();
                                                a.pushVolume({
                                                    volume: new BlockVolume(
                                                        Vector3Utils.subtract(
                                                            center,
                                                            Object.assign(
                                                                Vector3Utils.scale(
                                                                    VECTOR3_ONE,
                                                                    50
                                                                ),
                                                                { y: 0 }
                                                            )
                                                        ),
                                                        Vector3Utils.add(
                                                            center,
                                                            Object.assign(
                                                                Vector3Utils.scale(
                                                                    VECTOR3_ONE,
                                                                    50
                                                                ),
                                                                { y: 0 }
                                                            )
                                                        )
                                                    ),
                                                });
                                                return a;
                                            })(),
                                            player.dimension
                                        ).then((tac) => {
                                            ta = tac;
                                            try {
                                                fillBlocksHSSG(
                                                    center,
                                                    radius - 0.5,
                                                    player.dimension,
                                                    ccfirstblockname,
                                                    ccfirstblockstates,
                                                    {
                                                        matchingBlock: ccmatchingblock[0],
                                                        matchingBlockStates: ccmatchingblock[1],
                                                        minMSBetweenYields: 5000,
                                                    },
                                                    undefined,
                                                    ccreplacemode,
                                                    100
                                                ).then(
                                                    (a) => {
                                                        player.sendMessageB(
                                                            `${a.counter == 0
                                                                ? "§c"
                                                                : ""}${a.counter} blocks filled in ${a.completionData
                                                                .endTime -
                                                            a.completionData
                                                                .startTime} ms over ${a.completionData
                                                                .endTick -
                                                            a.completionData
                                                                .startTick} tick${a.completionData
                                                                .endTick -
                                                                a
                                                                    .completionData
                                                                    .startTick ==
                                                                1
                                                                ? ""
                                                                : "s"}`
                                                        );
                                                    },
                                                    (e) => {
                                                        player.sendError(
                                                            "§c" + e + e.stack,
                                                            true
                                                        );
                                                    }
                                                );
                                            } catch (e) {
                                                player.sendError(
                                                    "§c" + e + e.stack,
                                                    true
                                                );
                                            } finally {
                                                tac.forEach((tab) => tab?.remove()
                                                );
                                            }
                                        });
                                    } catch (e) {
                                        player.sendError(
                                            "§c" + e + e.stack,
                                            true
                                        );
                                    }
                                });
                                break;
                            case "circle":
                                system.run(() => {
                                    let ta: Entity[];
                                    try {
                                        generateTickingAreaFillCoordinatesC(
                                            player.location,
                                            (() => {
                                                let a = new CompoundBlockVolume();
                                                a.pushVolume({
                                                    volume: new BlockVolume(
                                                        Vector3Utils.subtract(
                                                            center,
                                                            Object.assign(
                                                                Vector3Utils.scale(
                                                                    VECTOR3_ONE,
                                                                    50
                                                                ),
                                                                { y: 0 }
                                                            )
                                                        ),
                                                        Vector3Utils.add(
                                                            center,
                                                            Object.assign(
                                                                Vector3Utils.scale(
                                                                    VECTOR3_ONE,
                                                                    50
                                                                ),
                                                                { y: 0 }
                                                            )
                                                        )
                                                    ),
                                                });
                                                return a;
                                            })(),
                                            player.dimension
                                        ).then((tac) => {
                                            ta = tac;
                                            try {
                                                let startTime = Date.now();
                                                let a = fillBlocksHC(
                                                    center,
                                                    radius,
                                                    player.dimension,
                                                    axis,
                                                    cfirstblockname,
                                                    cfirstblockstates,
                                                    {
                                                        matchingBlock: cmatchingblock[0],
                                                        matchingBlockStates: cmatchingblock[1],
                                                    },
                                                    undefined,
                                                    creplacemode
                                                );
                                                let endTime = Date.now();
                                                player.sendMessageB(
                                                    `${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`
                                                );
                                            } catch (e) {
                                                player.sendError(
                                                    "§c" + e + e.stack,
                                                    true
                                                );
                                            } finally {
                                                tac.forEach((tab) => tab?.remove()
                                                );
                                            }
                                        });
                                    } catch (e) {
                                        player.sendError(
                                            "§c" + e + e.stack,
                                            true
                                        );
                                    }
                                });
                                break;
                            case "circlex":
                                system.run(() => {
                                    let ta: Entity[];
                                    try {
                                        generateTickingAreaFillCoordinatesC(
                                            player.location,
                                            (() => {
                                                let a = new CompoundBlockVolume();
                                                a.pushVolume({
                                                    volume: new BlockVolume(
                                                        Vector3Utils.subtract(
                                                            center,
                                                            Object.assign(
                                                                Vector3Utils.scale(
                                                                    VECTOR3_ONE,
                                                                    50
                                                                ),
                                                                { y: 0 }
                                                            )
                                                        ),
                                                        Vector3Utils.add(
                                                            center,
                                                            Object.assign(
                                                                Vector3Utils.scale(
                                                                    VECTOR3_ONE,
                                                                    50
                                                                ),
                                                                { y: 0 }
                                                            )
                                                        )
                                                    ),
                                                });
                                                return a;
                                            })(),
                                            player.dimension
                                        ).then((tac) => {
                                            ta = tac;
                                            try {
                                                let startTime = Date.now();
                                                let a = fillBlocksHC(
                                                    center,
                                                    radius,
                                                    player.dimension,
                                                    "x",
                                                    ccfirstblockname,
                                                    ccfirstblockstates,
                                                    {
                                                        matchingBlock: ccmatchingblock[0],
                                                        matchingBlockStates: ccmatchingblock[1],
                                                    },
                                                    undefined,
                                                    ccreplacemode
                                                );
                                                let endTime = Date.now();
                                                player.sendMessageB(
                                                    `${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`
                                                );
                                            } catch (e) {
                                                player.sendError(
                                                    "§c" + e + e.stack,
                                                    true
                                                );
                                            } finally {
                                                tac.forEach((tab) => tab?.remove()
                                                );
                                            }
                                        });
                                    } catch (e) {
                                        player.sendError(
                                            "§c" + e + e.stack,
                                            true
                                        );
                                    }
                                });
                                break;
                            case "circley":
                                system.run(() => {
                                    let ta: Entity[];
                                    try {
                                        generateTickingAreaFillCoordinatesC(
                                            player.location,
                                            (() => {
                                                let a = new CompoundBlockVolume();
                                                a.pushVolume({
                                                    volume: new BlockVolume(
                                                        Vector3Utils.subtract(
                                                            center,
                                                            Object.assign(
                                                                Vector3Utils.scale(
                                                                    VECTOR3_ONE,
                                                                    50
                                                                ),
                                                                { y: 0 }
                                                            )
                                                        ),
                                                        Vector3Utils.add(
                                                            center,
                                                            Object.assign(
                                                                Vector3Utils.scale(
                                                                    VECTOR3_ONE,
                                                                    50
                                                                ),
                                                                { y: 0 }
                                                            )
                                                        )
                                                    ),
                                                });
                                                return a;
                                            })(),
                                            player.dimension
                                        ).then((tac) => {
                                            ta = tac;
                                            try {
                                                let startTime = Date.now();
                                                let a = fillBlocksHC(
                                                    center,
                                                    radius,
                                                    player.dimension,
                                                    "y",
                                                    ccfirstblockname,
                                                    ccfirstblockstates,
                                                    {
                                                        matchingBlock: ccmatchingblock[0],
                                                        matchingBlockStates: ccmatchingblock[1],
                                                    },
                                                    undefined,
                                                    ccreplacemode
                                                );
                                                let endTime = Date.now();
                                                player.sendMessageB(
                                                    `${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`
                                                );
                                            } catch (e) {
                                                player.sendError(
                                                    "§c" + e + e.stack,
                                                    true
                                                );
                                            } finally {
                                                tac.forEach((tab) => tab?.remove()
                                                );
                                            }
                                        });
                                    } catch (e) {
                                        player.sendError(
                                            "§c" + e + e.stack,
                                            true
                                        );
                                    }
                                });
                                break;
                            case "circlez":
                                system.run(() => {
                                    let ta: Entity[];
                                    try {
                                        generateTickingAreaFillCoordinatesC(
                                            player.location,
                                            (() => {
                                                let a = new CompoundBlockVolume();
                                                a.pushVolume({
                                                    volume: new BlockVolume(
                                                        Vector3Utils.subtract(
                                                            center,
                                                            Object.assign(
                                                                Vector3Utils.scale(
                                                                    VECTOR3_ONE,
                                                                    50
                                                                ),
                                                                { y: 0 }
                                                            )
                                                        ),
                                                        Vector3Utils.add(
                                                            center,
                                                            Object.assign(
                                                                Vector3Utils.scale(
                                                                    VECTOR3_ONE,
                                                                    50
                                                                ),
                                                                { y: 0 }
                                                            )
                                                        )
                                                    ),
                                                });
                                                return a;
                                            })(),
                                            player.dimension
                                        ).then((tac) => {
                                            ta = tac;
                                            try {
                                                let startTime = Date.now();
                                                let a = fillBlocksHC(
                                                    center,
                                                    radius,
                                                    player.dimension,
                                                    "z",
                                                    ccfirstblockname,
                                                    ccfirstblockstates,
                                                    {
                                                        matchingBlock: ccmatchingblock[0],
                                                        matchingBlockStates: ccmatchingblock[1],
                                                    },
                                                    undefined,
                                                    ccreplacemode
                                                );
                                                let endTime = Date.now();
                                                player.sendMessageB(
                                                    `${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`
                                                );
                                            } catch (e) {
                                                player.sendError(
                                                    "§c" + e + e.stack,
                                                    true
                                                );
                                            } finally {
                                                tac.forEach((tab) => tab?.remove()
                                                );
                                            }
                                        });
                                    } catch (e) {
                                        player.sendError(
                                            "§c" + e + e.stack,
                                            true
                                        );
                                    }
                                });
                                break;
                            case "circlexy":
                                system.run(() => {
                                    let ta: Entity[];
                                    try {
                                        generateTickingAreaFillCoordinatesC(
                                            player.location,
                                            (() => {
                                                let a = new CompoundBlockVolume();
                                                a.pushVolume({
                                                    volume: new BlockVolume(
                                                        Vector3Utils.subtract(
                                                            center,
                                                            Object.assign(
                                                                Vector3Utils.scale(
                                                                    VECTOR3_ONE,
                                                                    50
                                                                ),
                                                                { y: 0 }
                                                            )
                                                        ),
                                                        Vector3Utils.add(
                                                            center,
                                                            Object.assign(
                                                                Vector3Utils.scale(
                                                                    VECTOR3_ONE,
                                                                    50
                                                                ),
                                                                { y: 0 }
                                                            )
                                                        )
                                                    ),
                                                });
                                                return a;
                                            })(),
                                            player.dimension
                                        ).then((tac) => {
                                            ta = tac;
                                            try {
                                                let startTime = Date.now();
                                                let a = fillBlocksHC(
                                                    center,
                                                    radius,
                                                    player.dimension,
                                                    "xy",
                                                    ccfirstblockname,
                                                    ccfirstblockstates,
                                                    {
                                                        matchingBlock: ccmatchingblock[0],
                                                        matchingBlockStates: ccmatchingblock[1],
                                                    },
                                                    undefined,
                                                    ccreplacemode
                                                );
                                                let endTime = Date.now();
                                                player.sendMessageB(
                                                    `${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`
                                                );
                                            } catch (e) {
                                                player.sendError(
                                                    "§c" + e + e.stack,
                                                    true
                                                );
                                            } finally {
                                                tac.forEach((tab) => tab?.remove()
                                                );
                                            }
                                        });
                                    } catch (e) {
                                        player.sendError(
                                            "§c" + e + e.stack,
                                            true
                                        );
                                    }
                                });
                                break;
                            case "circleyz":
                                system.run(() => {
                                    let ta: Entity[];
                                    try {
                                        generateTickingAreaFillCoordinatesC(
                                            player.location,
                                            (() => {
                                                let a = new CompoundBlockVolume();
                                                a.pushVolume({
                                                    volume: new BlockVolume(
                                                        Vector3Utils.subtract(
                                                            center,
                                                            Object.assign(
                                                                Vector3Utils.scale(
                                                                    VECTOR3_ONE,
                                                                    50
                                                                ),
                                                                { y: 0 }
                                                            )
                                                        ),
                                                        Vector3Utils.add(
                                                            center,
                                                            Object.assign(
                                                                Vector3Utils.scale(
                                                                    VECTOR3_ONE,
                                                                    50
                                                                ),
                                                                { y: 0 }
                                                            )
                                                        )
                                                    ),
                                                });
                                                return a;
                                            })(),
                                            player.dimension
                                        ).then((tac) => {
                                            ta = tac;
                                            try {
                                                let startTime = Date.now();
                                                let a = fillBlocksHC(
                                                    center,
                                                    radius,
                                                    player.dimension,
                                                    "yz",
                                                    ccfirstblockname,
                                                    ccfirstblockstates,
                                                    {
                                                        matchingBlock: ccmatchingblock[0],
                                                        matchingBlockStates: ccmatchingblock[1],
                                                    },
                                                    undefined,
                                                    ccreplacemode
                                                );
                                                let endTime = Date.now();
                                                player.sendMessageB(
                                                    `${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`
                                                );
                                            } catch (e) {
                                                player.sendError(
                                                    "§c" + e + e.stack,
                                                    true
                                                );
                                            } finally {
                                                tac.forEach((tab) => tab?.remove()
                                                );
                                            }
                                        });
                                    } catch (e) {
                                        player.sendError(
                                            "§c" + e + e.stack,
                                            true
                                        );
                                    }
                                });
                                break;
                            case "circlexz":
                                system.run(() => {
                                    let ta: Entity[];
                                    try {
                                        generateTickingAreaFillCoordinatesC(
                                            player.location,
                                            (() => {
                                                let a = new CompoundBlockVolume();
                                                a.pushVolume({
                                                    volume: new BlockVolume(
                                                        Vector3Utils.subtract(
                                                            center,
                                                            Object.assign(
                                                                Vector3Utils.scale(
                                                                    VECTOR3_ONE,
                                                                    50
                                                                ),
                                                                { y: 0 }
                                                            )
                                                        ),
                                                        Vector3Utils.add(
                                                            center,
                                                            Object.assign(
                                                                Vector3Utils.scale(
                                                                    VECTOR3_ONE,
                                                                    50
                                                                ),
                                                                { y: 0 }
                                                            )
                                                        )
                                                    ),
                                                });
                                                return a;
                                            })(),
                                            player.dimension
                                        ).then((tac) => {
                                            ta = tac;
                                            try {
                                                let startTime = Date.now();
                                                let a = fillBlocksHC(
                                                    center,
                                                    radius,
                                                    player.dimension,
                                                    "xz",
                                                    ccfirstblockname,
                                                    ccfirstblockstates,
                                                    {
                                                        matchingBlock: ccmatchingblock[0],
                                                        matchingBlockStates: ccmatchingblock[1],
                                                    },
                                                    undefined,
                                                    ccreplacemode
                                                );
                                                let endTime = Date.now();
                                                player.sendMessageB(
                                                    `${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`
                                                );
                                            } catch (e) {
                                                player.sendError(
                                                    "§c" + e + e.stack,
                                                    true
                                                );
                                            } finally {
                                                tac.forEach((tab) => tab?.remove()
                                                );
                                            }
                                        });
                                    } catch (e) {
                                        player.sendError(
                                            "§c" + e + e.stack,
                                            true
                                        );
                                    }
                                });
                                break;
                            case "circlexyz":
                                system.run(() => {
                                    let ta: Entity[];
                                    try {
                                        generateTickingAreaFillCoordinatesC(
                                            player.location,
                                            (() => {
                                                let a = new CompoundBlockVolume();
                                                a.pushVolume({
                                                    volume: new BlockVolume(
                                                        Vector3Utils.subtract(
                                                            center,
                                                            Object.assign(
                                                                Vector3Utils.scale(
                                                                    VECTOR3_ONE,
                                                                    50
                                                                ),
                                                                { y: 0 }
                                                            )
                                                        ),
                                                        Vector3Utils.add(
                                                            center,
                                                            Object.assign(
                                                                Vector3Utils.scale(
                                                                    VECTOR3_ONE,
                                                                    50
                                                                ),
                                                                { y: 0 }
                                                            )
                                                        )
                                                    ),
                                                });
                                                return a;
                                            })(),
                                            player.dimension
                                        ).then((tac) => {
                                            ta = tac;
                                            try {
                                                let startTime = Date.now();
                                                let a = fillBlocksHC(
                                                    center,
                                                    radius,
                                                    player.dimension,
                                                    "xyz",
                                                    ccfirstblockname,
                                                    ccfirstblockstates,
                                                    {
                                                        matchingBlock: ccmatchingblock[0],
                                                        matchingBlockStates: ccmatchingblock[1],
                                                    },
                                                    undefined,
                                                    ccreplacemode
                                                );
                                                let endTime = Date.now();
                                                player.sendMessageB(
                                                    `${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`
                                                );
                                            } catch (e) {
                                                player.sendError(
                                                    "§c" + e + e.stack,
                                                    true
                                                );
                                            } finally {
                                                tac.forEach((tab) => tab?.remove()
                                                );
                                            }
                                        });
                                    } catch (e) {
                                        player.sendError(
                                            "§c" + e + e.stack,
                                            true
                                        );
                                    }
                                });
                                break;
                            case "cylinder":
                                system.run(() => {
                                    let ta: Entity[];
                                    try {
                                        generateTickingAreaFillCoordinatesC(
                                            player.location,
                                            (() => {
                                                let a = new CompoundBlockVolume();
                                                a.pushVolume({
                                                    volume: new BlockVolume(
                                                        Vector3Utils.subtract(
                                                            center,
                                                            Object.assign(
                                                                Vector3Utils.scale(
                                                                    VECTOR3_ONE,
                                                                    50
                                                                ),
                                                                { y: 0 }
                                                            )
                                                        ),
                                                        Vector3Utils.add(
                                                            center,
                                                            Object.assign(
                                                                Vector3Utils.scale(
                                                                    VECTOR3_ONE,
                                                                    50
                                                                ),
                                                                { y: 0 }
                                                            )
                                                        )
                                                    ),
                                                });
                                                return a;
                                            })(),
                                            player.dimension
                                        ).then((tac) => {
                                            ta = tac;
                                            try {
                                                let startTime = Date.now();
                                                let a = fillBlocksHT(
                                                    center,
                                                    radius,
                                                    thickness,
                                                    taxis,
                                                    player.dimension,
                                                    tfirstblockname,
                                                    tfirstblockstates,
                                                    {
                                                        matchingBlock: tmatchingblock[0],
                                                        matchingBlockStates: tmatchingblock[1],
                                                    },
                                                    undefined,
                                                    treplacemode
                                                );
                                                let endTime = Date.now();
                                                player.sendMessageB(
                                                    `${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`
                                                );
                                            } catch (e) {
                                                player.sendError(
                                                    "§c" + e + e.stack,
                                                    true
                                                );
                                            } finally {
                                                tac.forEach((tab) => tab?.remove()
                                                );
                                            }
                                        });
                                    } catch (e) {
                                        player.sendError(
                                            "§c" + e + e.stack,
                                            true
                                        );
                                    }
                                });
                                break;
                            case "cylinderx":
                                system.run(() => {
                                    let ta: Entity[];
                                    try {
                                        generateTickingAreaFillCoordinatesC(
                                            player.location,
                                            (() => {
                                                let a = new CompoundBlockVolume();
                                                a.pushVolume({
                                                    volume: new BlockVolume(
                                                        Vector3Utils.subtract(
                                                            center,
                                                            Object.assign(
                                                                Vector3Utils.scale(
                                                                    VECTOR3_ONE,
                                                                    50
                                                                ),
                                                                { y: 0 }
                                                            )
                                                        ),
                                                        Vector3Utils.add(
                                                            center,
                                                            Object.assign(
                                                                Vector3Utils.scale(
                                                                    VECTOR3_ONE,
                                                                    50
                                                                ),
                                                                { y: 0 }
                                                            )
                                                        )
                                                    ),
                                                });
                                                return a;
                                            })(),
                                            player.dimension
                                        ).then((tac) => {
                                            ta = tac;
                                            try {
                                                let startTime = Date.now();
                                                let a = fillBlocksHT(
                                                    center,
                                                    radius,
                                                    thickness,
                                                    "x",
                                                    player.dimension,
                                                    hsfirstblockname,
                                                    hsfirstblockstates,
                                                    {
                                                        matchingBlock: hsmatchingblock[0],
                                                        matchingBlockStates: hsmatchingblock[1],
                                                    },
                                                    undefined,
                                                    hsreplacemode
                                                );
                                                let endTime = Date.now();
                                                player.sendMessageB(
                                                    `${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`
                                                );
                                            } catch (e) {
                                                player.sendError(
                                                    "§c" + e + e.stack,
                                                    true
                                                );
                                            } finally {
                                                tac.forEach((tab) => tab?.remove()
                                                );
                                            }
                                        });
                                    } catch (e) {
                                        player.sendError(
                                            "§c" + e + e.stack,
                                            true
                                        );
                                    }
                                });
                                break;
                            case "cylindery":
                                system.run(() => {
                                    let ta: Entity[];
                                    try {
                                        generateTickingAreaFillCoordinatesC(
                                            player.location,
                                            (() => {
                                                let a = new CompoundBlockVolume();
                                                a.pushVolume({
                                                    volume: new BlockVolume(
                                                        Vector3Utils.subtract(
                                                            center,
                                                            Object.assign(
                                                                Vector3Utils.scale(
                                                                    VECTOR3_ONE,
                                                                    50
                                                                ),
                                                                { y: 0 }
                                                            )
                                                        ),
                                                        Vector3Utils.add(
                                                            center,
                                                            Object.assign(
                                                                Vector3Utils.scale(
                                                                    VECTOR3_ONE,
                                                                    50
                                                                ),
                                                                { y: 0 }
                                                            )
                                                        )
                                                    ),
                                                });
                                                return a;
                                            })(),
                                            player.dimension
                                        ).then((tac) => {
                                            ta = tac;
                                            try {
                                                let startTime = Date.now();
                                                let a = fillBlocksHT(
                                                    center,
                                                    radius,
                                                    thickness,
                                                    "y",
                                                    player.dimension,
                                                    hsfirstblockname,
                                                    hsfirstblockstates,
                                                    {
                                                        matchingBlock: hsmatchingblock[0],
                                                        matchingBlockStates: hsmatchingblock[1],
                                                    },
                                                    undefined,
                                                    hsreplacemode
                                                );
                                                let endTime = Date.now();
                                                player.sendMessageB(
                                                    `${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`
                                                );
                                            } catch (e) {
                                                player.sendError(
                                                    "§c" + e + e.stack,
                                                    true
                                                );
                                            } finally {
                                                tac.forEach((tab) => tab?.remove()
                                                );
                                            }
                                        });
                                    } catch (e) {
                                        player.sendError(
                                            "§c" + e + e.stack,
                                            true
                                        );
                                    }
                                });
                                break;
                            case "cylinderz":
                                system.run(() => {
                                    let ta: Entity[];
                                    try {
                                        generateTickingAreaFillCoordinatesC(
                                            player.location,
                                            (() => {
                                                let a = new CompoundBlockVolume();
                                                a.pushVolume({
                                                    volume: new BlockVolume(
                                                        Vector3Utils.subtract(
                                                            center,
                                                            Object.assign(
                                                                Vector3Utils.scale(
                                                                    VECTOR3_ONE,
                                                                    50
                                                                ),
                                                                { y: 0 }
                                                            )
                                                        ),
                                                        Vector3Utils.add(
                                                            center,
                                                            Object.assign(
                                                                Vector3Utils.scale(
                                                                    VECTOR3_ONE,
                                                                    50
                                                                ),
                                                                { y: 0 }
                                                            )
                                                        )
                                                    ),
                                                });
                                                return a;
                                            })(),
                                            player.dimension
                                        ).then((tac) => {
                                            ta = tac;
                                            try {
                                                let startTime = Date.now();
                                                let a = fillBlocksHT(
                                                    center,
                                                    radius,
                                                    thickness,
                                                    "z",
                                                    player.dimension,
                                                    hsfirstblockname,
                                                    hsfirstblockstates,
                                                    {
                                                        matchingBlock: hsmatchingblock[0],
                                                        matchingBlockStates: hsmatchingblock[1],
                                                    },
                                                    undefined,
                                                    hsreplacemode
                                                );
                                                let endTime = Date.now();
                                                player.sendMessageB(
                                                    `${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`
                                                );
                                            } catch (e) {
                                                player.sendError(
                                                    "§c" + e + e.stack,
                                                    true
                                                );
                                            } finally {
                                                tac.forEach((tab) => tab?.remove()
                                                );
                                            }
                                        });
                                    } catch (e) {
                                        player.sendError(
                                            "§c" + e + e.stack,
                                            true
                                        );
                                    }
                                });
                                break;
                            case "cylinderxy":
                                system.run(() => {
                                    let ta: Entity[];
                                    try {
                                        generateTickingAreaFillCoordinatesC(
                                            player.location,
                                            (() => {
                                                let a = new CompoundBlockVolume();
                                                a.pushVolume({
                                                    volume: new BlockVolume(
                                                        Vector3Utils.subtract(
                                                            center,
                                                            Object.assign(
                                                                Vector3Utils.scale(
                                                                    VECTOR3_ONE,
                                                                    50
                                                                ),
                                                                { y: 0 }
                                                            )
                                                        ),
                                                        Vector3Utils.add(
                                                            center,
                                                            Object.assign(
                                                                Vector3Utils.scale(
                                                                    VECTOR3_ONE,
                                                                    50
                                                                ),
                                                                { y: 0 }
                                                            )
                                                        )
                                                    ),
                                                });
                                                return a;
                                            })(),
                                            player.dimension
                                        ).then((tac) => {
                                            ta = tac;
                                            try {
                                                let startTime = Date.now();
                                                let a = fillBlocksHT(
                                                    center,
                                                    radius,
                                                    thickness,
                                                    "x",
                                                    player.dimension,
                                                    hsfirstblockname,
                                                    hsfirstblockstates,
                                                    {
                                                        matchingBlock: hsmatchingblock[0],
                                                        matchingBlockStates: hsmatchingblock[1],
                                                    },
                                                    undefined,
                                                    hsreplacemode
                                                );
                                                let endTime = Date.now();
                                                player.sendMessageB(
                                                    `${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`
                                                );
                                            } catch (e) {
                                                player.sendError(
                                                    "§c" + e + e.stack,
                                                    true
                                                );
                                            } finally {
                                                tac.forEach((tab) => tab?.remove()
                                                );
                                            }
                                        });
                                    } catch (e) {
                                        player.sendError(
                                            "§c" + e + e.stack,
                                            true
                                        );
                                    }
                                });
                                break;
                            case "cylinderyz":
                                system.run(() => {
                                    let ta: Entity[];
                                    try {
                                        generateTickingAreaFillCoordinatesC(
                                            player.location,
                                            (() => {
                                                let a = new CompoundBlockVolume();
                                                a.pushVolume({
                                                    volume: new BlockVolume(
                                                        Vector3Utils.subtract(
                                                            center,
                                                            Object.assign(
                                                                Vector3Utils.scale(
                                                                    VECTOR3_ONE,
                                                                    50
                                                                ),
                                                                { y: 0 }
                                                            )
                                                        ),
                                                        Vector3Utils.add(
                                                            center,
                                                            Object.assign(
                                                                Vector3Utils.scale(
                                                                    VECTOR3_ONE,
                                                                    50
                                                                ),
                                                                { y: 0 }
                                                            )
                                                        )
                                                    ),
                                                });
                                                return a;
                                            })(),
                                            player.dimension
                                        ).then((tac) => {
                                            ta = tac;
                                            try {
                                                let startTime = Date.now();
                                                let a = fillBlocksHT(
                                                    center,
                                                    radius,
                                                    thickness,
                                                    "y",
                                                    player.dimension,
                                                    hsfirstblockname,
                                                    hsfirstblockstates,
                                                    {
                                                        matchingBlock: hsmatchingblock[0],
                                                        matchingBlockStates: hsmatchingblock[1],
                                                    },
                                                    undefined,
                                                    hsreplacemode
                                                );
                                                let endTime = Date.now();
                                                player.sendMessageB(
                                                    `${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`
                                                );
                                            } catch (e) {
                                                player.sendError(
                                                    "§c" + e + e.stack,
                                                    true
                                                );
                                            } finally {
                                                tac.forEach((tab) => tab?.remove()
                                                );
                                            }
                                        });
                                    } catch (e) {
                                        player.sendError(
                                            "§c" + e + e.stack,
                                            true
                                        );
                                    }
                                });
                                break;
                            case "cylinderxz":
                                system.run(() => {
                                    let ta: Entity[];
                                    try {
                                        generateTickingAreaFillCoordinatesC(
                                            player.location,
                                            (() => {
                                                let a = new CompoundBlockVolume();
                                                a.pushVolume({
                                                    volume: new BlockVolume(
                                                        Vector3Utils.subtract(
                                                            center,
                                                            Object.assign(
                                                                Vector3Utils.scale(
                                                                    VECTOR3_ONE,
                                                                    50
                                                                ),
                                                                { y: 0 }
                                                            )
                                                        ),
                                                        Vector3Utils.add(
                                                            center,
                                                            Object.assign(
                                                                Vector3Utils.scale(
                                                                    VECTOR3_ONE,
                                                                    50
                                                                ),
                                                                { y: 0 }
                                                            )
                                                        )
                                                    ),
                                                });
                                                return a;
                                            })(),
                                            player.dimension
                                        ).then((tac) => {
                                            ta = tac;
                                            try {
                                                let startTime = Date.now();
                                                let a = fillBlocksHT(
                                                    center,
                                                    radius,
                                                    thickness,
                                                    "z",
                                                    player.dimension,
                                                    hsfirstblockname,
                                                    hsfirstblockstates,
                                                    {
                                                        matchingBlock: hsmatchingblock[0],
                                                        matchingBlockStates: hsmatchingblock[1],
                                                    },
                                                    undefined,
                                                    hsreplacemode
                                                );
                                                let endTime = Date.now();
                                                player.sendMessageB(
                                                    `${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`
                                                );
                                            } catch (e) {
                                                player.sendError(
                                                    "§c" + e + e.stack,
                                                    true
                                                );
                                            } finally {
                                                tac.forEach((tab) => tab?.remove()
                                                );
                                            }
                                        });
                                    } catch (e) {
                                        player.sendError(
                                            "§c" + e + e.stack,
                                            true
                                        );
                                    }
                                });
                                break;
                            case "cylinderxyz":
                                system.run(() => {
                                    let ta: Entity[];
                                    try {
                                        generateTickingAreaFillCoordinatesC(
                                            player.location,
                                            (() => {
                                                let a = new CompoundBlockVolume();
                                                a.pushVolume({
                                                    volume: new BlockVolume(
                                                        Vector3Utils.subtract(
                                                            center,
                                                            Object.assign(
                                                                Vector3Utils.scale(
                                                                    VECTOR3_ONE,
                                                                    50
                                                                ),
                                                                { y: 0 }
                                                            )
                                                        ),
                                                        Vector3Utils.add(
                                                            center,
                                                            Object.assign(
                                                                Vector3Utils.scale(
                                                                    VECTOR3_ONE,
                                                                    50
                                                                ),
                                                                { y: 0 }
                                                            )
                                                        )
                                                    ),
                                                });
                                                return a;
                                            })(),
                                            player.dimension
                                        ).then((tac) => {
                                            ta = tac;
                                            try {
                                                let startTime = Date.now();
                                                let a = fillBlocksHT(
                                                    center,
                                                    radius,
                                                    thickness,
                                                    "z",
                                                    player.dimension,
                                                    hsfirstblockname,
                                                    hsfirstblockstates,
                                                    {
                                                        matchingBlock: hsmatchingblock[0],
                                                        matchingBlockStates: hsmatchingblock[1],
                                                    },
                                                    undefined,
                                                    hsreplacemode
                                                );
                                                let endTime = Date.now();
                                                player.sendMessageB(
                                                    `${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`
                                                );
                                            } catch (e) {
                                                player.sendError(
                                                    "§c" + e + e.stack,
                                                    true
                                                );
                                            } finally {
                                                tac.forEach((tab) => tab?.remove()
                                                );
                                            }
                                        });
                                    } catch (e) {
                                        player.sendError(
                                            "§c" + e + e.stack,
                                            true
                                        );
                                    }
                                });
                                break;
                            case "hourglass":
                                player.sendMessageB("§eComing Soon!");
                                break;
                            case "cube":
                                system.run(() => {
                                    let ta: Entity[];
                                    try {
                                        generateTickingAreaFillCoordinatesC(
                                            player.location,
                                            (() => {
                                                let a = new CompoundBlockVolume();
                                                a.pushVolume({
                                                    volume: new BlockVolume(
                                                        coordinatesa,
                                                        coordinatesb
                                                    ),
                                                });
                                                return a;
                                            })(),
                                            player.dimension
                                        ).then((tac) => {
                                            ta = tac;
                                            try {
                                                let startTime = Date.now();
                                                if (replacemode) {
                                                    clearAllContainerBlocks(
                                                        scanForContainerBlocks(
                                                            coordinatesa,
                                                            coordinatesb,
                                                            player.dimension,
                                                            "Block"
                                                        ) as Block[]
                                                    );
                                                }
                                                let a = fillBlocksH(
                                                    coordinatesa,
                                                    coordinatesb,
                                                    player.dimension,
                                                    firstblockname,
                                                    firstblockstates,
                                                    {
                                                        matchingBlock: matchingblock[0],
                                                        matchingBlockStates: matchingblock[1],
                                                    }
                                                );
                                                let endTime = Date.now();
                                                player.sendMessageB(
                                                    `${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`
                                                );
                                            } catch (e) {
                                                player.sendError(
                                                    "§c" + e + e.stack,
                                                    true
                                                );
                                            } finally {
                                                tac.forEach((tab) => tab?.remove()
                                                );
                                            }
                                        });
                                    } catch (e) {
                                        player.sendError(
                                            "§c" + e + e.stack,
                                            true
                                        );
                                    }
                                });
                                break;
                            default:
                        }
                    }
                    //            try{system.run(()=>{player.dimension.fillBlocks(evaluateCoordinates(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[0][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[1][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[2][0], player.location, player.getRotation()), evaluateCoordinates(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[3][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[4][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0], player.location, player.getRotation()), BlockPermutation.resolve(switchTestB.split(" ").slice(1).join(" ").slice(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5].index+Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0].indexOf(" ")+1).split(" ")[0], extractJSONStrings(switchTestB.split(" ").slice(1).join(" ").slice(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5].index+Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0].indexOf(" ")).split(" ").slice(1).join(" "), false)[0]), {matchingBlock: BlockPermutation.resolve(getParametersFromString(switchTestB.split(" ").slice(1).join(" ").slice(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5].index+Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0].indexOf(" ")+1)).results[2], extractJSONStrings(switchTestB.split(" ").slice(1).join(" ").slice(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5].index+Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0].indexOf(" ")).split(" ").slice(1).join(" "), false)[1])}); }); }catch(e){player.sendError("§c" + e + e.stack, true)}
                }
                break;
            case !!switchTest.match(/^\\idtfill$/):
                {
                    eventData.cancel = true;
                    eventData.cancel = true;
                    if (switchTestB.trim().split(" ").length == 1) {
                        player.sendMessageB(`idtfill command format: 
${command.dp}\\idtfill <integrity: float> <tileName: Block> <blockStates: block states> <ifillMode: replace|fill|cube|keep|walls|hollow|outline|pillars§c|floor|ceilling|diamond|hourglass§r> <replaceTileName: Block> [replaceBlockStates: block states] [clearContainers: boolean]
${command.dp}\\idtfill <integrity: float> <tileName: Block> <blockStates: block states> <ifillMode: replace|fill|cube|keep|walls|hollow|outline|pillars§c|floor|ceilling|diamond|hourglass§r> <reaplceTileName: Block> [clearContainers: boolean]
${command.dp}\\idtfill <integrity: float> <tileName: Block> <blockStates: block states> [ifillMode: replace|fill|cube|keep|walls|hollow|outline|pillars§c|floor|ceilling|diamond|hourglass§r] [clearContainers: boolean]
${command.dp}\\idtfill <integrity: float> <tileName: Block> <blockStates: block states> [clearContainers: boolean]
${command.dp}\\idtfill <integrity: float> <tileName: Block> <ifillMode: replace|fill|cube|keep|walls|hollow|outline|pillars§c|floor|ceilling|diamond|hourglass§r> <replaceTileName: Block> [replaceBlockStates: block states] [clearContainers: boolean]
${command.dp}\\idtfill <integrity: float> <tileName: Block> <ifillMode: replace|fill|cube|keep|walls|hollow|outline|pillars§c|floor|ceilling|diamond|hourglass§r> <reaplceTileName: Block> [clearContainers: boolean]
${command.dp}\\idtfill <integrity: float> <tileName: Block> [ifillMode: replace|fill|cube|keep|walls|hollow|outline|pillars§c|floor|ceilling|diamond|hourglass§r] [clearContainers: boolean]
${command.dp}\\idtfill <integrity: float> <tileName: Block> [clearContainers: boolean]
${command.dp}\\idtfill <integrity: float> <skygridSize: float> <tileName: Block> <blockStates: block states> <mode: skygrid|inverseskygrid> <replaceTileName: Block> [replaceBlockStates: block states] [clearContainers: boolean]
${command.dp}\\idtfill <integrity: float> <skygridSize: float> <tileName: Block> <blockStates: block states> <mode: skygrid|inverseskygrid> <reaplceTileName: Block> [clearContainers: boolean]
${command.dp}\\idtfill <integrity: float> <skygridSize: float> <tileName: Block> <blockStates: block states> <mode: skygrid|inverseskygrid> [clearContainers: boolean]
${command.dp}\\idtfill <integrity: float> <skygridSize: float> <tileName: Block> <blockStates: block states> <mode: skygrid|inverseskygrid> [clearContainers: boolean]
${command.dp}\\idtfill <integrity: float> <skygridSize: float> <tileName: Block> <mode: skygrid|inverseskygrid> <replaceTileName: Block> [replaceBlockStates: block states] [clearContainers: boolean]
${command.dp}\\idtfill <integrity: float> <skygridSize: float> <tileName: Block> <mode: skygrid|inverseskygrid> <reaplceTileName: Block> [clearContainers: boolean]
${command.dp}\\idtfill <integrity: float> <skygridSize: float> <tileName: Block> <mode: skygrid|inverseskygrid> [clearContainers: boolean]
${command.dp}\\idtfill <integrity: float> <tileName: Block> [clearContainers: boolean]
${command.dp}\\idtfill <integrity: float> clear [clearContainers: boolean]
${command.dp}\\idtfill <integrity: float> drain
${command.dp}\\idtfill <integrity: float> <axis: {x}|{y}|{z}|{xy}|{yz}|{xz}|{xyz}> <tileName: Block> <blockStates: block states> circle [replaceTileName: Block] [replaceBlockStates: block states] [clearContainers: boolean]
${command.dp}\\idtfill <integrity: float> <axis: {x}|{y}|{z}|{xy}|{yz}|{xz}|{xyz}> <tileName: Block> <blockStates: block states> circle [replaceTileName: Block] [clearContainers: boolean]
${command.dp}\\idtfill <integrity: float> <axis: {x}|{y}|{z}|{xy}|{yz}|{xz}|{xyz}> <tileName: Block> <blockStates: block states> circle [clearContainers: boolean]
${command.dp}\\idtfill <integrity: float> <axis: {x}|{y}|{z}|{xy}|{yz}|{xz}|{xyz}> <tileName: Block> circle [replaceTileName: Block] [replaceBlockStates: block states] [clearContainers: boolean]
${command.dp}\\idtfill <integrity: float> <axis: {x}|{y}|{z}|{xy}|{yz}|{xz}|{xyz}> <tileName: Block> circle [replaceTileName: Block] [clearContainers: boolean]
${command.dp}\\idtfill <integrity: float> <axis: {x}|{y}|{z}|{xy}|{yz}|{xz}|{xyz}> <tileName: Block> circle [clearContainers: boolean]
${command.dp}\\idtfill <integrity: float> <tileName: Block> <blockStates: block states> <mode: {circlex}|{circley}|{circlez}|{circlexy}|{circleyz}|{circlexyz}|{sphere}|{semisphere}> <replaceTileName: Block> [replaceBlockStates: block states] [clearContainers: boolean]
${command.dp}\\idtfill <integrity: float> <tileName: Block> <blockStates: block states> <mode: {circlex}|{circley}|{circlez}|{circlexy}|{circleyz}|{circlexyz}|{sphere}|{semisphere}> <replaceTileName: Block> [clearContainers: boolean]
${command.dp}\\idtfill <integrity: float> <tileName: Block> <blockStates: block states> <mode: {circlex}|{circley}|{circlez}|{circlexy}|{circleyz}|{circlexyz}|{sphere}|{semisphere}> [clearContainers: boolean]
${command.dp}\\idtfill <integrity: float> <tileName: Block> <mode: {circlex}|{circley}|{circlez}|{circlexy}|{circleyz}|{circlexyz}|{sphere}|{semisphere}> <replaceTileName: Block> [replaceBlockStates: block states] [clearContainers: boolean]
${command.dp}\\idtfill <integrity: float> <tileName: Block> <mode: {circlex}|{circley}|{circlez}|{circlexy}|{circleyz}|{circlexyz}|{sphere}|{semisphere}> <replaceTileName: Block> [clearContainers: boolean]
${command.dp}\\idtfill <integrity: float> <tileName: Block> <mode: {circlex}|{circley}|{circlez}|{circlexy}|{circleyz}|{circlexyz}|{sphere}|{semisphere}> [clearContainers: boolean]
${command.dp}\\idtfill <integrity: float> <thickness: float> <tileName: Block> <blockStates: block states> <mode: hollowsphere|dome> <replaceTileName: Block> [replaceBlockStates: block states] [clearContainers: boolean]
${command.dp}\\idtfill <integrity: float> <thickness: float> <tileName: Block> <blockStates: block states> <mode: hollowsphere|dome> <replaceTileName: Block> [clearContainers: boolean]
${command.dp}\\idtfill <integrity: float> <thickness: float> <tileName: Block> <blockStates: block states> <mode: hollowsphere|dome> [clearContainers: boolean]
${command.dp}\\idtfill <integrity: float> <thickness: float> <tileName: Block> <mode: hollowsphere|dome> <replaceTileName: Block> [replaceBlockStates: block states] [clearContainers: boolean]
${command.dp}\\idtfill <integrity: float> <thickness: float> <tileName: Block> <mode: hollowsphere|dome> <replaceTileName: Block> [clearContainers: boolean]
${command.dp}\\idtfill <integrity: float> <thickness: float> <tileName: Block> <mode: hollowsphere|dome> [clearContainers: boolean]
${command.dp}\\idtfill <integrity: float> <length: float> <tileName: Block> <blockStates: block states> <mode: cylinderx|cylindery|cylinderz|cylinderxy|cylinderyz|cylinderxz|cylinderxyz> <replaceTileName: Block> [replaceBlockStates: block states] [clearContainers: boolean]
${command.dp}\\idtfill <integrity: float> <length: float> <tileName: Block> <blockStates: block states> <mode: cylinderx|cylindery|cylinderz|cylinderxy|cylinderyz|cylinderxz|cylinderxyz> <replaceTileName: Block> [clearContainers: boolean]
${command.dp}\\idtfill <integrity: float> <length: float> <tileName: Block> <blockStates: block states> <mode: cylinderx|cylindery|cylinderz|cylinderxy|cylinderyz|cylinderxz|cylinderxyz> [clearContainers: boolean]
${command.dp}\\idtfill <integrity: float> <length: float> <tileName: Block> <mode: cylinderx|cylindery|cylinderz|cylinderxy|cylinderyz|cylinderxz|cylinderxyz> <replaceTileName: Block> [replaceBlockStates: block states] [clearContainers: boolean]
${command.dp}\\idtfill <integrity: float> <length: float> <tileName: Block> <mode: cylinderx|cylindery|cylinderz|cylinderxy|cylinderyz|cylinderxz|cylinderxyz> <replaceTileName: Block> [clearContainers: boolean]
${command.dp}\\idtfill <integrity: float> <length: float> <tileName: Block> <mode: cylinderx|cylindery|cylinderz|cylinderxy|cylinderyz|cylinderxz|cylinderxyz> [clearContainers: boolean]
${command.dp}\\idtfill <integrity: float> <length: float> <axis: {x}|{y}|{z}|{xy}|{yz}|{xz}|{xyz}> <tileName: Block> <blockStates: block states> <mode: tunnel|cylinder> [replaceTileName: Block] [replaceBlockStates: block states] [clearContainers: boolean]
${command.dp}\\idtfill <integrity: float> <length: float> <axis: {x}|{y}|{z}|{xy}|{yz}|{xz}|{xyz}> <tileName: Block> <blockStates: block states> <mode: tunnel|cylinder> [replaceTileName: Block] [clearContainers: boolean]
${command.dp}\\idtfill <integrity: float> <length: float> <axis: {x}|{y}|{z}|{xy}|{yz}|{xz}|{xyz}> <tileName: Block> <blockStates: block states> <mode: tunnel|cylinder> [clearContainers: boolean]
${command.dp}\\idtfill <integrity: float> <length: float> <axis: {x}|{y}|{z}|{xy}|{yz}|{xz}|{xyz}> <tileName: Block> <mode: tunnel|cylinder> [replaceTileName: Block] [replaceBlockStates: block states] [clearContainers: boolean]
${command.dp}\\idtfill <integrity: float> <length: float> <axis: {x}|{y}|{z}|{xy}|{yz}|{xz}|{xyz}> <tileName: Block> <mode: tunnel|cylinder> [replaceTileName: Block] [clearContainers: boolean]
${command.dp}\\idtfill <integrity: float> <length: float> <axis: {x}|{y}|{z}|{xy}|{yz}|{xz}|{xyz}> <tileName: Block> <mode: tunnel|cylinder> [clearContainers: boolean]
${command.dp}\\idtfill <offsetx: float> <offsety: float> <offsetz: float> <integrity: float> <thickness: float> <tileName: Block> <blockStates: block states> hollowovoid [replaceTileName: Block] [replaceBlockStates: block states] [clearContainers: boolean]
${command.dp}\\idtfill <offsetx: float> <offsety: float> <offsetz: float> <integrity: float> <thickness: float> <tileName: Block> <blockStates: block states> hollowovoid [replaceTileName: Block] [clearContainers: boolean]
${command.dp}\\idtfill <offsetx: float> <offsety: float> <offsetz: float> <integrity: float> <thickness: float> <tileName: Block> <blockStates: block states> hollowovoid [clearContainers: boolean]
${command.dp}\\idtfill <offsetx: float> <offsety: float> <offsetz: float> <integrity: float> <thickness: float> <tileName: Block> hollowovoid [replaceTileName: Block] [replaceBlockStates: block states] [clearContainers: boolean]
${command.dp}\\idtfill <offsetx: float> <offsety: float> <offsetz: float> <integrity: float> <thickness: float> <tileName: Block> hollowovoid [replaceTileName: Block] [clearContainers: boolean]
${command.dp}\\idtfill <offsetx: float> <offsety: float> <offsetz: float> <integrity: float> <thickness: float> <tileName: Block> hollowovoid [clearContainers: boolean]`);
                    } else {
                        let argsa = evaluateParameters(switchTestB, [
                            "presetText",
                            "number",
                            "string",
                            "blockStates",
                            "presetText",
                            "non-booleanString",
                            "blockStates",
                            "neboolean",
                        ]);
                        let argsb = evaluateParameters(switchTestB, [
                            "presetText",
                            "number",
                            "string",
                            "presetText",
                            "blockStates",
                            "presetText",
                            "non-booleanString",
                            "blockStates",
                            "neboolean",
                        ]);
                        let argsd = evaluateParameters(switchTestB, [
                            "presetText",
                            "number",
                            "string",
                            "blockStates",
                            "presetText",
                            "non-booleanString",
                            "blockStates",
                            "neboolean",
                        ]);
                        let argsf = evaluateParameters(switchTestB, [
                            "presetText",
                            "number",
                            "number",
                            "string",
                            "blockStates",
                            "presetText",
                            "non-booleanString",
                            "blockStates",
                            "neboolean",
                        ]);
                        let argsh = evaluateParameters(switchTestB, [
                            "presetText",
                            "number",
                            "string",
                            "string",
                            "blockStates",
                            "presetText",
                            "non-booleanString",
                            "blockStates",
                            "neboolean",
                        ]);
                        let argsj = evaluateParameters(switchTestB, [
                            "presetText",
                            "number",
                            "number",
                            "number",
                            "number",
                            "number",
                            "string",
                            "blockStates",
                            "presetText",
                            "non-booleanString",
                            "blockStates",
                            "neboolean",
                        ]);
                        let argsl = evaluateParameters(switchTestB, [
                            "presetText",
                            "number",
                            "number",
                            "number",
                            "number",
                            "string",
                            "blockStates",
                            "presetText",
                            "non-booleanString",
                            "blockStates",
                            "neboolean",
                        ]);
                        let argsn = evaluateParameters(switchTestB, [
                            "presetText",
                            "number",
                            "number",
                            "string",
                            "blockStates",
                            "presetText",
                            "non-booleanString",
                            "blockStates",
                            "neboolean",
                        ]);
                        //console.warn(argsh.args)
                        let args = argsa.args;
                        let argsc = argsb.args;
                        let argse = argsd.args;
                        let argsg = argsf.args;
                        let argsi = argsh.args;
                        let argsk = argsj.args;
                        let argsm = argsl.args;
                        let argso = argsn.args;
                        let argsaextra = argsa.extra;
                        let argsbextra = argsb.extra;
                        let argsdextra = argsd.extra;
                        let argsfextra = argsf.extra;
                        let argshextra = argsh.extra;
                        let argsjextra = argsj.extra;
                        let argslextra = argsl.extra;
                        let argsnextra = argsn.extra;
                        //console.warn(JSONStringify(args), JSONStringify(argsaextra))
                        let center = player.getDynamicProperty(
                            "pos1"
                        ) as Vector3; //evaluateCoordinates(argsc[1], argsc[2], argsc[3], roundVector3ToMiddleOfBlock(player.location), player.getRotation());
                        let radius = Vector.distance(
                            player.getDynamicProperty("pos1") as Vector3,
                            player.getDynamicProperty("pos2") as Vector3
                        );
                        let cintegrity = argsc[1];
                        let axis = argsc[2];
                        let cfirstblockname = argsc[3];
                        let cfirstblockstates = argsc[4];
                        let cmode = argsc[5] as string;
                        let clastblockname = argsc[6];
                        let clastblockstates = argsc[7];
                        let creplacemode = argsc[8] ?? false;
                        let ccfirstblockname = argse[2];
                        let ccfirstblockstates = argse[3];
                        let ccmode = argse[4] as string;
                        let cclastblockname = argse[5];
                        let cclastblockstates = argse[6];
                        let ccreplacemode = argse[7] ?? false;
                        let thickness = argsg[2];
                        let hsfirstblockname = argsg[3];
                        let hsfirstblockstates = argsg[4];
                        let hsmode = argsg[5] as string;
                        let hslastblockname = argsg[6];
                        let hslastblockstates = argsg[7];
                        let hsreplacemode = argsg[8] ?? false;
                        let tintegrity = argsi[1];
                        let taxis = argsi[2];
                        let tfirstblockname = argsi[3];
                        let tfirstblockstates = argsi[4];
                        let tmode = argsi[5] as string;
                        let tlastblockname = argsi[6];
                        let tlastblockstates = argsi[7];
                        let treplacemode = argsi[8] ?? false;
                        let sgskygridsize = argso[2];
                        let sgfirstblockname = argso[3];
                        let sgfirstblockstates = argso[4];
                        let sgmode = argso[5] as string;
                        let sglastblockname = argso[6];
                        let sglastblockstates = argso[7];
                        let sgreplacemode = argso[8] ?? false;
                        let circlemode = false;
                        new Date(Date.now()).getMilliseconds();
                        let ccirclemode = false;
                        let hspheremode = false;
                        let tunnelmode = false;
                        let ovoidmode = false;
                        let hovoidmode = false;
                        let skygridmode = false;
                        if (["circle"].includes(
                            fillmodetypeenum[argsc[5] ??
                            "undefined"?.toLowerCase()?.trim()]
                        )) {
                            circlemode = true;
                        }
                        if ([
                            "circlex",
                            "circley",
                            "circlez",
                            "circlexy",
                            "circleyz",
                            "circlexz",
                            "circlexyz",
                            "sphere",
                            "semisphere",
                        ].includes(
                            fillmodetypeenum[argse[4] ??
                            "undefined"?.toLowerCase()?.trim()]
                        )) {
                            ccirclemode = true;
                        }
                        if ([
                            "hollowsphere",
                            "cylinderx",
                            "cylindery",
                            "cylinderz",
                            "cylinderxy",
                            "cylinderyz",
                            "cylinderxz",
                            "cylinderxyz",
                            "dome",
                        ].includes(
                            fillmodetypeenum[argsg[5] ??
                            "undefined"?.toLowerCase()?.trim()]
                        )) {
                            hspheremode = true;
                        }
                        if (["tunnel", "cylinder"].includes(
                            fillmodetypeenum[argsi[5] ??
                            "undefined"?.toLowerCase()?.trim()]
                        )) {
                            tunnelmode = true;
                        }
                        if (["ovoid"].includes(
                            fillmodetypeenum[argsm[7] ??
                            "undefined"?.toLowerCase()?.trim()]
                        )) {
                            ovoidmode = true;
                        }
                        if (["hollowovoid"].includes(
                            fillmodetypeenum[argsk[8] ??
                            "undefined"?.toLowerCase()?.trim()]
                        )) {
                            hovoidmode = true;
                        }
                        if (["skygrid", "inverseskygrid"].includes(
                            fillmodetypeenum[argso[5] ??
                            "undefined"?.toLowerCase()?.trim()]
                        )) {
                            skygridmode = true;
                        }
                        let coordinatesa: Vector3; /*
            console.warn(circlemode, ccirclemode, hspheremode)*/

                        if (!circlemode &&
                            !ccirclemode &&
                            !hspheremode &&
                            !tunnelmode) {
                            coordinatesa = player.getDynamicProperty(
                                "pos1"
                            ) as Vector3; /*evaluateCoordinates(args[1], args[2], args[3], roundVector3ToMiddleOfBlock(player.location), player.getRotation()); */
                        }
                        let coordinatesb: Vector3;
                        if (!circlemode &&
                            !ccirclemode &&
                            !hspheremode &&
                            !tunnelmode) {
                            coordinatesb = player.getDynamicProperty(
                                "pos2"
                            ) as Vector3; /*evaluateCoordinates(args[4], args[5], args[6], roundVector3ToMiddleOfBlock(player.location), player.getRotation()); */
                        }
                        let horadi: Vector3;
                        let hooffset: Vector3;
                        let hointegrity = argsk[4];
                        let hothickness = argsk[5];
                        let hofirstblockname = argsk[6];
                        let hofirstblockstates = argsk[7];
                        let homode = argsk[8] as string;
                        let holastblockname = argsk[9];
                        let holastblockstates = argsk[10];
                        let horeplacemode = argsk[11] ?? false;
                        if (hovoidmode) {
                            const oradia = Vector.subtract(
                                player.getDynamicProperty("pos1") as Vector3,
                                player.getDynamicProperty("pos2") as Vector3
                            );
                            horadi = {
                                x: Math.abs(oradia.x),
                                y: Math.abs(oradia.y),
                                z: Math.abs(oradia.z),
                            };
                            hooffset = Vector.add(
                                { x: argsk[1], y: argsk[2], z: argsk[3] },
                                center
                            );
                        }
                        let oradi: Vector3;
                        let ooffset: Vector3;
                        let ointegrity = argsk[4];
                        let ofirstblockname = argsm[5];
                        let ofirstblockstates = argsm[6];
                        let omode = argsm[7] as string;
                        let olastblockname = argsm[8];
                        let olastblockstates = argsm[9];
                        let oreplacemode = argsm[10] ?? false;
                        if (ovoidmode) {
                            const oradia = Vector.subtract(
                                player.getDynamicProperty("pos1") as Vector3,
                                player.getDynamicProperty("pos2") as Vector3
                            );
                            oradi = {
                                x: Math.abs(oradia.x),
                                y: Math.abs(oradia.y),
                                z: Math.abs(oradia.z),
                            };
                            ooffset = Vector.add(
                                { x: argsm[1], y: argsm[2], z: argsm[3] },
                                center
                            );
                        }
                        let integrity = args[1];
                        let firstblockname = args[2];
                        let firstblockstates = args[3];
                        let mode = args[4] as string;
                        let lastblockname = args[5];
                        let lastblockstates = args[6];
                        let replacemode = args[7] ?? false;
                        let matchingblock: [
                            string,
                            { [id: string]: string | number | boolean; }?
                        ] = (lastblockname ?? "") == ""
                                ? [undefined, undefined]
                                : lastblockname == "keep" || mode == "keep"
                                    ? ["air"]
                                    : [
                                        BlockTypes.get(lastblockname).id,
                                        lastblockstates,
                                    ];
                        let cmatchingblock: [
                            string,
                            { [id: string]: string | number | boolean; }?
                        ] = (clastblockname ?? "") == ""
                                ? [undefined, undefined]
                                : clastblockname == "keep"
                                    ? ["air"]
                                    : [clastblockname, clastblockstates];
                        let ccmatchingblock: [
                            string,
                            { [id: string]: string | number | boolean; }?
                        ] = (cclastblockname ?? "") == ""
                                ? [undefined, undefined]
                                : cclastblockname == "keep"
                                    ? ["air"]
                                    : [cclastblockname, cclastblockstates];
                        let hsmatchingblock: [
                            string,
                            { [id: string]: string | number | boolean; }?
                        ] = (hslastblockname ?? "") == ""
                                ? [undefined, undefined]
                                : hslastblockname == "keep"
                                    ? ["air"]
                                    : [hslastblockname, hslastblockstates];
                        let tmatchingblock: [
                            string,
                            { [id: string]: string | number | boolean; }?
                        ] = (tlastblockname ?? "") == ""
                                ? [undefined, undefined]
                                : tlastblockname == "keep"
                                    ? ["air"]
                                    : [tlastblockname, tlastblockstates];
                        let omatchingblock: [
                            string,
                            { [id: string]: string | number | boolean; }?
                        ] = (olastblockname ?? "") == ""
                                ? [undefined, undefined]
                                : olastblockname == "keep"
                                    ? ["air"]
                                    : [olastblockname, olastblockstates];
                        let homatchingblock: [
                            string,
                            { [id: string]: string | number | boolean; }?
                        ] = (holastblockname ?? "") == ""
                                ? [undefined, undefined]
                                : holastblockname == "keep"
                                    ? ["air"]
                                    : [holastblockname, holastblockstates];
                        let sgmatchingblock: [
                            string,
                            { [id: string]: string | number | boolean; }?
                        ] = (sglastblockname ?? "") == ""
                                ? [undefined, undefined]
                                : sglastblockname == "keep"
                                    ? ["air"]
                                    : [sglastblockname, sglastblockstates];
                        const blocktypes = BlockTypes.getAll(); /*
            console.warn(JSONStringify({coordinatesa, coordinatesb, firstblockname, firstblocknameindex, reststringaftercoordinates, firstblockstates, lastblockname, somethingtest, lastblockstates, matchingblock}))*/

                        switch (fillmodetypeenum[skygridmode
                            ? sgmode
                            : hovoidmode
                                ? homode
                                : ovoidmode
                                    ? omode
                                    : tunnelmode
                                        ? tmode
                                        : hspheremode
                                            ? hsmode
                                            : circlemode
                                                ? cmode
                                                : ccirclemode
                                                    ? ccmode
                                                    : mode ?? ""]) {
                            case "":
                                system.run(() => {
                                    let ta: Entity[];
                                    try {
                                        generateTickingAreaFillCoordinatesC(
                                            player.location,
                                            (() => {
                                                let a = new CompoundBlockVolume();
                                                a.pushVolume({
                                                    volume: new BlockVolume(
                                                        coordinatesa,
                                                        coordinatesb
                                                    ),
                                                });
                                                return a;
                                            })(),
                                            player.dimension
                                        ).then((tac) => {
                                            ta = tac;
                                            try {
                                                fillBlocksHFG(
                                                    coordinatesa,
                                                    coordinatesb,
                                                    player.dimension,
                                                    firstblockname == "random"
                                                        ? () => blocktypes[Math.floor(
                                                            blocktypes.length *
                                                            Math.random()
                                                        )]
                                                        : firstblockname,
                                                    firstblockstates,
                                                    {
                                                        matchingBlock: matchingblock[0],
                                                        matchingBlockStates: matchingblock[1],
                                                        minMSBetweenYields: 5000,
                                                    },
                                                    undefined,
                                                    replacemode,
                                                    integrity
                                                ).then(
                                                    (a) => {
                                                        player.sendMessageB(
                                                            `${a.counter == 0
                                                                ? "§c"
                                                                : ""}${a.counter} blocks filled in ${a.completionData
                                                                .endTime -
                                                            a.completionData
                                                                .startTime} ms over ${a.completionData
                                                                .endTick -
                                                            a.completionData
                                                                .startTick} tick${a.completionData
                                                                .endTick -
                                                                a
                                                                    .completionData
                                                                    .startTick ==
                                                                1
                                                                ? ""
                                                                : "s"}${a.completionData
                                                                .containsUnloadedChunks
                                                                ? "; Some blocks were not generated because they were in unloaded chunks. "
                                                                : ""}`
                                                        );
                                                    },
                                                    (e) => {
                                                        player.sendError(
                                                            "§c" + e + e.stack,
                                                            true
                                                        );
                                                    }
                                                );
                                            } catch (e) {
                                                player.sendError(
                                                    "§c" + e + e.stack,
                                                    true
                                                );
                                            } finally {
                                                tac.forEach((tab) => tab?.remove()
                                                );
                                            }
                                        });
                                    } catch (e) {
                                        player.sendError(
                                            "§c" + e + e.stack,
                                            true
                                        );
                                    }
                                });
                                break;
                            case "replace":
                                system.run(() => {
                                    let ta: Entity[];
                                    try {
                                        generateTickingAreaFillCoordinatesC(
                                            player.location,
                                            (() => {
                                                let a = new CompoundBlockVolume();
                                                a.pushVolume({
                                                    volume: new BlockVolume(
                                                        coordinatesa,
                                                        coordinatesb
                                                    ),
                                                });
                                                return a;
                                            })(),
                                            player.dimension
                                        ).then((tac) => {
                                            ta = tac;
                                            try {
                                                fillBlocksHFG(
                                                    coordinatesa,
                                                    coordinatesb,
                                                    player.dimension,
                                                    firstblockname == "random"
                                                        ? () => blocktypes[Math.floor(
                                                            blocktypes.length *
                                                            Math.random()
                                                        )]
                                                        : firstblockname,
                                                    firstblockstates,
                                                    {
                                                        matchingBlock: matchingblock[0],
                                                        matchingBlockStates: matchingblock[1],
                                                        minMSBetweenYields: 5000,
                                                    },
                                                    undefined,
                                                    args[7] ?? true,
                                                    integrity
                                                ).then(
                                                    (a) => {
                                                        player.sendMessageB(
                                                            `${a.counter == 0
                                                                ? "§c"
                                                                : ""}${a.counter} blocks filled in ${a.completionData
                                                                .endTime -
                                                            a.completionData
                                                                .startTime} ms over ${a.completionData
                                                                .endTick -
                                                            a.completionData
                                                                .startTick} tick${a.completionData
                                                                .endTick -
                                                                a
                                                                    .completionData
                                                                    .startTick ==
                                                                1
                                                                ? ""
                                                                : "s"}${a.completionData
                                                                .containsUnloadedChunks
                                                                ? "; Some blocks were not generated because they were in unloaded chunks. "
                                                                : ""}`
                                                        );
                                                    },
                                                    (e) => {
                                                        player.sendError(
                                                            "§c" + e + e.stack,
                                                            true
                                                        );
                                                    }
                                                );
                                            } catch (e) {
                                                player.sendError(
                                                    "§c" + e + e.stack,
                                                    true
                                                );
                                            } finally {
                                                tac.forEach((tab) => tab?.remove()
                                                );
                                            }
                                        });
                                    } catch (e) {
                                        player.sendError(
                                            "§c" + e + e.stack,
                                            true
                                        );
                                    }
                                });
                                break;
                            case "clear":
                                system.run(() => {
                                    let ta: Entity[];
                                    try {
                                        generateTickingAreaFillCoordinatesC(
                                            player.location,
                                            (() => {
                                                let a = new CompoundBlockVolume();
                                                a.pushVolume({
                                                    volume: new BlockVolume(
                                                        coordinatesa,
                                                        coordinatesb
                                                    ),
                                                });
                                                return a;
                                            })(),
                                            player.dimension
                                        ).then((tac) => {
                                            ta = tac;
                                            try {
                                                let startTime = Date.now();
                                                if (replacemode) {
                                                    clearAllContainerBlocks(
                                                        scanForContainerBlocks(
                                                            coordinatesa,
                                                            coordinatesb,
                                                            player.dimension,
                                                            "Block"
                                                        ) as Block[]
                                                    );
                                                }
                                                let a = fillBlocksH(
                                                    coordinatesa,
                                                    coordinatesb,
                                                    player.dimension,
                                                    "air"
                                                );
                                                let endTime = Date.now();
                                                player.sendMessageB(
                                                    `${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`
                                                );
                                            } catch (e) {
                                                player.sendError(
                                                    "§c" + e + e.stack,
                                                    true
                                                );
                                            } finally {
                                                tac.forEach((tab) => tab?.remove()
                                                );
                                            }
                                        });
                                    } catch (e) {
                                        player.sendError(
                                            "§c" + e + e.stack,
                                            true
                                        );
                                    }
                                });
                                break;
                            case "drain":
                                system.run(() => {
                                    let ta: Entity[];
                                    try {
                                        generateTickingAreaFillCoordinatesC(
                                            player.location,
                                            (() => {
                                                let a = new CompoundBlockVolume();
                                                a.pushVolume({
                                                    volume: new BlockVolume(
                                                        coordinatesa,
                                                        coordinatesb
                                                    ),
                                                });
                                                return a;
                                            })(),
                                            player.dimension
                                        ).then((tac) => {
                                            ta = tac;
                                            try {
                                                let startTime = Date.now();
                                                let a = fillBlocksH(
                                                    coordinatesa,
                                                    coordinatesb,
                                                    player.dimension,
                                                    "air",
                                                    undefined,
                                                    { matchingBlock: "water" }
                                                );
                                                let endTime = Date.now();
                                                player.sendMessageB(
                                                    `${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`
                                                );
                                            } catch (e) {
                                                player.sendError(
                                                    "§c" + e + e.stack,
                                                    true
                                                );
                                            } finally {
                                                tac.forEach((tab) => tab?.remove()
                                                );
                                            }
                                        });
                                    } catch (e) {
                                        player.sendError(
                                            "§c" + e + e.stack,
                                            true
                                        );
                                    }
                                });
                                break;
                            case "fill":
                                system.run(() => {
                                    let ta: Entity[];
                                    try {
                                        generateTickingAreaFillCoordinatesC(
                                            player.location,
                                            (() => {
                                                let a = new CompoundBlockVolume();
                                                a.pushVolume({
                                                    volume: new BlockVolume(
                                                        coordinatesa,
                                                        coordinatesb
                                                    ),
                                                });
                                                return a;
                                            })(),
                                            player.dimension
                                        ).then((tac) => {
                                            ta = tac;
                                            try {
                                                fillBlocksHFG(
                                                    coordinatesa,
                                                    coordinatesb,
                                                    player.dimension,
                                                    firstblockname == "random"
                                                        ? () => blocktypes[Math.floor(
                                                            blocktypes.length *
                                                            Math.random()
                                                        )]
                                                        : firstblockname,
                                                    firstblockstates,
                                                    {
                                                        matchingBlock: matchingblock[0],
                                                        matchingBlockStates: matchingblock[1],
                                                        minMSBetweenYields: 5000,
                                                    },
                                                    undefined,
                                                    replacemode,
                                                    integrity
                                                ).then(
                                                    (a) => {
                                                        player.sendMessageB(
                                                            `${a.counter == 0
                                                                ? "§c"
                                                                : ""}${a.counter} blocks filled in ${a.completionData
                                                                .endTime -
                                                            a.completionData
                                                                .startTime} ms over ${a.completionData
                                                                .endTick -
                                                            a.completionData
                                                                .startTick} tick${a.completionData
                                                                .endTick -
                                                                a
                                                                    .completionData
                                                                    .startTick ==
                                                                1
                                                                ? ""
                                                                : "s"}${a.completionData
                                                                .containsUnloadedChunks
                                                                ? "; Some blocks were not generated because they were in unloaded chunks. "
                                                                : ""}`
                                                        );
                                                    },
                                                    (e) => {
                                                        player.sendError(
                                                            "§c" + e + e.stack,
                                                            true
                                                        );
                                                    }
                                                );
                                            } catch (e) {
                                                player.sendError(
                                                    "§c" + e + e.stack,
                                                    true
                                                );
                                            } finally {
                                                tac.forEach((tab) => tab?.remove()
                                                );
                                            }
                                        });
                                    } catch (e) {
                                        player.sendError(
                                            "§c" + e + e.stack,
                                            true
                                        );
                                    }
                                });
                                break;
                            case "keep":
                                system.run(() => {
                                    let ta: Entity[];
                                    try {
                                        generateTickingAreaFillCoordinatesC(
                                            player.location,
                                            (() => {
                                                let a = new CompoundBlockVolume();
                                                a.pushVolume({
                                                    volume: new BlockVolume(
                                                        coordinatesa,
                                                        coordinatesb
                                                    ),
                                                });
                                                return a;
                                            })(),
                                            player.dimension
                                        ).then((tac) => {
                                            ta = tac;
                                            try {
                                                fillBlocksHFG(
                                                    coordinatesa,
                                                    coordinatesb,
                                                    player.dimension,
                                                    firstblockname == "random"
                                                        ? () => blocktypes[Math.floor(
                                                            blocktypes.length *
                                                            Math.random()
                                                        )]
                                                        : firstblockname,
                                                    firstblockstates,
                                                    {
                                                        matchingBlock: "air",
                                                        minMSBetweenYields: 5000,
                                                    },
                                                    undefined,
                                                    replacemode,
                                                    integrity
                                                ).then(
                                                    (a) => {
                                                        player.sendMessageB(
                                                            `${a.counter == 0
                                                                ? "§c"
                                                                : ""}${a.counter} blocks filled in ${a.completionData
                                                                .endTime -
                                                            a.completionData
                                                                .startTime} ms over ${a.completionData
                                                                .endTick -
                                                            a.completionData
                                                                .startTick} tick${a.completionData
                                                                .endTick -
                                                                a
                                                                    .completionData
                                                                    .startTick ==
                                                                1
                                                                ? ""
                                                                : "s"}${a.completionData
                                                                .containsUnloadedChunks
                                                                ? "; Some blocks were not generated because they were in unloaded chunks. "
                                                                : ""}`
                                                        );
                                                    },
                                                    (e) => {
                                                        player.sendError(
                                                            "§c" + e + e.stack,
                                                            true
                                                        );
                                                    }
                                                );
                                            } catch (e) {
                                                player.sendError(
                                                    "§c" + e + e.stack,
                                                    true
                                                );
                                            } finally {
                                                tac.forEach((tab) => tab?.remove()
                                                );
                                            }
                                        });
                                    } catch (e) {
                                        player.sendError(
                                            "§c" + e + e.stack,
                                            true
                                        );
                                    }
                                });
                                break;
                            case "walls":
                                system.run(() => {
                                    let ta: Entity[];
                                    try {
                                        generateTickingAreaFillCoordinatesC(
                                            player.location,
                                            (() => {
                                                let a = new CompoundBlockVolume();
                                                a.pushVolume({
                                                    volume: new BlockVolume(
                                                        coordinatesa,
                                                        coordinatesb
                                                    ),
                                                });
                                                return a;
                                            })(),
                                            player.dimension
                                        ).then((tac) => {
                                            ta = tac;
                                            try {
                                                fillBlocksHWG(
                                                    coordinatesa,
                                                    coordinatesb,
                                                    player.dimension,
                                                    firstblockname == "random"
                                                        ? () => blocktypes[Math.floor(
                                                            blocktypes.length *
                                                            Math.random()
                                                        )]
                                                        : firstblockname,
                                                    firstblockstates,
                                                    {
                                                        matchingBlock: matchingblock[0],
                                                        matchingBlockStates: matchingblock[1],
                                                        minMSBetweenYields: 5000,
                                                    },
                                                    undefined,
                                                    replacemode,
                                                    integrity
                                                ).then(
                                                    (a) => {
                                                        player.sendMessageB(
                                                            `${a.counter == 0
                                                                ? "§c"
                                                                : ""}${a.counter} blocks filled in ${a.completionData
                                                                .endTime -
                                                            a.completionData
                                                                .startTime} ms over ${a.completionData
                                                                .endTick -
                                                            a.completionData
                                                                .startTick} tick${a.completionData
                                                                .endTick -
                                                                a
                                                                    .completionData
                                                                    .startTick ==
                                                                1
                                                                ? ""
                                                                : "s"}${a.completionData
                                                                .containsUnloadedChunks
                                                                ? "; Some blocks were not generated because they were in unloaded chunks. "
                                                                : ""}`
                                                        );
                                                    },
                                                    (e) => {
                                                        player.sendError(
                                                            "§c" + e + e.stack,
                                                            true
                                                        );
                                                    }
                                                );
                                            } catch (e) {
                                                player.sendError(
                                                    "§c" + e + e.stack,
                                                    true
                                                );
                                            } finally {
                                                tac.forEach((tab) => tab?.remove()
                                                );
                                            }
                                        });
                                    } catch (e) {
                                        player.sendError(
                                            "§c" + e + e.stack,
                                            true
                                        );
                                    }
                                });
                                break;
                            case "hollow":
                                system.run(() => {
                                    let ta: Entity[];
                                    try {
                                        generateTickingAreaFillCoordinatesC(
                                            player.location,
                                            (() => {
                                                let a = new CompoundBlockVolume();
                                                a.pushVolume({
                                                    volume: new BlockVolume(
                                                        coordinatesa,
                                                        coordinatesb
                                                    ),
                                                });
                                                return a;
                                            })(),
                                            player.dimension
                                        ).then((tac) => {
                                            ta = tac;
                                            try {
                                                fillBlocksHHG(
                                                    coordinatesa,
                                                    coordinatesb,
                                                    player.dimension,
                                                    firstblockname == "random"
                                                        ? () => blocktypes[Math.floor(
                                                            blocktypes.length *
                                                            Math.random()
                                                        )]
                                                        : firstblockname,
                                                    firstblockstates,
                                                    {
                                                        matchingBlock: matchingblock[0],
                                                        matchingBlockStates: matchingblock[1],
                                                        minMSBetweenYields: 5000,
                                                    },
                                                    undefined,
                                                    replacemode,
                                                    integrity
                                                ).then(
                                                    (a) => {
                                                        player.sendMessageB(
                                                            `${a.counter == 0
                                                                ? "§c"
                                                                : ""}${a.counter} blocks filled in ${a.completionData
                                                                .endTime -
                                                            a.completionData
                                                                .startTime} ms over ${a.completionData
                                                                .endTick -
                                                            a.completionData
                                                                .startTick} tick${a.completionData
                                                                .endTick -
                                                                a
                                                                    .completionData
                                                                    .startTick ==
                                                                1
                                                                ? ""
                                                                : "s"}${a.completionData
                                                                .containsUnloadedChunks
                                                                ? "; Some blocks were not generated because they were in unloaded chunks. "
                                                                : ""}`
                                                        );
                                                    },
                                                    (e) => {
                                                        player.sendError(
                                                            "§c" + e + e.stack,
                                                            true
                                                        );
                                                    }
                                                );
                                            } catch (e) {
                                                player.sendError(
                                                    "§c" + e + e.stack,
                                                    true
                                                );
                                            } finally {
                                                tac.forEach((tab) => tab?.remove()
                                                );
                                            }
                                        });
                                    } catch (e) {
                                        player.sendError(
                                            "§c" + e + e.stack,
                                            true
                                        );
                                    }
                                });
                                break;
                            case "outline":
                                system.run(() => {
                                    let ta: Entity[];
                                    try {
                                        generateTickingAreaFillCoordinatesC(
                                            player.location,
                                            (() => {
                                                let a = new CompoundBlockVolume();
                                                a.pushVolume({
                                                    volume: new BlockVolume(
                                                        coordinatesa,
                                                        coordinatesb
                                                    ),
                                                });
                                                return a;
                                            })(),
                                            player.dimension
                                        ).then((tac) => {
                                            ta = tac;
                                            try {
                                                fillBlocksHOTG(
                                                    coordinatesa,
                                                    coordinatesb,
                                                    player.dimension,
                                                    firstblockname == "random"
                                                        ? () => blocktypes[Math.floor(
                                                            blocktypes.length *
                                                            Math.random()
                                                        )]
                                                        : firstblockname,
                                                    firstblockstates,
                                                    {
                                                        matchingBlock: matchingblock[0],
                                                        matchingBlockStates: matchingblock[1],
                                                        minMSBetweenYields: 5000,
                                                    },
                                                    undefined,
                                                    replacemode,
                                                    integrity
                                                ).then(
                                                    (a) => {
                                                        player.sendMessageB(
                                                            `${a.counter == 0
                                                                ? "§c"
                                                                : ""}${a.counter} blocks filled in ${a.completionData
                                                                .endTime -
                                                            a.completionData
                                                                .startTime} ms over ${a.completionData
                                                                .endTick -
                                                            a.completionData
                                                                .startTick} tick${a.completionData
                                                                .endTick -
                                                                a
                                                                    .completionData
                                                                    .startTick ==
                                                                1
                                                                ? ""
                                                                : "s"}${a.completionData
                                                                .containsUnloadedChunks
                                                                ? "; Some blocks were not generated because they were in unloaded chunks. "
                                                                : ""}`
                                                        );
                                                    },
                                                    (e) => {
                                                        player.sendError(
                                                            "§c" + e + e.stack,
                                                            true
                                                        );
                                                    }
                                                );
                                            } catch (e) {
                                                player.sendError(
                                                    "§c" + e + e.stack,
                                                    true
                                                );
                                            } finally {
                                                tac.forEach((tab) => tab?.remove()
                                                );
                                            }
                                        });
                                    } catch (e) {
                                        player.sendError(
                                            "§c" + e + e.stack,
                                            true
                                        );
                                    }
                                });
                                break;
                            case "pillars":
                                system.run(() => {
                                    let ta: Entity[];
                                    try {
                                        generateTickingAreaFillCoordinatesC(
                                            player.location,
                                            (() => {
                                                let a = new CompoundBlockVolume();
                                                a.pushVolume({
                                                    volume: new BlockVolume(
                                                        coordinatesa,
                                                        coordinatesb
                                                    ),
                                                });
                                                return a;
                                            })(),
                                            player.dimension
                                        ).then((tac) => {
                                            ta = tac;
                                            try {
                                                let startTime = Date.now();
                                                let a = fillBlocksHP(
                                                    coordinatesa,
                                                    coordinatesb,
                                                    player.dimension,
                                                    firstblockname,
                                                    firstblockstates,
                                                    {
                                                        matchingBlock: matchingblock[0],
                                                        matchingBlockStates: matchingblock[1],
                                                    },
                                                    undefined,
                                                    replacemode
                                                );
                                                let endTime = Date.now();
                                                player.sendMessageB(
                                                    `${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`
                                                );
                                            } catch (e) {
                                                player.sendError(
                                                    "§c" + e + e.stack,
                                                    true
                                                );
                                            } finally {
                                                tac.forEach((tab) => tab?.remove()
                                                );
                                            }
                                        });
                                    } catch (e) {
                                        player.sendError(
                                            "§c" + e + e.stack,
                                            true
                                        );
                                    }
                                });
                                break;
                            case "skygrid":
                                system.run(() => {
                                    let ta: Entity[];
                                    try {
                                        generateTickingAreaFillCoordinatesC(
                                            player.location,
                                            (() => {
                                                let a = new CompoundBlockVolume();
                                                a.pushVolume({
                                                    volume: new BlockVolume(
                                                        coordinatesa,
                                                        coordinatesb
                                                    ),
                                                });
                                                return a;
                                            })(),
                                            player.dimension
                                        ).then((tac) => {
                                            ta = tac;
                                            try {
                                                fillBlocksHSGG(
                                                    coordinatesa,
                                                    coordinatesb,
                                                    sgskygridsize,
                                                    player.dimension,
                                                    sgfirstblockname,
                                                    sgfirstblockstates,
                                                    {
                                                        matchingBlock: sgmatchingblock[0],
                                                        matchingBlockStates: sgmatchingblock[1],
                                                        minMSBetweenYields: 5000,
                                                    },
                                                    undefined,
                                                    sgreplacemode,
                                                    integrity
                                                ).then(
                                                    (a) => {
                                                        player.sendMessageB(
                                                            `${a.counter == 0
                                                                ? "§c"
                                                                : ""}${a.counter} blocks filled in ${a.completionData
                                                                .endTime -
                                                            a.completionData
                                                                .startTime} ms over ${a.completionData
                                                                .endTick -
                                                            a.completionData
                                                                .startTick} tick${a.completionData
                                                                .endTick -
                                                                a
                                                                    .completionData
                                                                    .startTick ==
                                                                1
                                                                ? ""
                                                                : "s"}${a.completionData
                                                                .containsUnloadedChunks
                                                                ? "; Some blocks were not generated because they were in unloaded chunks. "
                                                                : ""}`
                                                        );
                                                    },
                                                    (e) => {
                                                        player.sendError(
                                                            "§c" + e + e.stack,
                                                            true
                                                        );
                                                    }
                                                );
                                            } catch (e) {
                                                player.sendError(
                                                    "§c" + e + e.stack,
                                                    true
                                                );
                                            } finally {
                                                tac.forEach((tab) => tab?.remove()
                                                );
                                            }
                                        });
                                    } catch (e) {
                                        player.sendError(
                                            "§c" + e + e.stack,
                                            true
                                        );
                                    }
                                });
                                break;
                            case "inverseskygrid":
                                system.run(() => {
                                    let ta: Entity[];
                                    try {
                                        generateTickingAreaFillCoordinatesC(
                                            player.location,
                                            (() => {
                                                let a = new CompoundBlockVolume();
                                                a.pushVolume({
                                                    volume: new BlockVolume(
                                                        coordinatesa,
                                                        coordinatesb
                                                    ),
                                                });
                                                return a;
                                            })(),
                                            player.dimension
                                        ).then((tac) => {
                                            ta = tac;
                                            try {
                                                fillBlocksHISGG(
                                                    coordinatesa,
                                                    coordinatesb,
                                                    sgskygridsize,
                                                    player.dimension,
                                                    sgfirstblockname,
                                                    sgfirstblockstates,
                                                    {
                                                        matchingBlock: sgmatchingblock[0],
                                                        matchingBlockStates: sgmatchingblock[1],
                                                        minMSBetweenYields: 5000,
                                                    },
                                                    undefined,
                                                    sgreplacemode,
                                                    integrity
                                                ).then(
                                                    (a) => {
                                                        player.sendMessageB(
                                                            `${a.counter == 0
                                                                ? "§c"
                                                                : ""}${a.counter} blocks filled in ${a.completionData
                                                                .endTime -
                                                            a.completionData
                                                                .startTime} ms over ${a.completionData
                                                                .endTick -
                                                            a.completionData
                                                                .startTick} tick${a.completionData
                                                                .endTick -
                                                                a
                                                                    .completionData
                                                                    .startTick ==
                                                                1
                                                                ? ""
                                                                : "s"}${a.completionData
                                                                .containsUnloadedChunks
                                                                ? "; Some blocks were not generated because they were in unloaded chunks. "
                                                                : ""}`
                                                        );
                                                    },
                                                    (e) => {
                                                        player.sendError(
                                                            "§c" + e + e.stack,
                                                            true
                                                        );
                                                    }
                                                );
                                            } catch (e) {
                                                player.sendError(
                                                    "§c" + e + e.stack,
                                                    true
                                                );
                                            } finally {
                                                tac.forEach((tab) => tab?.remove()
                                                );
                                            }
                                        });
                                    } catch (e) {
                                        player.sendError(
                                            "§c" + e + e.stack,
                                            true
                                        );
                                    }
                                });
                                break;
                            case "tunnel":
                                player.sendMessageB("§eComing Soon! ");
                                break;
                            case "floor":
                                player.sendMessageB("§eComing Soon! ");
                                break;
                            case "ceilling":
                                player.sendMessageB("§eComing Soon! ");
                                break;
                            case "diamond":
                                player.sendMessageB("§eComing Soon! ");
                                break;
                            case "hollowovoid":
                                system.run(() => {
                                    let ta: Entity;
                                    try {
                                        player.dimension.runCommand(
                                            "summon andexdb:tickingarea_6 itwalls " +
                                            vTStr(center)
                                        );
                                        ta = player.dimension
                                            .getEntitiesAtBlockLocation(center)
                                            .find(
                                                (v) => v.typeId ==
                                                    "andexdb:tickingarea_6"
                                            );
                                        /*console.warn(ta, location); */ system.runTimeout(
                                                () => {
                                                    try {
                                                        fillBlocksHHOG(
                                                            center,
                                                            vTV3(
                                                                Vector3Utils.subtract(
                                                                    horadi,
                                                                    {
                                                                        x: -0.5,
                                                                        y: -0.5,
                                                                        z: -0.5,
                                                                    }
                                                                )
                                                            ),
                                                            hooffset,
                                                            hothickness,
                                                            player.dimension,
                                                            hofirstblockname,
                                                            hofirstblockstates,
                                                            {
                                                                matchingBlock: homatchingblock[0],
                                                                matchingBlockStates: homatchingblock[1],
                                                                minMSBetweenYields: 5000,
                                                            },
                                                            undefined,
                                                            horeplacemode,
                                                            hointegrity
                                                        ).then(
                                                            (a) => {
                                                                player.sendMessageB(
                                                                    `${a.counter ==
                                                                        0
                                                                        ? "§c"
                                                                        : ""}${a.counter} blocks filled in ${a
                                                                        .completionData
                                                                        .endTime -
                                                                    a
                                                                        .completionData
                                                                        .startTime} ms over ${a
                                                                        .completionData
                                                                        .endTick -
                                                                    a
                                                                        .completionData
                                                                        .startTick} tick${a
                                                                        .completionData
                                                                        .endTick -
                                                                        a
                                                                            .completionData
                                                                            .startTick ==
                                                                        1
                                                                        ? ""
                                                                        : "s"}${a
                                                                        .completionData
                                                                        .containsUnloadedChunks
                                                                        ? "; Some blocks were not generated because they were in unloaded chunks. "
                                                                        : ""}`
                                                                );
                                                            },
                                                            (e) => {
                                                                player.sendError(
                                                                    "§c" +
                                                                    e +
                                                                    e.stack,
                                                                    true
                                                                );
                                                            }
                                                        );
                                                    } catch (e) {
                                                        player.sendError(
                                                            "§c" + e + e.stack,
                                                            true
                                                        );
                                                    } finally {
                                                        ta?.remove();
                                                    }
                                                },
                                                2
                                            );
                                    } catch (e) {
                                        player.sendError(
                                            "§c" + e + e.stack,
                                            true
                                        );
                                    }
                                });
                                break;
                            case "ovoid":
                                system.run(() => {
                                    let ta: Entity;
                                    try {
                                        player.dimension.runCommand(
                                            "summon andexdb:tickingarea_6 itwalls " +
                                            vTStr(center)
                                        );
                                        ta = player.dimension
                                            .getEntitiesAtBlockLocation(center)
                                            .find(
                                                (v) => v.typeId ==
                                                    "andexdb:tickingarea_6"
                                            );
                                        /*console.warn(ta, location); */ system.runTimeout(
                                                () => {
                                                    try {
                                                        fillBlocksHOG(
                                                            center,
                                                            vTV3(
                                                                Vector3Utils.subtract(
                                                                    oradi,
                                                                    {
                                                                        x: -0.5,
                                                                        y: -0.5,
                                                                        z: -0.5,
                                                                    }
                                                                )
                                                            ),
                                                            ooffset,
                                                            player.dimension,
                                                            ofirstblockname,
                                                            ofirstblockstates,
                                                            {
                                                                matchingBlock: omatchingblock[0],
                                                                matchingBlockStates: omatchingblock[1],
                                                                minMSBetweenYields: 5000,
                                                            },
                                                            undefined,
                                                            oreplacemode,
                                                            ointegrity
                                                        ).then(
                                                            (a) => {
                                                                player.sendMessageB(
                                                                    `${a.counter ==
                                                                        0
                                                                        ? "§c"
                                                                        : ""}${a.counter} blocks filled in ${a
                                                                        .completionData
                                                                        .endTime -
                                                                    a
                                                                        .completionData
                                                                        .startTime} ms over ${a
                                                                        .completionData
                                                                        .endTick -
                                                                    a
                                                                        .completionData
                                                                        .startTick} tick${a
                                                                        .completionData
                                                                        .endTick -
                                                                        a
                                                                            .completionData
                                                                            .startTick ==
                                                                        1
                                                                        ? ""
                                                                        : "s"}${a
                                                                        .completionData
                                                                        .containsUnloadedChunks
                                                                        ? "; Some blocks were not generated because they were in unloaded chunks. "
                                                                        : ""}`
                                                                );
                                                            },
                                                            (e) => {
                                                                player.sendError(
                                                                    "§c" +
                                                                    e +
                                                                    e.stack,
                                                                    true
                                                                );
                                                            }
                                                        );
                                                    } catch (e) {
                                                        player.sendError(
                                                            "§c" + e + e.stack,
                                                            true
                                                        );
                                                    } finally {
                                                        ta?.remove();
                                                    }
                                                },
                                                2
                                            );
                                    } catch (e) {
                                        player.sendError(
                                            "§c" + e + e.stack,
                                            true
                                        );
                                    }
                                });
                                break;
                            case "hollowsphere":
                                system.run(() => {
                                    let ta: Entity;
                                    try {
                                        player.dimension.runCommand(
                                            "summon andexdb:tickingarea_6 itwalls " +
                                            vTStr(center)
                                        );
                                        ta = player.dimension
                                            .getEntitiesAtBlockLocation(center)
                                            .find(
                                                (v) => v.typeId ==
                                                    "andexdb:tickingarea_6"
                                            );
                                        /*console.warn(ta, location); */ system.runTimeout(
                                                () => {
                                                    try {
                                                        fillBlocksHHSG(
                                                            center,
                                                            radius - 0.5,
                                                            thickness,
                                                            player.dimension,
                                                            hsfirstblockname,
                                                            hsfirstblockstates,
                                                            {
                                                                matchingBlock: hsmatchingblock[0],
                                                                matchingBlockStates: hsmatchingblock[1],
                                                                minMSBetweenYields: 5000,
                                                            },
                                                            undefined,
                                                            hsreplacemode,
                                                            cintegrity
                                                        ).then(
                                                            (a) => {
                                                                player.sendMessageB(
                                                                    `${a.counter ==
                                                                        0
                                                                        ? "§c"
                                                                        : ""}${a.counter} blocks filled in ${a
                                                                        .completionData
                                                                        .endTime -
                                                                    a
                                                                        .completionData
                                                                        .startTime} ms over ${a
                                                                        .completionData
                                                                        .endTick -
                                                                    a
                                                                        .completionData
                                                                        .startTick} tick${a
                                                                        .completionData
                                                                        .endTick -
                                                                        a
                                                                            .completionData
                                                                            .startTick ==
                                                                        1
                                                                        ? ""
                                                                        : "s"}${a
                                                                        .completionData
                                                                        .containsUnloadedChunks
                                                                        ? "; Some blocks were not generated because they were in unloaded chunks. "
                                                                        : ""}`
                                                                );
                                                            },
                                                            (e) => {
                                                                player.sendError(
                                                                    "§c" +
                                                                    e +
                                                                    e.stack,
                                                                    true
                                                                );
                                                            }
                                                        );
                                                    } catch (e) {
                                                        player.sendError(
                                                            "§c" + e + e.stack,
                                                            true
                                                        );
                                                    } finally {
                                                        ta?.remove();
                                                    }
                                                },
                                                2
                                            );
                                    } catch (e) {
                                        player.sendError(
                                            "§c" + e + e.stack,
                                            true
                                        );
                                    }
                                });
                                break;
                            case "dome":
                                system.run(() => {
                                    let ta: Entity;
                                    try {
                                        player.dimension.runCommand(
                                            "summon andexdb:tickingarea_6 itwalls " +
                                            vTStr(center)
                                        );
                                        ta = player.dimension
                                            .getEntitiesAtBlockLocation(center)
                                            .find(
                                                (v) => v.typeId ==
                                                    "andexdb:tickingarea_6"
                                            );
                                        /*console.warn(ta, location); */ system.runTimeout(
                                                () => {
                                                    try {
                                                        fillBlocksHDG(
                                                            center,
                                                            radius - 0.5,
                                                            thickness,
                                                            player.dimension,
                                                            hsfirstblockname,
                                                            hsfirstblockstates,
                                                            {
                                                                matchingBlock: hsmatchingblock[0],
                                                                matchingBlockStates: hsmatchingblock[1],
                                                                minMSBetweenYields: 5000,
                                                            },
                                                            undefined,
                                                            hsreplacemode,
                                                            cintegrity
                                                        ).then(
                                                            (a) => {
                                                                player.sendMessageB(
                                                                    `${a.counter ==
                                                                        0
                                                                        ? "§c"
                                                                        : ""}${a.counter} blocks filled in ${a
                                                                        .completionData
                                                                        .endTime -
                                                                    a
                                                                        .completionData
                                                                        .startTime} ms over ${a
                                                                        .completionData
                                                                        .endTick -
                                                                    a
                                                                        .completionData
                                                                        .startTick} tick${a
                                                                        .completionData
                                                                        .endTick -
                                                                        a
                                                                            .completionData
                                                                            .startTick ==
                                                                        1
                                                                        ? ""
                                                                        : "s"}${a
                                                                        .completionData
                                                                        .containsUnloadedChunks
                                                                        ? "; Some blocks were not generated because they were in unloaded chunks. "
                                                                        : ""}`
                                                                );
                                                            },
                                                            (e) => {
                                                                player.sendError(
                                                                    "§c" +
                                                                    e +
                                                                    e.stack,
                                                                    true
                                                                );
                                                            }
                                                        );
                                                    } catch (e) {
                                                        player.sendError(
                                                            "§c" + e + e.stack,
                                                            true
                                                        );
                                                    } finally {
                                                        ta?.remove();
                                                    }
                                                },
                                                2
                                            );
                                    } catch (e) {
                                        player.sendError(
                                            "§c" + e + e.stack,
                                            true
                                        );
                                    }
                                });
                                break;
                            case "sphere":
                                system.run(() => {
                                    let ta: Entity;
                                    try {
                                        player.dimension.runCommand(
                                            "summon andexdb:tickingarea_6 itwalls " +
                                            vTStr(center)
                                        );
                                        ta = player.dimension
                                            .getEntitiesAtBlockLocation(center)
                                            .find(
                                                (v) => v.typeId ==
                                                    "andexdb:tickingarea_6"
                                            );
                                        /*console.warn(ta, location); */ system.runTimeout(
                                                () => {
                                                    try {
                                                        fillBlocksHSG(
                                                            center,
                                                            radius - 0.5,
                                                            player.dimension,
                                                            ccfirstblockname,
                                                            ccfirstblockstates,
                                                            {
                                                                matchingBlock: ccmatchingblock[0],
                                                                matchingBlockStates: ccmatchingblock[1],
                                                                minMSBetweenYields: 5000,
                                                            },
                                                            undefined,
                                                            ccreplacemode,
                                                            cintegrity
                                                        ).then(
                                                            (a) => {
                                                                player.sendMessageB(
                                                                    `${a.counter ==
                                                                        0
                                                                        ? "§c"
                                                                        : ""}${a.counter} blocks filled in ${a
                                                                        .completionData
                                                                        .endTime -
                                                                    a
                                                                        .completionData
                                                                        .startTime} ms over ${a
                                                                        .completionData
                                                                        .endTick -
                                                                    a
                                                                        .completionData
                                                                        .startTick} tick${a
                                                                        .completionData
                                                                        .endTick -
                                                                        a
                                                                            .completionData
                                                                            .startTick ==
                                                                        1
                                                                        ? ""
                                                                        : "s"}`
                                                                );
                                                            },
                                                            (e) => {
                                                                player.sendError(
                                                                    "§c" +
                                                                    e +
                                                                    e.stack,
                                                                    true
                                                                );
                                                            }
                                                        );
                                                    } catch (e) {
                                                        player.sendError(
                                                            "§c" + e + e.stack,
                                                            true
                                                        );
                                                    } finally {
                                                        ta?.remove();
                                                    }
                                                },
                                                2
                                            );
                                    } catch (e) {
                                        player.sendError(
                                            "§c" + e + e.stack,
                                            true
                                        );
                                    }
                                });
                                break;
                            case "semisphere":
                                system.run(() => {
                                    let ta: Entity;
                                    try {
                                        player.dimension.runCommand(
                                            "summon andexdb:tickingarea_6 itwalls " +
                                            vTStr(center)
                                        );
                                        ta = player.dimension
                                            .getEntitiesAtBlockLocation(center)
                                            .find(
                                                (v) => v.typeId ==
                                                    "andexdb:tickingarea_6"
                                            );
                                        /*console.warn(ta, location); */ system.runTimeout(
                                                () => {
                                                    try {
                                                        fillBlocksHSSG(
                                                            center,
                                                            radius - 0.5,
                                                            player.dimension,
                                                            ccfirstblockname,
                                                            ccfirstblockstates,
                                                            {
                                                                matchingBlock: ccmatchingblock[0],
                                                                matchingBlockStates: ccmatchingblock[1],
                                                                minMSBetweenYields: 5000,
                                                            },
                                                            undefined,
                                                            ccreplacemode,
                                                            cintegrity
                                                        ).then(
                                                            (a) => {
                                                                player.sendMessageB(
                                                                    `${a.counter ==
                                                                        0
                                                                        ? "§c"
                                                                        : ""}${a.counter} blocks filled in ${a
                                                                        .completionData
                                                                        .endTime -
                                                                    a
                                                                        .completionData
                                                                        .startTime} ms over ${a
                                                                        .completionData
                                                                        .endTick -
                                                                    a
                                                                        .completionData
                                                                        .startTick} tick${a
                                                                        .completionData
                                                                        .endTick -
                                                                        a
                                                                            .completionData
                                                                            .startTick ==
                                                                        1
                                                                        ? ""
                                                                        : "s"}`
                                                                );
                                                            },
                                                            (e) => {
                                                                player.sendError(
                                                                    "§c" +
                                                                    e +
                                                                    e.stack,
                                                                    true
                                                                );
                                                            }
                                                        );
                                                    } catch (e) {
                                                        player.sendError(
                                                            "§c" + e + e.stack,
                                                            true
                                                        );
                                                    } finally {
                                                        ta?.remove();
                                                    }
                                                },
                                                2
                                            );
                                    } catch (e) {
                                        player.sendError(
                                            "§c" + e + e.stack,
                                            true
                                        );
                                    }
                                });
                                break;
                            case "circle":
                                system.run(() => {
                                    let ta: Entity;
                                    try {
                                        player.dimension.runCommand(
                                            "summon andexdb:tickingarea_6 itwalls " +
                                            vTStr(center)
                                        );
                                        ta = player.dimension
                                            .getEntitiesAtBlockLocation(center)
                                            .find(
                                                (v) => v.typeId ==
                                                    "andexdb:tickingarea_6"
                                            );
                                        /*console.warn(ta, location); */ system.runTimeout(
                                                () => {
                                                    try {
                                                        let startTime = Date.now();
                                                        let a = fillBlocksHC(
                                                            center,
                                                            radius,
                                                            player.dimension,
                                                            axis,
                                                            cfirstblockname,
                                                            cfirstblockstates,
                                                            {
                                                                matchingBlock: cmatchingblock[0],
                                                                matchingBlockStates: cmatchingblock[1],
                                                            },
                                                            undefined,
                                                            creplacemode
                                                        );
                                                        let endTime = Date.now();
                                                        player.sendMessageB(
                                                            `${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`
                                                        );
                                                    } catch (e) {
                                                        player.sendError(
                                                            "§c" + e + e.stack,
                                                            true
                                                        );
                                                    } finally {
                                                        ta?.remove();
                                                    }
                                                },
                                                2
                                            );
                                    } catch (e) {
                                        player.sendError(
                                            "§c" + e + e.stack,
                                            true
                                        );
                                    }
                                });
                                break;
                            case "circlex":
                                system.run(() => {
                                    let ta: Entity;
                                    try {
                                        player.dimension.runCommand(
                                            "summon andexdb:tickingarea_6 itwalls " +
                                            vTStr(center)
                                        );
                                        ta = player.dimension
                                            .getEntitiesAtBlockLocation(center)
                                            .find(
                                                (v) => v.typeId ==
                                                    "andexdb:tickingarea_6"
                                            );
                                        /*console.warn(ta, location); */ system.runTimeout(
                                                () => {
                                                    try {
                                                        let startTime = Date.now();
                                                        let a = fillBlocksHC(
                                                            center,
                                                            radius,
                                                            player.dimension,
                                                            "x",
                                                            ccfirstblockname,
                                                            ccfirstblockstates,
                                                            {
                                                                matchingBlock: ccmatchingblock[0],
                                                                matchingBlockStates: ccmatchingblock[1],
                                                            },
                                                            undefined,
                                                            ccreplacemode
                                                        );
                                                        let endTime = Date.now();
                                                        player.sendMessageB(
                                                            `${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`
                                                        );
                                                    } catch (e) {
                                                        player.sendError(
                                                            "§c" + e + e.stack,
                                                            true
                                                        );
                                                    } finally {
                                                        ta?.remove();
                                                    }
                                                },
                                                2
                                            );
                                    } catch (e) {
                                        player.sendError(
                                            "§c" + e + e.stack,
                                            true
                                        );
                                    }
                                });
                                break;
                            case "circley":
                                system.run(() => {
                                    let ta: Entity;
                                    try {
                                        player.dimension.runCommand(
                                            "summon andexdb:tickingarea_6 itwalls " +
                                            vTStr(center)
                                        );
                                        ta = player.dimension
                                            .getEntitiesAtBlockLocation(center)
                                            .find(
                                                (v) => v.typeId ==
                                                    "andexdb:tickingarea_6"
                                            );
                                        /*console.warn(ta, location); */ system.runTimeout(
                                                () => {
                                                    try {
                                                        let startTime = Date.now();
                                                        let a = fillBlocksHC(
                                                            center,
                                                            radius,
                                                            player.dimension,
                                                            "y",
                                                            ccfirstblockname,
                                                            ccfirstblockstates,
                                                            {
                                                                matchingBlock: ccmatchingblock[0],
                                                                matchingBlockStates: ccmatchingblock[1],
                                                            },
                                                            undefined,
                                                            ccreplacemode
                                                        );
                                                        let endTime = Date.now();
                                                        player.sendMessageB(
                                                            `${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`
                                                        );
                                                    } catch (e) {
                                                        player.sendError(
                                                            "§c" + e + e.stack,
                                                            true
                                                        );
                                                    } finally {
                                                        ta?.remove();
                                                    }
                                                },
                                                2
                                            );
                                    } catch (e) {
                                        player.sendError(
                                            "§c" + e + e.stack,
                                            true
                                        );
                                    }
                                });
                                break;
                            case "circlez":
                                system.run(() => {
                                    let ta: Entity;
                                    try {
                                        player.dimension.runCommand(
                                            "summon andexdb:tickingarea_6 itwalls " +
                                            vTStr(center)
                                        );
                                        ta = player.dimension
                                            .getEntitiesAtBlockLocation(center)
                                            .find(
                                                (v) => v.typeId ==
                                                    "andexdb:tickingarea_6"
                                            );
                                        /*console.warn(ta, location); */ system.runTimeout(
                                                () => {
                                                    try {
                                                        let startTime = Date.now();
                                                        let a = fillBlocksHC(
                                                            center,
                                                            radius,
                                                            player.dimension,
                                                            "z",
                                                            ccfirstblockname,
                                                            ccfirstblockstates,
                                                            {
                                                                matchingBlock: ccmatchingblock[0],
                                                                matchingBlockStates: ccmatchingblock[1],
                                                            },
                                                            undefined,
                                                            ccreplacemode
                                                        );
                                                        let endTime = Date.now();
                                                        player.sendMessageB(
                                                            `${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`
                                                        );
                                                    } catch (e) {
                                                        player.sendError(
                                                            "§c" + e + e.stack,
                                                            true
                                                        );
                                                    } finally {
                                                        ta?.remove();
                                                    }
                                                },
                                                2
                                            );
                                    } catch (e) {
                                        player.sendError(
                                            "§c" + e + e.stack,
                                            true
                                        );
                                    }
                                });
                                break;
                            case "circlexy":
                                system.run(() => {
                                    let ta: Entity;
                                    try {
                                        player.dimension.runCommand(
                                            "summon andexdb:tickingarea_6 itwalls " +
                                            vTStr(center)
                                        );
                                        ta = player.dimension
                                            .getEntitiesAtBlockLocation(center)
                                            .find(
                                                (v) => v.typeId ==
                                                    "andexdb:tickingarea_6"
                                            );
                                        /*console.warn(ta, location); */ system.runTimeout(
                                                () => {
                                                    try {
                                                        let startTime = Date.now();
                                                        let a = fillBlocksHC(
                                                            center,
                                                            radius,
                                                            player.dimension,
                                                            "xy",
                                                            ccfirstblockname,
                                                            ccfirstblockstates,
                                                            {
                                                                matchingBlock: ccmatchingblock[0],
                                                                matchingBlockStates: ccmatchingblock[1],
                                                            },
                                                            undefined,
                                                            ccreplacemode
                                                        );
                                                        let endTime = Date.now();
                                                        player.sendMessageB(
                                                            `${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`
                                                        );
                                                    } catch (e) {
                                                        player.sendError(
                                                            "§c" + e + e.stack,
                                                            true
                                                        );
                                                    } finally {
                                                        ta?.remove();
                                                    }
                                                },
                                                2
                                            );
                                    } catch (e) {
                                        player.sendError(
                                            "§c" + e + e.stack,
                                            true
                                        );
                                    }
                                });
                                break;
                            case "circleyz":
                                system.run(() => {
                                    let ta: Entity;
                                    try {
                                        player.dimension.runCommand(
                                            "summon andexdb:tickingarea_6 itwalls " +
                                            vTStr(center)
                                        );
                                        ta = player.dimension
                                            .getEntitiesAtBlockLocation(center)
                                            .find(
                                                (v) => v.typeId ==
                                                    "andexdb:tickingarea_6"
                                            );
                                        /*console.warn(ta, location); */ system.runTimeout(
                                                () => {
                                                    try {
                                                        let startTime = Date.now();
                                                        let a = fillBlocksHC(
                                                            center,
                                                            radius,
                                                            player.dimension,
                                                            "yz",
                                                            ccfirstblockname,
                                                            ccfirstblockstates,
                                                            {
                                                                matchingBlock: ccmatchingblock[0],
                                                                matchingBlockStates: ccmatchingblock[1],
                                                            },
                                                            undefined,
                                                            ccreplacemode
                                                        );
                                                        let endTime = Date.now();
                                                        player.sendMessageB(
                                                            `${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`
                                                        );
                                                    } catch (e) {
                                                        player.sendError(
                                                            "§c" + e + e.stack,
                                                            true
                                                        );
                                                    } finally {
                                                        ta?.remove();
                                                    }
                                                },
                                                2
                                            );
                                    } catch (e) {
                                        player.sendError(
                                            "§c" + e + e.stack,
                                            true
                                        );
                                    }
                                });
                                break;
                            case "circlexz":
                                system.run(() => {
                                    let ta: Entity;
                                    try {
                                        player.dimension.runCommand(
                                            "summon andexdb:tickingarea_6 itwalls " +
                                            vTStr(center)
                                        );
                                        ta = player.dimension
                                            .getEntitiesAtBlockLocation(center)
                                            .find(
                                                (v) => v.typeId ==
                                                    "andexdb:tickingarea_6"
                                            );
                                        /*console.warn(ta, location); */ system.runTimeout(
                                                () => {
                                                    try {
                                                        let startTime = Date.now();
                                                        let a = fillBlocksHC(
                                                            center,
                                                            radius,
                                                            player.dimension,
                                                            "xz",
                                                            ccfirstblockname,
                                                            ccfirstblockstates,
                                                            {
                                                                matchingBlock: ccmatchingblock[0],
                                                                matchingBlockStates: ccmatchingblock[1],
                                                            },
                                                            undefined,
                                                            ccreplacemode
                                                        );
                                                        let endTime = Date.now();
                                                        player.sendMessageB(
                                                            `${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`
                                                        );
                                                    } catch (e) {
                                                        player.sendError(
                                                            "§c" + e + e.stack,
                                                            true
                                                        );
                                                    } finally {
                                                        ta?.remove();
                                                    }
                                                },
                                                2
                                            );
                                    } catch (e) {
                                        player.sendError(
                                            "§c" + e + e.stack,
                                            true
                                        );
                                    }
                                });
                                break;
                            case "circlexyz":
                                system.run(() => {
                                    let ta: Entity;
                                    try {
                                        player.dimension.runCommand(
                                            "summon andexdb:tickingarea_6 itwalls " +
                                            vTStr(center)
                                        );
                                        ta = player.dimension
                                            .getEntitiesAtBlockLocation(center)
                                            .find(
                                                (v) => v.typeId ==
                                                    "andexdb:tickingarea_6"
                                            );
                                        /*console.warn(ta, location); */ system.runTimeout(
                                                () => {
                                                    try {
                                                        let startTime = Date.now();
                                                        let a = fillBlocksHC(
                                                            center,
                                                            radius,
                                                            player.dimension,
                                                            "xyz",
                                                            ccfirstblockname,
                                                            ccfirstblockstates,
                                                            {
                                                                matchingBlock: ccmatchingblock[0],
                                                                matchingBlockStates: ccmatchingblock[1],
                                                            },
                                                            undefined,
                                                            ccreplacemode
                                                        );
                                                        let endTime = Date.now();
                                                        player.sendMessageB(
                                                            `${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`
                                                        );
                                                    } catch (e) {
                                                        player.sendError(
                                                            "§c" + e + e.stack,
                                                            true
                                                        );
                                                    } finally {
                                                        ta?.remove();
                                                    }
                                                },
                                                2
                                            );
                                    } catch (e) {
                                        player.sendError(
                                            "§c" + e + e.stack,
                                            true
                                        );
                                    }
                                });
                                break;
                            case "cylinder":
                                system.run(() => {
                                    let ta: Entity;
                                    try {
                                        player.dimension.runCommand(
                                            "summon andexdb:tickingarea_6 itwalls " +
                                            vTStr(center)
                                        );
                                        ta = player.dimension
                                            .getEntitiesAtBlockLocation(center)
                                            .find(
                                                (v) => v.typeId ==
                                                    "andexdb:tickingarea_6"
                                            );
                                        /*console.warn(ta, location); */ system.runTimeout(
                                                () => {
                                                    try {
                                                        let startTime = Date.now();
                                                        let a = fillBlocksHT(
                                                            center,
                                                            radius,
                                                            thickness,
                                                            taxis,
                                                            player.dimension,
                                                            tfirstblockname,
                                                            tfirstblockstates,
                                                            {
                                                                matchingBlock: tmatchingblock[0],
                                                                matchingBlockStates: tmatchingblock[1],
                                                            },
                                                            undefined,
                                                            treplacemode,
                                                            tintegrity
                                                        );
                                                        let endTime = Date.now();
                                                        player.sendMessageB(
                                                            `${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`
                                                        );
                                                    } catch (e) {
                                                        player.sendError(
                                                            "§c" + e + e.stack,
                                                            true
                                                        );
                                                    } finally {
                                                        ta?.remove();
                                                    }
                                                },
                                                2
                                            );
                                    } catch (e) {
                                        player.sendError(
                                            "§c" + e + e.stack,
                                            true
                                        );
                                    }
                                });
                                break;
                            case "cylinderx":
                                system.run(() => {
                                    let ta: Entity;
                                    try {
                                        player.dimension.runCommand(
                                            "summon andexdb:tickingarea_6 itwalls " +
                                            vTStr(center)
                                        );
                                        ta = player.dimension
                                            .getEntitiesAtBlockLocation(center)
                                            .find(
                                                (v) => v.typeId ==
                                                    "andexdb:tickingarea_6"
                                            );
                                        /*console.warn(ta, location); */ system.runTimeout(
                                                () => {
                                                    try {
                                                        let startTime = Date.now();
                                                        let a = fillBlocksHT(
                                                            center,
                                                            radius,
                                                            thickness,
                                                            "x",
                                                            player.dimension,
                                                            hsfirstblockname,
                                                            hsfirstblockstates,
                                                            {
                                                                matchingBlock: hsmatchingblock[0],
                                                                matchingBlockStates: hsmatchingblock[1],
                                                            },
                                                            undefined,
                                                            hsreplacemode,
                                                            tintegrity
                                                        );
                                                        let endTime = Date.now();
                                                        player.sendMessageB(
                                                            `${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`
                                                        );
                                                    } catch (e) {
                                                        player.sendError(
                                                            "§c" + e + e.stack,
                                                            true
                                                        );
                                                    } finally {
                                                        ta?.remove();
                                                    }
                                                },
                                                2
                                            );
                                    } catch (e) {
                                        player.sendError(
                                            "§c" + e + e.stack,
                                            true
                                        );
                                    }
                                });
                                break;
                            case "cylindery":
                                system.run(() => {
                                    let ta: Entity;
                                    try {
                                        player.dimension.runCommand(
                                            "summon andexdb:tickingarea_6 itwalls " +
                                            vTStr(center)
                                        );
                                        ta = player.dimension
                                            .getEntitiesAtBlockLocation(center)
                                            .find(
                                                (v) => v.typeId ==
                                                    "andexdb:tickingarea_6"
                                            );
                                        /*console.warn(ta, location); */ system.runTimeout(
                                                () => {
                                                    try {
                                                        let startTime = Date.now();
                                                        let a = fillBlocksHT(
                                                            center,
                                                            radius,
                                                            thickness,
                                                            "y",
                                                            player.dimension,
                                                            hsfirstblockname,
                                                            hsfirstblockstates,
                                                            {
                                                                matchingBlock: hsmatchingblock[0],
                                                                matchingBlockStates: hsmatchingblock[1],
                                                            },
                                                            undefined,
                                                            hsreplacemode,
                                                            tintegrity
                                                        );
                                                        let endTime = Date.now();
                                                        player.sendMessageB(
                                                            `${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`
                                                        );
                                                    } catch (e) {
                                                        player.sendError(
                                                            "§c" + e + e.stack,
                                                            true
                                                        );
                                                    } finally {
                                                        ta?.remove();
                                                    }
                                                },
                                                2
                                            );
                                    } catch (e) {
                                        player.sendError(
                                            "§c" + e + e.stack,
                                            true
                                        );
                                    }
                                });
                                break;
                            case "cylinderz":
                                system.run(() => {
                                    let ta: Entity;
                                    try {
                                        player.dimension.runCommand(
                                            "summon andexdb:tickingarea_6 itwalls " +
                                            vTStr(center)
                                        );
                                        ta = player.dimension
                                            .getEntitiesAtBlockLocation(center)
                                            .find(
                                                (v) => v.typeId ==
                                                    "andexdb:tickingarea_6"
                                            );
                                        /*console.warn(ta, location); */ system.runTimeout(
                                                () => {
                                                    try {
                                                        let startTime = Date.now();
                                                        let a = fillBlocksHT(
                                                            center,
                                                            radius,
                                                            thickness,
                                                            "z",
                                                            player.dimension,
                                                            hsfirstblockname,
                                                            hsfirstblockstates,
                                                            {
                                                                matchingBlock: hsmatchingblock[0],
                                                                matchingBlockStates: hsmatchingblock[1],
                                                            },
                                                            undefined,
                                                            hsreplacemode,
                                                            tintegrity
                                                        );
                                                        let endTime = Date.now();
                                                        player.sendMessageB(
                                                            `${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`
                                                        );
                                                    } catch (e) {
                                                        player.sendError(
                                                            "§c" + e + e.stack,
                                                            true
                                                        );
                                                    } finally {
                                                        ta?.remove();
                                                    }
                                                },
                                                2
                                            );
                                    } catch (e) {
                                        player.sendError(
                                            "§c" + e + e.stack,
                                            true
                                        );
                                    }
                                });
                                break;
                            case "cylinderxy":
                                system.run(() => {
                                    let ta: Entity;
                                    try {
                                        player.dimension.runCommand(
                                            "summon andexdb:tickingarea_6 itwalls " +
                                            vTStr(center)
                                        );
                                        ta = player.dimension
                                            .getEntitiesAtBlockLocation(center)
                                            .find(
                                                (v) => v.typeId ==
                                                    "andexdb:tickingarea_6"
                                            );
                                        /*console.warn(ta, location); */ system.runTimeout(
                                                () => {
                                                    try {
                                                        let startTime = Date.now();
                                                        let a = fillBlocksHT(
                                                            center,
                                                            radius,
                                                            thickness,
                                                            "x",
                                                            player.dimension,
                                                            hsfirstblockname,
                                                            hsfirstblockstates,
                                                            {
                                                                matchingBlock: hsmatchingblock[0],
                                                                matchingBlockStates: hsmatchingblock[1],
                                                            },
                                                            undefined,
                                                            hsreplacemode,
                                                            tintegrity
                                                        );
                                                        let endTime = Date.now();
                                                        player.sendMessageB(
                                                            `${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`
                                                        );
                                                    } catch (e) {
                                                        player.sendError(
                                                            "§c" + e + e.stack,
                                                            true
                                                        );
                                                    } finally {
                                                        ta?.remove();
                                                    }
                                                },
                                                2
                                            );
                                    } catch (e) {
                                        player.sendError(
                                            "§c" + e + e.stack,
                                            true
                                        );
                                    }
                                });
                                break;
                            case "cylinderyz":
                                system.run(() => {
                                    let ta: Entity;
                                    try {
                                        player.dimension.runCommand(
                                            "summon andexdb:tickingarea_6 itwalls " +
                                            vTStr(center)
                                        );
                                        ta = player.dimension
                                            .getEntitiesAtBlockLocation(center)
                                            .find(
                                                (v) => v.typeId ==
                                                    "andexdb:tickingarea_6"
                                            );
                                        /*console.warn(ta, location); */ system.runTimeout(
                                                () => {
                                                    try {
                                                        let startTime = Date.now();
                                                        let a = fillBlocksHT(
                                                            center,
                                                            radius,
                                                            thickness,
                                                            "y",
                                                            player.dimension,
                                                            hsfirstblockname,
                                                            hsfirstblockstates,
                                                            {
                                                                matchingBlock: hsmatchingblock[0],
                                                                matchingBlockStates: hsmatchingblock[1],
                                                            },
                                                            undefined,
                                                            hsreplacemode,
                                                            tintegrity
                                                        );
                                                        let endTime = Date.now();
                                                        player.sendMessageB(
                                                            `${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`
                                                        );
                                                    } catch (e) {
                                                        player.sendError(
                                                            "§c" + e + e.stack,
                                                            true
                                                        );
                                                    } finally {
                                                        ta?.remove();
                                                    }
                                                },
                                                2
                                            );
                                    } catch (e) {
                                        player.sendError(
                                            "§c" + e + e.stack,
                                            true
                                        );
                                    }
                                });
                                break;
                            case "cylinderxz":
                                system.run(() => {
                                    let ta: Entity;
                                    try {
                                        player.dimension.runCommand(
                                            "summon andexdb:tickingarea_6 itwalls " +
                                            vTStr(center)
                                        );
                                        ta = player.dimension
                                            .getEntitiesAtBlockLocation(center)
                                            .find(
                                                (v) => v.typeId ==
                                                    "andexdb:tickingarea_6"
                                            );
                                        /*console.warn(ta, location); */ system.runTimeout(
                                                () => {
                                                    try {
                                                        let startTime = Date.now();
                                                        let a = fillBlocksHT(
                                                            center,
                                                            radius,
                                                            thickness,
                                                            "z",
                                                            player.dimension,
                                                            hsfirstblockname,
                                                            hsfirstblockstates,
                                                            {
                                                                matchingBlock: hsmatchingblock[0],
                                                                matchingBlockStates: hsmatchingblock[1],
                                                            },
                                                            undefined,
                                                            hsreplacemode,
                                                            tintegrity
                                                        );
                                                        let endTime = Date.now();
                                                        player.sendMessageB(
                                                            `${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`
                                                        );
                                                    } catch (e) {
                                                        player.sendError(
                                                            "§c" + e + e.stack,
                                                            true
                                                        );
                                                    } finally {
                                                        ta?.remove();
                                                    }
                                                },
                                                2
                                            );
                                    } catch (e) {
                                        player.sendError(
                                            "§c" + e + e.stack,
                                            true
                                        );
                                    }
                                });
                                break;
                            case "cylinderxyz":
                                system.run(() => {
                                    let ta: Entity;
                                    try {
                                        player.dimension.runCommand(
                                            "summon andexdb:tickingarea_6 itwalls " +
                                            vTStr(center)
                                        );
                                        ta = player.dimension
                                            .getEntitiesAtBlockLocation(center)
                                            .find(
                                                (v) => v.typeId ==
                                                    "andexdb:tickingarea_6"
                                            );
                                        /*console.warn(ta, location); */ system.runTimeout(
                                                () => {
                                                    try {
                                                        let startTime = Date.now();
                                                        let a = fillBlocksHT(
                                                            center,
                                                            radius,
                                                            thickness,
                                                            "z",
                                                            player.dimension,
                                                            hsfirstblockname,
                                                            hsfirstblockstates,
                                                            {
                                                                matchingBlock: hsmatchingblock[0],
                                                                matchingBlockStates: hsmatchingblock[1],
                                                            },
                                                            undefined,
                                                            hsreplacemode,
                                                            tintegrity
                                                        );
                                                        let endTime = Date.now();
                                                        player.sendMessageB(
                                                            `${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`
                                                        );
                                                    } catch (e) {
                                                        player.sendError(
                                                            "§c" + e + e.stack,
                                                            true
                                                        );
                                                    } finally {
                                                        ta?.remove();
                                                    }
                                                },
                                                2
                                            );
                                    } catch (e) {
                                        player.sendError(
                                            "§c" + e + e.stack,
                                            true
                                        );
                                    }
                                });
                                break;
                            case "hourglass":
                                player.sendMessageB("§eComing Soon! ");
                                break;
                            case "cube":
                                system.run(() => {
                                    let ta: Entity;
                                    try {
                                        let location = {
                                            x: (coordinatesa.x +
                                                coordinatesb.x) /
                                                2,
                                            y: (coordinatesa.y +
                                                coordinatesb.y) /
                                                2,
                                            z: (coordinatesa.z +
                                                coordinatesb.z) /
                                                2,
                                        };
                                        player.dimension.runCommand(
                                            "summon andexdb:tickingarea_6 itwalls " +
                                            vTStr(location)
                                        );
                                        ta = player.dimension
                                            .getEntitiesAtBlockLocation(
                                                location
                                            )
                                            .find(
                                                (v) => v.typeId ==
                                                    "andexdb:tickingarea_6"
                                            );
                                        system.runTimeout(() => {
                                            try {
                                                let startTime = Date.now();
                                                if (replacemode) {
                                                    clearAllContainerBlocks(
                                                        scanForContainerBlocks(
                                                            coordinatesa,
                                                            coordinatesb,
                                                            player.dimension,
                                                            "Block"
                                                        ) as Block[]
                                                    );
                                                }
                                                let a = fillBlocksH(
                                                    coordinatesa,
                                                    coordinatesb,
                                                    player.dimension,
                                                    firstblockname,
                                                    firstblockstates,
                                                    {
                                                        matchingBlock: matchingblock[0],
                                                        matchingBlockStates: matchingblock[1],
                                                    }
                                                );
                                                let endTime = Date.now();
                                                player.sendMessageB(
                                                    `${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`
                                                );
                                            } catch (e) {
                                                player.sendError(
                                                    "§c" + e + e.stack,
                                                    true
                                                );
                                            } finally {
                                                ta?.remove();
                                            }
                                        }, 2);
                                    } catch (e) {
                                        player.sendError(
                                            "§c" + e + e.stack,
                                            true
                                        );
                                    }
                                });
                                break;
                            default:
                        }
                    }
                    //            try{system.run(()=>{player.dimension.fillBlocks(evaluateCoordinates(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[0][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[1][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[2][0], player.location, player.getRotation()), evaluateCoordinates(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[3][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[4][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0], player.location, player.getRotation()), BlockPermutation.resolve(switchTestB.split(" ").slice(1).join(" ").slice(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5].index+Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0].indexOf(" ")+1).split(" ")[0], extractJSONStrings(switchTestB.split(" ").slice(1).join(" ").slice(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5].index+Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0].indexOf(" ")).split(" ").slice(1).join(" "), false)[0]), {matchingBlock: BlockPermutation.resolve(getParametersFromString(switchTestB.split(" ").slice(1).join(" ").slice(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5].index+Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0].indexOf(" ")+1)).results[2], extractJSONStrings(switchTestB.split(" ").slice(1).join(" ").slice(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5].index+Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0].indexOf(" ")).split(" ").slice(1).join(" "), false)[1])}); }); }catch(e){player.sendError("§c" + e + e.stack, true)}
                }
                break;
            case !!switchTest.match(/^brush$/) ||
                !!switchTest.match(/^\\brush$/) ||
                !!switchTest.match(/^br$/) ||
                !!switchTest.match(/^\\br$/):
                {
                    eventData.cancel = true;
                    let args = evaluateParameters(switchTestB, [
                        "presetText",
                        "f-l",
                        "string",
                    ]).args;
                    if (player
                        .getComponent("inventory")
                        .container.getItem(player.selectedSlotIndex)
                        .isStackable) {
                        player.sendMessageB(
                            "§cError: The held item is a stackable item."
                        );
                    } else {
                        switch (args[2].toLowerCase()) {
                            case "none":
                                {
                                    player
                                        .getComponent("inventory")
                                        .container.getSlot(
                                            player.selectedSlotIndex
                                        )
                                        .setDynamicProperty(
                                            "brushtype",
                                            "none"
                                        );
                                    if (!args[1].l) {
                                        srun(() => player
                                            .getComponent("inventory")
                                            .container.getSlot(
                                                player.selectedSlotIndex
                                            )
                                            .setLore()
                                        );
                                    }
                                    player.sendMessageB(
                                        `Successfully unbound the brush from the currently held item.`
                                    );
                                }
                                break;
                            case "extinguish":
                                {
                                    let args = evaluateParameters(switchTestB, [
                                        "presetText",
                                        "f-l",
                                        "string",
                                        "number",
                                    ]).args;
                                    player
                                        .getComponent("inventory")
                                        .container.getSlot(
                                            player.selectedSlotIndex
                                        )
                                        .setDynamicProperty(
                                            "brushtype",
                                            "extinguish"
                                        );
                                    player
                                        .getComponent("inventory")
                                        .container.getSlot(
                                            player.selectedSlotIndex
                                        )
                                        .setDynamicProperty(
                                            "radius",
                                            isNaN(Number(args[3]))
                                                ? 10
                                                : args[3]
                                        );
                                    if (!args[1].l) {
                                        srun(() => player
                                            .getComponent("inventory")
                                            .container.getSlot(
                                                player.selectedSlotIndex
                                            )
                                            .setLore([
                                                `§r§bSelect Mode: ${player
                                                    .getComponent(
                                                        "inventory"
                                                    )
                                                    .container.getSlot(
                                                        player.selectedSlotIndex
                                                    )
                                                    .getDynamicProperty(
                                                        "selectmode"
                                                    )}`,
                                                `§r§bBrush Type: §aExtinguish`,
                                                `§r§bBrush Radius: ${isNaN(Number(args[3]))
                                                    ? 10
                                                    : args[3]}`,
                                            ])
                                        );
                                    }
                                    player.sendMessageB(
                                        `Successfully set brush type of the held item to extinguish with a radius of ${isNaN(Number(args[3]))
                                            ? 10
                                            : args[3]}.`
                                    );
                                }
                                break;
                            case "ex":
                                {
                                    let args = evaluateParameters(switchTestB, [
                                        "presetText",
                                        "f-l",
                                        "string",
                                        "number",
                                    ]).args;
                                    player
                                        .getComponent("inventory")
                                        .container.getSlot(
                                            player.selectedSlotIndex
                                        )
                                        .setDynamicProperty(
                                            "brushtype",
                                            "extinguish"
                                        );
                                    player
                                        .getComponent("inventory")
                                        .container.getSlot(
                                            player.selectedSlotIndex
                                        )
                                        .setDynamicProperty(
                                            "radius",
                                            isNaN(Number(args[3]))
                                                ? 10
                                                : args[3]
                                        );
                                    if (!args[1].l) {
                                        srun(() => player
                                            .getComponent("inventory")
                                            .container.getSlot(
                                                player.selectedSlotIndex
                                            )
                                            .setLore([
                                                `§r§bBrush Type: §aExtinguish`,
                                                `§r§bBrush Radius: ${isNaN(Number(args[3]))
                                                    ? 10
                                                    : args[3]}`,
                                            ])
                                        );
                                    }
                                    player.sendMessageB(
                                        `Successfully set brush type of the held item to extinguish with a radius of ${isNaN(Number(args[3]))
                                            ? 10
                                            : args[3]}.`
                                    );
                                }
                                break;
                            case "remexp":
                                {
                                    let args = evaluateParameters(switchTestB, [
                                        "presetText",
                                        "f-l",
                                        "string",
                                        "number",
                                    ]).args;
                                    player
                                        .getComponent("inventory")
                                        .container.getSlot(
                                            player.selectedSlotIndex
                                        )
                                        .setDynamicProperty(
                                            "brushtype",
                                            "remexp"
                                        );
                                    player
                                        .getComponent("inventory")
                                        .container.getSlot(
                                            player.selectedSlotIndex
                                        )
                                        .setDynamicProperty(
                                            "radius",
                                            isNaN(Number(args[3]))
                                                ? 10
                                                : args[3]
                                        );
                                    if (!args[1].l) {
                                        srun(() => player
                                            .getComponent("inventory")
                                            .container.getSlot(
                                                player.selectedSlotIndex
                                            )
                                            .setLore([
                                                `§r§bBrush Type: §aRemExp`,
                                                `§r§bBrush Radius: ${isNaN(Number(args[3]))
                                                    ? 10
                                                    : args[3]}`,
                                            ])
                                        );
                                    }
                                    player.sendMessageB(
                                        `Successfully set brush type of the held item to remexp with a radius of ${isNaN(Number(args[3]))
                                            ? 10
                                            : args[3]}.`
                                    );
                                }
                                break;
                            case "remexpne":
                                {
                                    let args = evaluateParameters(switchTestB, [
                                        "presetText",
                                        "f-l",
                                        "string",
                                        "number",
                                    ]).args;
                                    player
                                        .getComponent("inventory")
                                        .container.getSlot(
                                            player.selectedSlotIndex
                                        )
                                        .setDynamicProperty(
                                            "brushtype",
                                            "remexpne"
                                        );
                                    player
                                        .getComponent("inventory")
                                        .container.getSlot(
                                            player.selectedSlotIndex
                                        )
                                        .setDynamicProperty(
                                            "radius",
                                            isNaN(Number(args[3]))
                                                ? 10
                                                : args[3]
                                        );
                                    if (!args[1].l) {
                                        srun(() => player
                                            .getComponent("inventory")
                                            .container.getSlot(
                                                player.selectedSlotIndex
                                            )
                                            .setLore([
                                                `§r§bBrush Type: §aRemExpNE`,
                                                `§r§bBrush Radius: ${isNaN(Number(args[3]))
                                                    ? 10
                                                    : args[3]}`,
                                            ])
                                        );
                                    }
                                    player.sendMessageB(
                                        `Successfully set brush type of the held item to remexp with a radius of ${isNaN(Number(args[3]))
                                            ? 10
                                            : args[3]}.`
                                    );
                                }
                                break;
                            case "sphere":
                                {
                                    let args = evaluateParameters(switchTestB, [
                                        "presetText",
                                        "f-l",
                                        "string",
                                        "f-h",
                                        "blockPattern",
                                        "number",
                                    ]).args;
                                    player
                                        .getComponent("inventory")
                                        .container.getSlot(
                                            player.selectedSlotIndex
                                        )
                                        .setDynamicProperty(
                                            "brushtype",
                                            "sphere"
                                        );
                                    player
                                        .getComponent("inventory")
                                        .container.getSlot(
                                            player.selectedSlotIndex
                                        )
                                        .setDynamicProperty(
                                            "pattern",
                                            JSON.stringify(
                                                (args[4] as BlockPattern).blocks
                                            )
                                        );
                                    player
                                        .getComponent("inventory")
                                        .container.getSlot(
                                            player.selectedSlotIndex
                                        )
                                        .setDynamicProperty(
                                            "patterntype",
                                            (args[4] as BlockPattern).type
                                        );
                                    player
                                        .getComponent("inventory")
                                        .container.getSlot(
                                            player.selectedSlotIndex
                                        )
                                        .setDynamicProperty(
                                            "radius",
                                            isNaN(Number(args[5])) ? 3 : args[5]
                                        );
                                    if (!args[1].l) {
                                        srun(() => player
                                            .getComponent("inventory")
                                            .container.getSlot(
                                                player.selectedSlotIndex
                                            )
                                            .setLore([
                                                `§r§bBrush Type: §aSphere`,
                                                `§r§bBrush Radius: §c${isNaN(Number(args[5]))
                                                    ? 3
                                                    : args[5]}`,
                                                ...[
                                                    ...(
                                                        args[4] as BlockPattern
                                                    ).blocks
                                                        .map((v) => v.rawns)
                                                        .slice(0, 15)
                                                        .map(
                                                            (v) => `§r§d${v}`
                                                        ),
                                                    "§r§d...",
                                                ].slice(
                                                    0,
                                                    (
                                                        args[4] as BlockPattern
                                                    ).blocks.length > 15
                                                        ? -1
                                                        : undefined
                                                ),
                                                `§r§bBrush Pattern Type: §a${(
                                                    args[4] as BlockPattern
                                                ).type}`,
                                            ])
                                        );
                                    }
                                    player.sendMessageB(
                                        `Successfully set brush type of the held item to sphere with a radius of ${isNaN(Number(args[5])) ? 3 : args[5]}.`
                                    );
                                }
                                break;
                            case "cube":
                                {
                                    let args = evaluateParameters(switchTestB, [
                                        "presetText",
                                        "f-l",
                                        "string",
                                        "f-h",
                                        "blockPattern",
                                        "number",
                                    ]).args;
                                    player
                                        .getComponent("inventory")
                                        .container.getSlot(
                                            player.selectedSlotIndex
                                        )
                                        .setDynamicProperty(
                                            "brushtype",
                                            "cube"
                                        );
                                    player
                                        .getComponent("inventory")
                                        .container.getSlot(
                                            player.selectedSlotIndex
                                        )
                                        .setDynamicProperty(
                                            "pattern",
                                            JSON.stringify(
                                                (args[4] as BlockPattern).blocks
                                            )
                                        );
                                    player
                                        .getComponent("inventory")
                                        .container.getSlot(
                                            player.selectedSlotIndex
                                        )
                                        .setDynamicProperty(
                                            "patterntype",
                                            (args[4] as BlockPattern).type
                                        );
                                    player
                                        .getComponent("inventory")
                                        .container.getSlot(
                                            player.selectedSlotIndex
                                        )
                                        .setDynamicProperty(
                                            "radius",
                                            isNaN(Number(args[5])) ? 3 : args[5]
                                        );
                                    if (!args[1].l) {
                                        srun(() => player
                                            .getComponent("inventory")
                                            .container.getSlot(
                                                player.selectedSlotIndex
                                            )
                                            .setLore([
                                                `§r§bBrush Type: §aCube`,
                                                `§r§bBrush Radius: §c${isNaN(Number(args[5]))
                                                    ? 3
                                                    : args[5]}`,
                                                ...[
                                                    ...(
                                                        args[4] as BlockPattern
                                                    ).blocks
                                                        .map((v) => v.rawns)
                                                        .slice(0, 15)
                                                        .map(
                                                            (v) => `§r§d${v}`
                                                        ),
                                                    "§r§d...",
                                                ].slice(
                                                    0,
                                                    (
                                                        args[4] as BlockPattern
                                                    ).blocks.length > 15
                                                        ? -1
                                                        : undefined
                                                ),
                                                `§r§bBrush Pattern Type: §a${(
                                                    args[4] as BlockPattern
                                                ).type}`,
                                            ])
                                        );
                                    }
                                    player.sendMessageB(
                                        `Successfully set brush type of the held item to cube with a radius of ${isNaN(Number(args[5])) ? 3 : args[5]}.`
                                    );
                                }
                                break;
                            case "square":
                                {
                                    let args = evaluateParameters(switchTestB, [
                                        "presetText",
                                        "f-l",
                                        "string",
                                        "f-h",
                                        "blockPattern",
                                        "number",
                                    ]).args;
                                    player
                                        .getComponent("inventory")
                                        .container.getSlot(
                                            player.selectedSlotIndex
                                        )
                                        .setDynamicProperty(
                                            "brushtype",
                                            "square"
                                        );
                                    player
                                        .getComponent("inventory")
                                        .container.getSlot(
                                            player.selectedSlotIndex
                                        )
                                        .setDynamicProperty(
                                            "pattern",
                                            JSON.stringify(
                                                (args[4] as BlockPattern).blocks
                                            )
                                        );
                                    player
                                        .getComponent("inventory")
                                        .container.getSlot(
                                            player.selectedSlotIndex
                                        )
                                        .setDynamicProperty(
                                            "patterntype",
                                            (args[4] as BlockPattern).type
                                        );
                                    player
                                        .getComponent("inventory")
                                        .container.getSlot(
                                            player.selectedSlotIndex
                                        )
                                        .setDynamicProperty(
                                            "radius",
                                            isNaN(Number(args[5])) ? 3 : args[5]
                                        );
                                    if (!args[1].l) {
                                        srun(() => player
                                            .getComponent("inventory")
                                            .container.getSlot(
                                                player.selectedSlotIndex
                                            )
                                            .setLore([
                                                `§r§bBrush Type: §aSquare`,
                                                `§r§bBrush Radius: §c${isNaN(Number(args[5]))
                                                    ? 3
                                                    : args[5]}`,
                                                ...[
                                                    ...(
                                                        args[4] as BlockPattern
                                                    ).blocks
                                                        .map((v) => v.rawns)
                                                        .slice(0, 15)
                                                        .map(
                                                            (v) => `§r§d${v}`
                                                        ),
                                                    "§r§d...",
                                                ].slice(
                                                    0,
                                                    (
                                                        args[4] as BlockPattern
                                                    ).blocks.length > 15
                                                        ? -1
                                                        : undefined
                                                ),
                                                `§r§bBrush Pattern Type: §a${(
                                                    args[4] as BlockPattern
                                                ).type}`,
                                            ])
                                        );
                                    }
                                    player.sendMessageB(
                                        `Successfully set brush type of the held item to square with a radius of ${isNaN(Number(args[5])) ? 3 : args[5]}.`
                                    );
                                }
                                break;
                            case "splatter":
                                {
                                    let args = evaluateParameters(switchTestB, [
                                        "presetText",
                                        "f-l",
                                        "string",
                                        "f-h",
                                        "blockPattern",
                                        "number",
                                        "number",
                                    ]).args;
                                    player
                                        .getComponent("inventory")
                                        .container.getSlot(
                                            player.selectedSlotIndex
                                        )
                                        .setDynamicProperty(
                                            "brushtype",
                                            "splatter"
                                        );
                                    player
                                        .getComponent("inventory")
                                        .container.getSlot(
                                            player.selectedSlotIndex
                                        )
                                        .setDynamicProperty(
                                            "pattern",
                                            JSON.stringify(
                                                (args[4] as BlockPattern).blocks
                                            )
                                        );
                                    player
                                        .getComponent("inventory")
                                        .container.getSlot(
                                            player.selectedSlotIndex
                                        )
                                        .setDynamicProperty(
                                            "patterntype",
                                            (args[4] as BlockPattern).type
                                        );
                                    player
                                        .getComponent("inventory")
                                        .container.getSlot(
                                            player.selectedSlotIndex
                                        )
                                        .setDynamicProperty(
                                            "decay",
                                            isNaN(Number(args[6])) ? 0 : args[6]
                                        );
                                    player
                                        .getComponent("inventory")
                                        .container.getSlot(
                                            player.selectedSlotIndex
                                        )
                                        .setDynamicProperty(
                                            "radius",
                                            isNaN(Number(args[5])) ? 3 : args[5]
                                        );
                                    //console.warn(JSON.stringify((args[4] as BlockPattern).blocks))
                                    if (!args[1].l) {
                                        srun(() => player
                                            .getComponent("inventory")
                                            .container.getSlot(
                                                player.selectedSlotIndex
                                            )
                                            .setLore([
                                                `§r§bBrush Type: §aSplatter`,
                                                `§r§bBrush Radius: §c${isNaN(Number(args[5]))
                                                    ? 3
                                                    : args[5]}`,
                                                `§r§bBrush Decay: §c${isNaN(Number(args[6]))
                                                    ? 0
                                                    : args[6]}`,
                                                `§r§bBrush Pattern: `,
                                                ...[
                                                    ...(
                                                        args[4] as BlockPattern
                                                    ).blocks
                                                        .map((v) => v.rawns)
                                                        .slice(0, 15)
                                                        .map(
                                                            (v) => `§r§d${v}`
                                                        ),
                                                    "§r§d...",
                                                ].slice(
                                                    0,
                                                    (
                                                        args[4] as BlockPattern
                                                    ).blocks.length > 15
                                                        ? -1
                                                        : undefined
                                                ),
                                                `§r§bBrush Pattern Type: §a${(
                                                    args[4] as BlockPattern
                                                ).type}`,
                                            ])
                                        );
                                    }
                                    player.sendMessageB(
                                        `Successfully set brush type of the held item to splatter with a radius of ${isNaN(Number(args[5])) ? 3 : args[5]} and a decay level of ${isNaN(Number(args[6])) ? 0 : args[6]}.`
                                    );
                                }
                                break;
                            case "splattercube":
                                {
                                    let args = evaluateParameters(switchTestB, [
                                        "presetText",
                                        "f-l",
                                        "string",
                                        "f-h",
                                        "blockPattern",
                                        "number",
                                        "number",
                                    ]).args;
                                    player
                                        .getComponent("inventory")
                                        .container.getSlot(
                                            player.selectedSlotIndex
                                        )
                                        .setDynamicProperty(
                                            "brushtype",
                                            "splattercube"
                                        );
                                    player
                                        .getComponent("inventory")
                                        .container.getSlot(
                                            player.selectedSlotIndex
                                        )
                                        .setDynamicProperty(
                                            "pattern",
                                            JSON.stringify(
                                                (args[4] as BlockPattern).blocks
                                            )
                                        );
                                    player
                                        .getComponent("inventory")
                                        .container.getSlot(
                                            player.selectedSlotIndex
                                        )
                                        .setDynamicProperty(
                                            "patterntype",
                                            (args[4] as BlockPattern).type
                                        );
                                    player
                                        .getComponent("inventory")
                                        .container.getSlot(
                                            player.selectedSlotIndex
                                        )
                                        .setDynamicProperty(
                                            "decay",
                                            isNaN(Number(args[6])) ? 0 : args[6]
                                        );
                                    player
                                        .getComponent("inventory")
                                        .container.getSlot(
                                            player.selectedSlotIndex
                                        )
                                        .setDynamicProperty(
                                            "radius",
                                            isNaN(Number(args[5])) ? 3 : args[5]
                                        );
                                    if (!args[1].l) {
                                        srun(() => player
                                            .getComponent("inventory")
                                            .container.getSlot(
                                                player.selectedSlotIndex
                                            )
                                            .setLore([
                                                `§r§bBrush Type: §aSplatterCube`,
                                                `§r§bBrush Radius: §c${isNaN(Number(args[5]))
                                                    ? 3
                                                    : args[5]}`,
                                                `§r§bBrush Decay: §c${isNaN(Number(args[6]))
                                                    ? 0
                                                    : args[6]}`,
                                                ...[
                                                    ...(
                                                        args[4] as BlockPattern
                                                    ).blocks
                                                        .map((v) => v.rawns)
                                                        .slice(0, 15)
                                                        .map(
                                                            (v) => `§r§d${v}`
                                                        ),
                                                    "§r§d...",
                                                ].slice(
                                                    0,
                                                    (
                                                        args[4] as BlockPattern
                                                    ).blocks.length > 15
                                                        ? -1
                                                        : undefined
                                                ),
                                                `§r§bBrush Pattern Type: §a${(
                                                    args[4] as BlockPattern
                                                ).type}`,
                                            ])
                                        );
                                    }
                                    player.sendMessageB(
                                        `Successfully set brush type of the held item to splatter with a radius of ${isNaN(Number(args[5])) ? 3 : args[5]} and a decay level of ${isNaN(Number(args[6])) ? 0 : args[6]}.`
                                    );
                                }
                                break;
                            case "splattersquare":
                                {
                                    let args = evaluateParameters(switchTestB, [
                                        "presetText",
                                        "f-l",
                                        "string",
                                        "f-h",
                                        "blockPattern",
                                        "number",
                                        "number",
                                    ]).args;
                                    player
                                        .getComponent("inventory")
                                        .container.getSlot(
                                            player.selectedSlotIndex
                                        )
                                        .setDynamicProperty(
                                            "brushtype",
                                            "splattersquare"
                                        );
                                    player
                                        .getComponent("inventory")
                                        .container.getSlot(
                                            player.selectedSlotIndex
                                        )
                                        .setDynamicProperty(
                                            "pattern",
                                            JSON.stringify(
                                                (args[4] as BlockPattern).blocks
                                            )
                                        );
                                    player
                                        .getComponent("inventory")
                                        .container.getSlot(
                                            player.selectedSlotIndex
                                        )
                                        .setDynamicProperty(
                                            "patterntype",
                                            (args[4] as BlockPattern).type
                                        );
                                    player
                                        .getComponent("inventory")
                                        .container.getSlot(
                                            player.selectedSlotIndex
                                        )
                                        .setDynamicProperty(
                                            "decay",
                                            isNaN(Number(args[6])) ? 0 : args[6]
                                        );
                                    player
                                        .getComponent("inventory")
                                        .container.getSlot(
                                            player.selectedSlotIndex
                                        )
                                        .setDynamicProperty(
                                            "radius",
                                            isNaN(Number(args[5])) ? 3 : args[5]
                                        );
                                    if (!args[1].l) {
                                        srun(() => player
                                            .getComponent("inventory")
                                            .container.getSlot(
                                                player.selectedSlotIndex
                                            )
                                            .setLore([
                                                `§r§bBrush Type: §aSplatterSquare`,
                                                `§r§bBrush Radius: §c${isNaN(Number(args[5]))
                                                    ? 3
                                                    : args[5]}`,
                                                `§r§bBrush Decay: §c${isNaN(Number(args[6]))
                                                    ? 0
                                                    : args[6]}`,
                                                ...[
                                                    ...(
                                                        args[4] as BlockPattern
                                                    ).blocks
                                                        .map((v) => v.rawns)
                                                        .slice(0, 15)
                                                        .map(
                                                            (v) => `§r§d${v}`
                                                        ),
                                                    "§r§d...",
                                                ].slice(
                                                    0,
                                                    (
                                                        args[4] as BlockPattern
                                                    ).blocks.length > 15
                                                        ? -1
                                                        : undefined
                                                ),
                                                `§r§bBrush Pattern Type: §a${(
                                                    args[4] as BlockPattern
                                                ).type}`,
                                            ])
                                        );
                                    }
                                    player.sendMessageB(
                                        `Successfully set brush type of the held item to splatter with a radius of ${isNaN(Number(args[5])) ? 3 : args[5]} and a decay level of ${isNaN(Number(args[6])) ? 0 : args[6]}.`
                                    );
                                }
                                break;
                            case "splattersurface":
                                {
                                    let args = evaluateParameters(switchTestB, [
                                        "presetText",
                                        "f-l",
                                        "string",
                                        "f-h",
                                        "blockPattern",
                                        "number",
                                        "number",
                                    ]).args;
                                    player
                                        .getComponent("inventory")
                                        .container.getSlot(
                                            player.selectedSlotIndex
                                        )
                                        .setDynamicProperty(
                                            "brushtype",
                                            "splattersurface"
                                        );
                                    player
                                        .getComponent("inventory")
                                        .container.getSlot(
                                            player.selectedSlotIndex
                                        )
                                        .setDynamicProperty(
                                            "pattern",
                                            JSON.stringify(
                                                (args[4] as BlockPattern).blocks
                                            )
                                        );
                                    player
                                        .getComponent("inventory")
                                        .container.getSlot(
                                            player.selectedSlotIndex
                                        )
                                        .setDynamicProperty(
                                            "patterntype",
                                            (args[4] as BlockPattern).type
                                        );
                                    player
                                        .getComponent("inventory")
                                        .container.getSlot(
                                            player.selectedSlotIndex
                                        )
                                        .setDynamicProperty(
                                            "decay",
                                            isNaN(Number(args[6])) ? 0 : args[6]
                                        );
                                    player
                                        .getComponent("inventory")
                                        .container.getSlot(
                                            player.selectedSlotIndex
                                        )
                                        .setDynamicProperty(
                                            "radius",
                                            isNaN(Number(args[5])) ? 3 : args[5]
                                        );
                                    if (!args[1].l) {
                                        srun(() => player
                                            .getComponent("inventory")
                                            .container.getSlot(
                                                player.selectedSlotIndex
                                            )
                                            .setLore([
                                                `§r§bBrush Type: §aSplatterSurface`,
                                                `§r§bBrush Radius: §c${isNaN(Number(args[5]))
                                                    ? 3
                                                    : args[5]}`,
                                                `§r§bBrush Decay: §c${isNaN(Number(args[6]))
                                                    ? 0
                                                    : args[6]}`,
                                                ...[
                                                    ...(
                                                        args[4] as BlockPattern
                                                    ).blocks
                                                        .map((v) => v.rawns)
                                                        .slice(0, 15)
                                                        .map(
                                                            (v) => `§r§d${v}`
                                                        ),
                                                    "§r§d...",
                                                ].slice(
                                                    0,
                                                    (
                                                        args[4] as BlockPattern
                                                    ).blocks.length > 15
                                                        ? -1
                                                        : undefined
                                                ),
                                                `§r§bBrush Pattern Type: §a${(
                                                    args[4] as BlockPattern
                                                ).type}`,
                                            ])
                                        );
                                    }
                                    player.sendMessageB(
                                        `Successfully set brush type of the held item to splatter surface with a radius of ${isNaN(Number(args[5])) ? 3 : args[5]} and a decay level of ${isNaN(Number(args[6])) ? 0 : args[6]}.`
                                    );
                                }
                                break;
                            case "splattercubesurface":
                                {
                                    let args = evaluateParameters(switchTestB, [
                                        "presetText",
                                        "f-l",
                                        "string",
                                        "f-h",
                                        "blockPattern",
                                        "number",
                                        "number",
                                    ]).args;
                                    player
                                        .getComponent("inventory")
                                        .container.getSlot(
                                            player.selectedSlotIndex
                                        )
                                        .setDynamicProperty(
                                            "brushtype",
                                            "splattercubesurface"
                                        );
                                    player
                                        .getComponent("inventory")
                                        .container.getSlot(
                                            player.selectedSlotIndex
                                        )
                                        .setDynamicProperty(
                                            "pattern",
                                            JSON.stringify(
                                                (args[4] as BlockPattern).blocks
                                            )
                                        );
                                    player
                                        .getComponent("inventory")
                                        .container.getSlot(
                                            player.selectedSlotIndex
                                        )
                                        .setDynamicProperty(
                                            "patterntype",
                                            (args[4] as BlockPattern).type
                                        );
                                    player
                                        .getComponent("inventory")
                                        .container.getSlot(
                                            player.selectedSlotIndex
                                        )
                                        .setDynamicProperty(
                                            "decay",
                                            isNaN(Number(args[6])) ? 0 : args[6]
                                        );
                                    player
                                        .getComponent("inventory")
                                        .container.getSlot(
                                            player.selectedSlotIndex
                                        )
                                        .setDynamicProperty(
                                            "radius",
                                            isNaN(Number(args[5])) ? 3 : args[5]
                                        );
                                    if (!args[1].l) {
                                        srun(() => player
                                            .getComponent("inventory")
                                            .container.getSlot(
                                                player.selectedSlotIndex
                                            )
                                            .setLore([
                                                `§r§bBrush Type: §aSplatterCubeSurface`,
                                                `§r§bBrush Radius: §c${isNaN(Number(args[5]))
                                                    ? 3
                                                    : args[5]}`,
                                                `§r§bBrush Decay: §c${isNaN(Number(args[6]))
                                                    ? 0
                                                    : args[6]}`,
                                                ...[
                                                    ...(
                                                        args[4] as BlockPattern
                                                    ).blocks
                                                        .map((v) => v.rawns)
                                                        .slice(0, 15)
                                                        .map(
                                                            (v) => `§r§d${v}`
                                                        ),
                                                    "§r§d...",
                                                ].slice(
                                                    0,
                                                    (
                                                        args[4] as BlockPattern
                                                    ).blocks.length > 15
                                                        ? -1
                                                        : undefined
                                                ),
                                                `§r§bBrush Pattern Type: §a${(
                                                    args[4] as BlockPattern
                                                ).type}`,
                                            ])
                                        );
                                    }
                                    player.sendMessageB(
                                        `Successfully set brush type of the held item to splatter cube surface with a radius of ${isNaN(Number(args[5])) ? 3 : args[5]} and a decay level of ${isNaN(Number(args[6])) ? 0 : args[6]}.`
                                    );
                                }
                                break;
                            case "splattersquaresurface":
                                {
                                    let args = evaluateParameters(switchTestB, [
                                        "presetText",
                                        "f-l",
                                        "string",
                                        "f-h",
                                        "blockPattern",
                                        "number",
                                        "number",
                                    ]).args;
                                    player
                                        .getComponent("inventory")
                                        .container.getSlot(
                                            player.selectedSlotIndex
                                        )
                                        .setDynamicProperty(
                                            "brushtype",
                                            "splattersquaresurface"
                                        );
                                    player
                                        .getComponent("inventory")
                                        .container.getSlot(
                                            player.selectedSlotIndex
                                        )
                                        .setDynamicProperty(
                                            "pattern",
                                            JSON.stringify(
                                                (args[4] as BlockPattern).blocks
                                            )
                                        );
                                    player
                                        .getComponent("inventory")
                                        .container.getSlot(
                                            player.selectedSlotIndex
                                        )
                                        .setDynamicProperty(
                                            "patterntype",
                                            (args[4] as BlockPattern).type
                                        );
                                    player
                                        .getComponent("inventory")
                                        .container.getSlot(
                                            player.selectedSlotIndex
                                        )
                                        .setDynamicProperty(
                                            "decay",
                                            isNaN(Number(args[6])) ? 0 : args[6]
                                        );
                                    player
                                        .getComponent("inventory")
                                        .container.getSlot(
                                            player.selectedSlotIndex
                                        )
                                        .setDynamicProperty(
                                            "radius",
                                            isNaN(Number(args[5])) ? 3 : args[5]
                                        );
                                    if (!args[1].l) {
                                        srun(() => player
                                            .getComponent("inventory")
                                            .container.getSlot(
                                                player.selectedSlotIndex
                                            )
                                            .setLore([
                                                `§r§bBrush Type: §aSplatterSquareSurface`,
                                                `§r§bBrush Radius: §c${isNaN(Number(args[5]))
                                                    ? 3
                                                    : args[5]}`,
                                                `§r§bBrush Decay: §c${isNaN(Number(args[6]))
                                                    ? 0
                                                    : args[6]}`,
                                                ...[
                                                    ...(
                                                        args[4] as BlockPattern
                                                    ).blocks
                                                        .map((v) => v.rawns)
                                                        .slice(0, 15)
                                                        .map(
                                                            (v) => `§r§d${v}`
                                                        ),
                                                    "§r§d...",
                                                ].slice(
                                                    0,
                                                    (
                                                        args[4] as BlockPattern
                                                    ).blocks.length > 15
                                                        ? -1
                                                        : undefined
                                                ),
                                                `§r§bBrush Pattern Type: §a${(
                                                    args[4] as BlockPattern
                                                ).type}`,
                                            ])
                                        );
                                    }
                                    player.sendMessageB(
                                        `Successfully set brush type of the held item to splatter square surface with a radius of ${isNaN(Number(args[5])) ? 3 : args[5]} and a decay level of ${isNaN(Number(args[6])) ? 0 : args[6]}.`
                                    );
                                }
                                break;
                            default:
                                {
                                    player.sendError(
                                        `§cError: Unknown brush type "${args[2].toLowerCase()}".`,
                                        true
                                    );
                                }
                                break;
                        }
                    }
                }
                break;
            case !!switchTest.match(/^snapshot$/):
                {
                    eventData.cancel = true;
                    srun(() => {
                        let argsa = evaluateParameters(switchTestB, [
                            "presetText",
                            "presetText",
                        ]);
                        try {
                            if ((argsa.args[1] ?? "").trim() == "") {
                                player.sendMessageB(`${command.dp}snapshot backup <areaId: string>
${command.dp}snapshot rollback <areaId: string> [backupIndex: number]
${command.dp}snapshot deletebackup <areaId: string> [backupIndex: number]
${command.dp}snapshot clearbackups <areaId: string>
${command.dp}snapshot deletearea <areaId: string>
${command.dp}snapshot clearareas
${command.dp}snapshot listbackups <areaId: string>
${command.dp}snapshot listareas
${command.dp}snapshot list`);
                                return;
                            }
                            //let args = argsa.args;
                            switch (String(argsa.args[1]).toLowerCase()) {
                                case "backup":
                                    {
                                        let args = evaluateParameters(
                                            switchTestB,
                                            [
                                                { type: "presetText" },
                                                { type: "presetText" },
                                                { type: "string" },
                                            ]
                                        ).args;
                                        if (!!!tryget(
                                            () => AreaBackups.get(
                                                "areabackup:" + args[2]
                                            ).from
                                        )) {
                                            player.sendError(
                                                `§cError: No backup area found with the name ${JSON.stringify(
                                                    args[2]
                                                )}.`,
                                                true
                                            );
                                            return;
                                        }
                                        AreaBackups.get(
                                            "areabackup:" + args[2]
                                        ).backup(Date.now(), {
                                            includeBlocks: true,
                                            includeEntities: false,
                                            saveMode: StructureSaveMode.World,
                                        });
                                        player.sendMessageB(
                                            `Created a backup of the area ${JSON.stringify(
                                                args[2]
                                            )} at ${new Date(
                                                Date.now() +
                                                Number(
                                                    player.getDynamicProperty(
                                                        "andexdbPersonalSettings:timeZone"
                                                    ) ??
                                                    world.getDynamicProperty(
                                                        "andexdbSettings:timeZone"
                                                    ) ??
                                                    0
                                                ) *
                                                3600000
                                            )
                                                .toLocaleString()
                                                .replace(/^00:/, "12:")} GMT${Number(
                                                    player.getDynamicProperty(
                                                        "andexdbPersonalSettings:timeZone"
                                                    ) ??
                                                    world.getDynamicProperty(
                                                        "andexdbSettings:timeZone"
                                                    ) ??
                                                    0
                                                ) < 0
                                                ? ""
                                                : "+"}${Number(
                                                    player.getDynamicProperty(
                                                        "andexdbPersonalSettings:timeZone"
                                                    ) ??
                                                    world.getDynamicProperty(
                                                        "andexdbSettings:timeZone"
                                                    ) ??
                                                    0
                                                ) % 96}.`
                                        );
                                    }
                                    break;
                                case "rollback":
                                    {
                                        let args = evaluateParameters(
                                            switchTestB,
                                            [
                                                { type: "presetText" },
                                                { type: "presetText" },
                                                { type: "string" },
                                                { type: "number" },
                                            ]
                                        ).args;
                                        if (!!!tryget(
                                            () => AreaBackups.get(
                                                "areabackup:" + args[2]
                                            ).from
                                        )) {
                                            player.sendError(
                                                `§cError: No backup area found with the name ${JSON.stringify(
                                                    args[2]
                                                )}.`,
                                                true
                                            );
                                            return;
                                        }
                                        AreaBackups.get(
                                            "areabackup:" + args[2]
                                        ).rollback(
                                            AreaBackups.get(
                                                "areabackup:" + args[2]
                                            ).backups[args[3] ?? 0]
                                        );
                                        player.sendMessageB(
                                            `Restored the area ${JSON.stringify(
                                                args[2]
                                            )} from the backup at ${new Date(
                                                AreaBackups.get(
                                                    "areabackup:" + args[2]
                                                ).backups[args[3] ?? 0] +
                                                Number(
                                                    player.getDynamicProperty(
                                                        "andexdbPersonalSettings:timeZone"
                                                    ) ??
                                                    world.getDynamicProperty(
                                                        "andexdbSettings:timeZone"
                                                    ) ??
                                                    0
                                                ) *
                                                3600000
                                            )
                                                .toLocaleString()
                                                .replace(/^00:/, "12:")} GMT${Number(
                                                    player.getDynamicProperty(
                                                        "andexdbPersonalSettings:timeZone"
                                                    ) ??
                                                    world.getDynamicProperty(
                                                        "andexdbSettings:timeZone"
                                                    ) ??
                                                    0
                                                ) < 0
                                                ? ""
                                                : "+"}${Number(
                                                    player.getDynamicProperty(
                                                        "andexdbPersonalSettings:timeZone"
                                                    ) ??
                                                    world.getDynamicProperty(
                                                        "andexdbSettings:timeZone"
                                                    ) ??
                                                    0
                                                ) % 96}.`
                                        );
                                    }
                                    break;
                                case "deletebackup":
                                    {
                                        let args = evaluateParameters(
                                            switchTestB,
                                            [
                                                { type: "presetText" },
                                                { type: "presetText" },
                                                { type: "string" },
                                                { type: "number" },
                                            ]
                                        ).args;
                                        if (!!!tryget(
                                            () => AreaBackups.get(
                                                "areabackup:" + args[2]
                                            ).from
                                        )) {
                                            player.sendError(
                                                `§cError: No backup area found with the name ${JSON.stringify(
                                                    args[2]
                                                )}.`,
                                                true
                                            );
                                            return;
                                        }
                                        const backuptime = tryget(
                                            () => AreaBackups.get(
                                                "areabackup:" + args[2]
                                            ).backups[args[3] ?? 0]
                                        );
                                        if (!!!backuptime) {
                                            player.sendError(
                                                `§cError: No backup found at index ${args[3]}.`,
                                                true
                                            );
                                            return;
                                        }
                                        AreaBackups.get(
                                            "areabackup:" + args[2]
                                        ).clearBackup(backuptime);
                                        player.sendMessageB(
                                            `Deleted the backup at ${new Date(
                                                backuptime +
                                                Number(
                                                    player.getDynamicProperty(
                                                        "andexdbPersonalSettings:timeZone"
                                                    ) ??
                                                    world.getDynamicProperty(
                                                        "andexdbSettings:timeZone"
                                                    ) ??
                                                    0
                                                ) *
                                                3600000
                                            )
                                                .toLocaleString()
                                                .replace(/^00:/, "12:")} GMT${Number(
                                                    player.getDynamicProperty(
                                                        "andexdbPersonalSettings:timeZone"
                                                    ) ??
                                                    world.getDynamicProperty(
                                                        "andexdbSettings:timeZone"
                                                    ) ??
                                                    0
                                                ) < 0
                                                ? ""
                                                : "+"}${Number(
                                                    player.getDynamicProperty(
                                                        "andexdbPersonalSettings:timeZone"
                                                    ) ??
                                                    world.getDynamicProperty(
                                                        "andexdbSettings:timeZone"
                                                    ) ??
                                                    0
                                                ) % 96} of area ${JSON.stringify(
                                                    args[2]
                                                )}.`
                                        );
                                    }
                                    break;
                                case "clearbackups":
                                    {
                                        if (!player.hasTag(
                                            "canClearAllBackupsOfArea"
                                        )) {
                                            player.sendMessageB(
                                                `§cPermissionsError: You do not have permission to use this sub-command.`
                                            );
                                            return;
                                        }
                                        let args = evaluateParameters(
                                            switchTestB,
                                            [
                                                { type: "presetText" },
                                                { type: "presetText" },
                                                { type: "string" },
                                            ]
                                        ).args;
                                        if (!!!tryget(
                                            () => AreaBackups.get(
                                                "areabackup:" + args[2]
                                            ).from
                                        )) {
                                            player.sendError(
                                                `§cError: No backup area found with the name ${JSON.stringify(
                                                    args[2]
                                                )}.`,
                                                true
                                            );
                                            return;
                                        }
                                        AreaBackups.get(
                                            "areabackup:" + args[2]
                                        ).clearBackups();
                                        player.sendMessageB(
                                            `Cleared all of the backups of area ${JSON.stringify(
                                                args[2]
                                            )}.`
                                        );
                                    }
                                    break;
                                case "deletearea":
                                    {
                                        let args = evaluateParameters(
                                            switchTestB,
                                            [
                                                { type: "presetText" },
                                                { type: "presetText" },
                                                { type: "string" },
                                            ]
                                        ).args;
                                        if (!!!tryget(
                                            () => AreaBackups.get(
                                                "areabackup:" + args[2]
                                            ).from
                                        )) {
                                            player.sendError(
                                                `§cError: No backup area found with the name ${JSON.stringify(
                                                    args[2]
                                                )}.`,
                                                true
                                            );
                                            return;
                                        }
                                        AreaBackups.get(
                                            "areabackup:" + args[2]
                                        ).delete();
                                        player.sendMessageB(
                                            `Deleted the backup area ${JSON.stringify(
                                                args[2]
                                            )}.`
                                        );
                                    }
                                    break;
                                case "clearareas":
                                    {
                                        if (!player.hasTag(
                                            "canClearAllBackupAreas"
                                        )) {
                                            player.sendMessageB(
                                                `§cPermissionsError: You do not have permission to use this sub-command.`
                                            );
                                            return;
                                        }
                                        AreaBackups.clear();
                                        player.sendMessageB(
                                            `Cleared all of the backup areas.`
                                        );
                                    }
                                    break;
                                case "listbackups":
                                    {
                                        let args = evaluateParameters(
                                            switchTestB,
                                            [
                                                { type: "presetText" },
                                                { type: "presetText" },
                                                { type: "string" },
                                            ]
                                        ).args;
                                        if (!!!tryget(
                                            () => AreaBackups.get(
                                                "areabackup:" + args[2]
                                            ).from
                                        )) {
                                            player.sendError(
                                                `§cError: No backup area found with the name ${JSON.stringify(
                                                    args[2]
                                                )}.`,
                                                true
                                            );
                                            return;
                                        }
                                        player.sendMessageB(
                                            AreaBackups.get(
                                                "areabackup:" + args[2]
                                            ).backups.length == 0
                                                ? `§cError: No backups have been saved for this backup area. Please back it up using §e\\snapshot backup ${JSON.stringify(
                                                    args[2]
                                                )}`
                                                : AreaBackups.get(
                                                    "areabackup:" + args[2]
                                                )
                                                    .backups.map(
                                                        (v, i) => `${i}. ${new Date(
                                                            v +
                                                            Number(
                                                                player.getDynamicProperty(
                                                                    "andexdbPersonalSettings:timeZone"
                                                                ) ??
                                                                world.getDynamicProperty(
                                                                    "andexdbSettings:timeZone"
                                                                ) ??
                                                                0
                                                            ) *
                                                            3600000
                                                        )
                                                            .toLocaleString()
                                                            .replace(
                                                                /^00:/,
                                                                "12:"
                                                            )} GMT${Number(
                                                                player.getDynamicProperty(
                                                                    "andexdbPersonalSettings:timeZone"
                                                                ) ??
                                                                world.getDynamicProperty(
                                                                    "andexdbSettings:timeZone"
                                                                ) ??
                                                                0
                                                            ) < 0
                                                                ? ""
                                                                : "+"}${Number(
                                                                    player.getDynamicProperty(
                                                                        "andexdbPersonalSettings:timeZone"
                                                                    ) ??
                                                                    world.getDynamicProperty(
                                                                        "andexdbSettings:timeZone"
                                                                    ) ??
                                                                    0
                                                                ) % 96}`
                                                    )
                                                    .join("\n")
                                        );
                                    }
                                    break;
                                case "listareas":
                                    {
                                        player.sendMessageB(
                                            AreaBackups.ids.length == 0
                                                ? `§cError: No backup areas have been created. Please create a backup area by first selecting the two corners of the area that you want to back up, and then type §e\\backuparea §cfollowed by the id you want to set for the backup area.`
                                                : AreaBackups.ids
                                                    .map(
                                                        (v, i) => `${JSON.stringify(
                                                            v.slice(11)
                                                        )}: ${JSON.stringify(
                                                            AreaBackups.get(
                                                                v
                                                            ).toJSONNoId()
                                                        )}`
                                                    )
                                                    .join("\n")
                                        );
                                    }
                                    break;
                                case "list":
                                    {
                                        player.sendMessageB(
                                            AreaBackups.ids
                                                .map(
                                                    (v, i) => `${JSON.stringify(
                                                        v.slice(11)
                                                    )}: ${JSON.stringify(
                                                        AreaBackups.get(
                                                            v
                                                        ).toJSONNoId()
                                                    )}`
                                                )
                                                .join("\n")
                                        );
                                    }
                                    break;
                            }
                        } catch (e) {
                            perror(player, e);
                        }
                    });
                }
                break;
            case !!switchTest.match(/^selectioninfo$/) ||
                !!switchTest.match(/^selinfo$/) ||
                !!switchTest.match(/^seli$/):
                {
                    eventData.cancel = true;
                    player.sendMessageB(
                        `Currently Selected Area Info: \npos1 x: ${player.getDynamicProperty("pos1")["x"]}\npos1 y: ${player.getDynamicProperty("pos1")["y"]}\npos1 z: ${player.getDynamicProperty("pos1")["z"]}\npos2 x: ${player.getDynamicProperty("pos2")["x"]}\npos2 y: ${player.getDynamicProperty("pos2")["y"]}\npos2 z: ${player.getDynamicProperty("pos2")["z"]}\nNext Selection Mode: ${(player.getDynamicProperty("posM") ?? false)
                            ? "pos2"
                            : "pos1"}`
                    );
                }
                break;
            case !!switchTest.match(/^chunkinfo$/):
                {
                    eventData.cancel = true;
                    player.sendMessageB(
                        `Chunk Info: \nDimension: ${dimensionTypeDisplayFormattingD[player.dimension.id]}\nChunk Index x: ${getChunkIndex(player.location).x}\nChunk Index y: ${getChunkIndex(player.location).y}\nChunk Range: ${JSON.stringify(
                            chunkIndexToBoundingBoxB(
                                getChunkIndex(player.location),
                                player.dimension.heightRange
                            )
                        )}`
                    );
                }
                break;
            case !!switchTest.match(/^butcher$/):
                {
                    eventData.cancel = true;
                    const args = evaluateParameters(switchTestB, [
                        "presetText",
                        "-abfgnprtwipcehljocv",
                        "number",
                    ]).args;
                    args[1] ??= "";
                    const types = (
                        args[1] == ""
                            ? [
                                "minecraft:item",
                                "minecraft:xp_orb",
                                "minecraft:area_effect_cloud",
                            ]
                            : []
                    ) as string[];
                    if ((args[1] as string).includes("a") ||
                        (args[1] as string).includes("f")) {
                        types.push(
                            "minecraft:sheep",
                            "minecraft:cow",
                            "minecraft:pig",
                            "minecraft:horse",
                            "minecraft:sniffer",
                            "minecraft:chicken"
                        );
                    }
                    if ((args[1] as string).includes("h")) {
                        types.push(
                            "minecraft:zombie",
                            "minecraft:husk",
                            "minecraft:drowned",
                            "minecraft:spider",
                            "minecraft:skeleton",
                            "minecraft:slime",
                            "minecraft:blaze",
                            "minecraft:magma_cube",
                            "minecraft:bogged",
                            "minecraft:breeze",
                            "minecraft:cave_spider",
                            "minecraft:creeper",
                            "minecraft:elder_guardian",
                            "minecraft:guardian",
                            "minecraft:enderman",
                            "minecraft:endermite",
                            "minecraft:evocation_illager",
                            "minecraft:ghast",
                            "minecraft:hoglin",
                            "minecraft:phantom",
                            "minecraft:piglin_brute",
                            "minecraft:pillager",
                            "minecraft:ravager",
                            "minecraft:shulker",
                            "minecraft:silverfish",
                            "minecraft:stray",
                            "minecraft:vex",
                            "minecraft:vindicator",
                            "minecraft:warden",
                            "minecraft:witch",
                            "minecraft:wither",
                            "minecraft:ender_dragon",
                            "minecraft:wither_skeleton",
                            "minecraft:zombie_villager",
                            "minecraft:zombie_villager_v2"
                        );
                    }
                    if ((args[1] as string).includes("b") ||
                        (args[1] as string).includes("f")) {
                        types.push("minecraft:bat", "minecraft:bee");
                    }
                    if ((args[1] as string).includes("i")) {
                        types.push("minecraft:item", "minecraft:xp_orb");
                    }
                    if ((args[1] as string).includes("o")) {
                        types.push("minecraft:painting");
                    }
                    if ((args[1] as string).includes("v")) {
                        types.push(
                            "minecraft:minecart",
                            "minecraft:boat",
                            "minecraft:chest_boat",
                            "minecraft:chest_minecart",
                            "minecraft:tnt_minecart",
                            "minecraft:hopper_minecart"
                        );
                    }
                    if ((args[1] as string).includes("c")) {
                        types.push(
                            "minecraft:area_effect_cloud",
                            "minecraft:tnt"
                        );
                    }
                    if ((args[1] as string).includes("j")) {
                        types.push(
                            "minecraft:arrow",
                            "minecraft:snowball",
                            "minecraft:ice_bomb",
                            "minecraft:wind_charge_projectile",
                            "minecraft:egg",
                            "minecraft:dragon_fireball",
                            "minecraft:fireball",
                            "minecraft:small_fireball",
                            "minecraft:xb_bottle",
                            "minecraft:wither_skull",
                            "minecraft:wither_skull_dangerous",
                            "minecraft:thrown_trident",
                            "minecraft:splash_potion",
                            "minecraft:lingering_potion",
                            "minecraft:shulker_bullet"
                        );
                    }
                    if ((args[1] as string).includes("n")) {
                        types.push("minecraft:npc");
                    }
                    if ((args[1] as string).includes("g") ||
                        (args[1] as string).includes("f")) {
                        types.push(
                            "minecraft:iron_golem",
                            "minecraft:snow_golem",
                            "minecraft:copper_golem",
                            "minecraft:tuff_golem"
                        );
                    }
                    if ((args[1] as string).includes("r")) {
                        types.push("minecraft:armor_stand");
                    }
                    if ((args[1] as string).includes("w")) {
                        types.push(
                            "minecraft:dolphin",
                            "minecraft:drowned",
                            "minecraft:sea_turtle",
                            "minecraft:salmon",
                            "minecraft:tropical_fish",
                            "minecraft:cod",
                            "minecraft:guardian",
                            "minecraft:elder_guardian"
                        );
                    }
                    if ((args[1] as string).includes("p")) {
                        types.push("minecraft:player");
                    }
                    if ((args[1] as string).includes("c")) {
                        types.push("andexsa:cloned_player");
                    }
                    if ((args[1] as string).includes("l")) {
                        types.push(
                            "minecraft:ender_dragon",
                            "minecraft:wither",
                            "minecraft:elder_guardian",
                            "minecraft:warden"
                        );
                    }
                    srun(() => {
                        let sc = 0n;
                        player.dimension
                            .getEntities({
                                maxDistance: args[2] ?? 10,
                                location: player.location,
                            })
                            .filter(
                                (v) => (types.includes(v.typeId) &&
                                    (v.nameTag == "" ||
                                        (args[1] as string).includes(
                                            "t"
                                        ))) ||
                                    (args[1] as string).includes("e")
                            )
                            .forEach((v) => {
                                v.kill();
                                sc++;
                            });
                        player.sendMessageB(
                            `${sc == 0n ? "§c" : ""}Butchered ${sc} entit${sc == 1n ? "y" : "ies"}.`
                        );
                    });
                }
                break;
            case !!switchTest.match(/^butcherdespawn$/):
                {
                    eventData.cancel = true;
                    const args = evaluateParameters(switchTestB, [
                        "presetText",
                        "-abfgnprtwipcehljocv",
                        "number",
                    ]).args;
                    args[1] ??= "";
                    const types = (
                        args[1] == ""
                            ? [
                                "minecraft:item",
                                "minecraft:experience_orb",
                                "minecraft:area_effect_cloud",
                            ]
                            : []
                    ) as string[];
                    if ((args[1] as string).includes("a") ||
                        (args[1] as string).includes("f")) {
                        types.push(
                            "minecraft:sheep",
                            "minecraft:cow",
                            "minecraft:pig",
                            "minecraft:horse",
                            "minecraft:sniffer",
                            "minecraft:chicken"
                        );
                    }
                    if ((args[1] as string).includes("h")) {
                        types.push(
                            "minecraft:zombie",
                            "minecraft:husk",
                            "minecraft:drowned",
                            "minecraft:spider",
                            "minecraft:skeleton",
                            "minecraft:slime",
                            "minecraft:blaze",
                            "minecraft:magma_cube",
                            "minecraft:bogged",
                            "minecraft:breeze",
                            "minecraft:cave_spider",
                            "minecraft:creeper",
                            "minecraft:elder_guardian",
                            "minecraft:guardian",
                            "minecraft:enderman",
                            "minecraft:endermite",
                            "minecraft:evocation_illager",
                            "minecraft:ghast",
                            "minecraft:hoglin",
                            "minecraft:phantom",
                            "minecraft:piglin_brute",
                            "minecraft:pillager",
                            "minecraft:ravager",
                            "minecraft:shulker",
                            "minecraft:silverfish",
                            "minecraft:stray",
                            "minecraft:vex",
                            "minecraft:vindicator",
                            "minecraft:warden",
                            "minecraft:witch",
                            "minecraft:wither",
                            "minecraft:ender_dragon",
                            "minecraft:wither_skeleton",
                            "minecraft:zombie_villager",
                            "minecraft:zombie_villager_v2"
                        );
                    }
                    if ((args[1] as string).includes("b") ||
                        (args[1] as string).includes("f")) {
                        types.push("minecraft:bat", "minecraft:bee");
                    }
                    if ((args[1] as string).includes("i")) {
                        types.push("minecraft:item", "minecraft:xp_orb");
                    }
                    if ((args[1] as string).includes("o")) {
                        types.push("minecraft:painting");
                    }
                    if ((args[1] as string).includes("v")) {
                        types.push(
                            "minecraft:minecart",
                            "minecraft:boat",
                            "minecraft:chest_boat",
                            "minecraft:chest_minecart",
                            "minecraft:tnt_minecart",
                            "minecraft:hopper_minecart"
                        );
                    }
                    if ((args[1] as string).includes("c")) {
                        types.push(
                            "minecraft:area_effect_cloud",
                            "minecraft:tnt"
                        );
                    }
                    if ((args[1] as string).includes("j")) {
                        types.push(
                            "minecraft:arrow",
                            "minecraft:snowball",
                            "minecraft:ice_bomb",
                            "minecraft:wind_charge_projectile",
                            "minecraft:egg",
                            "minecraft:dragon_fireball",
                            "minecraft:fireball",
                            "minecraft:small_fireball",
                            "minecraft:xb_bottle",
                            "minecraft:wither_skull",
                            "minecraft:wither_skull_dangerous",
                            "minecraft:thrown_trident",
                            "minecraft:splash_potion",
                            "minecraft:lingering_potion",
                            "minecraft:shulker_bullet"
                        );
                    }
                    if ((args[1] as string).includes("n")) {
                        types.push("minecraft:npc");
                    }
                    if ((args[1] as string).includes("g") ||
                        (args[1] as string).includes("f")) {
                        types.push(
                            "minecraft:iron_golem",
                            "minecraft:snow_golem",
                            "minecraft:copper_golem",
                            "minecraft:tuff_golem"
                        );
                    }
                    if ((args[1] as string).includes("r")) {
                        types.push("minecraft:armor_stand");
                    }
                    if ((args[1] as string).includes("w")) {
                        types.push(
                            "minecraft:dolphin",
                            "minecraft:drowned",
                            "minecraft:sea_turtle",
                            "minecraft:salmon",
                            "minecraft:tropical_fish",
                            "minecraft:cod",
                            "minecraft:guardian",
                            "minecraft:elder_guardian"
                        );
                    }
                    if ((args[1] as string).includes("p")) {
                        types.push("minecraft:player");
                    }
                    if ((args[1] as string).includes("c")) {
                        types.push("andexsa:cloned_player");
                    }
                    if ((args[1] as string).includes("l")) {
                        types.push(
                            "minecraft:ender_dragon",
                            "minecraft:wither",
                            "minecraft:elder_guardian",
                            "minecraft:warden"
                        );
                    }
                    srun(() => {
                        let sc = 0n;
                        player.dimension
                            .getEntities({
                                maxDistance: args[2] ?? 10,
                                location: player.location,
                            })
                            .filter(
                                (v) => (types.includes(v.typeId) &&
                                    (v.nameTag == "" ||
                                        (args[1] as string).includes(
                                            "t"
                                        ))) ||
                                    (args[1] as string).includes("e")
                            )
                            .forEach((v) => {
                                v.typeId == "minecraft:player"
                                    ? despawnEntities([v])
                                    : v.remove();
                                sc++;
                            });
                        player.sendMessageB(
                            `${sc == 0n ? "§c" : ""}Butchered ${sc} entit${sc == 1n ? "y" : "ies"}.`
                        );
                    });
                }
                break;
            case !!switchTest.match(/^replacenear$/):
                {
                    eventData.cancel = true;
                    const args = evaluateParameters(switchTestB, [
                        "presetText",
                        "f-c",
                        "number",
                        "string",
                        "blockStates",
                        "string",
                        "blockStates",
                    ]).args;
                    const firstblockname = args[3];
                    const firstblockstates = args[4];
                    const lastblockname = args[5];
                    const lastblockstates = args[6];
                    const matchingblock: [
                        string,
                        { [id: string]: string | number | boolean; }?
                    ] = (lastblockname ?? "") == ""
                            ? [undefined, undefined]
                            : lastblockname == "keep"
                                ? ["air"]
                                : [
                                    BlockTypes.get(lastblockname).id,
                                    lastblockstates,
                                ];
                    const coordinatesa = Vector3Utils.add(
                        player.location,
                        { x: -args[2], y: -args[2], z: -args[2] }
                    );
                    const coordinatesb = Vector3Utils.add(
                        player.location,
                        { x: args[2], y: args[2], z: args[2] }
                    );
                    const blocktypes = BlockTypes.getAll();
                    system.run(() => {
                        let ta: Entity[];
                        try {
                            generateTickingAreaFillCoordinatesC(
                                player.location,
                                (() => {
                                    let a = new CompoundBlockVolume();
                                    a.pushVolume({
                                        volume: new BlockVolume(
                                            coordinatesa,
                                            coordinatesb
                                        ),
                                    });
                                    return a;
                                })(),
                                player.dimension
                            ).then((tac) => {
                                ta = tac;
                                try {
                                    fillBlocksHFG(
                                        coordinatesa,
                                        coordinatesb,
                                        player.dimension,
                                        matchingblock[0] == "random"
                                            ? () => blocktypes[Math.floor(
                                                blocktypes.length *
                                                Math.random()
                                            )]
                                            : matchingblock[0],
                                        matchingblock[1],
                                        {
                                            matchingBlock: firstblockname,
                                            matchingBlockStates: firstblockstates,
                                            minMSBetweenYields: 2500,
                                        },
                                        undefined,
                                        args[1].c,
                                        100
                                    ).then(
                                        (a) => {
                                            player.sendMessageB(
                                                `${a.counter == 0 ? "§c" : ""}${a.counter} blocks replaced in ${a.completionData.endTime -
                                                a.completionData.startTime} ms over ${a.completionData.endTick -
                                                a.completionData.startTick} tick${a.completionData.endTick -
                                                    a.completionData
                                                        .startTick ==
                                                    1
                                                    ? ""
                                                    : "s"}${a.completionData
                                                    .containsUnloadedChunks
                                                    ? "; Some blocks were not generated because they were in unloaded chunks. "
                                                    : ""}`
                                            );
                                        },
                                        (e) => {
                                            player.sendError(
                                                "§c" + e + e.stack,
                                                true
                                            );
                                        }
                                    );
                                } catch (e) {
                                    player.sendError("§c" + e + e.stack, true);
                                } finally {
                                    tac.forEach((tab) => tab?.remove());
                                }
                            });
                        } catch (e) {
                            player.sendError("§c" + e + e.stack, true);
                        }
                    });
                }
                break;
            case !!switchTest.match(/^jumpto$/) || !!switchTest.match(/^j$/):
                {
                    eventData.cancel = true;
                    let blockHit = player.getBlockFromViewDirection({
                        includeLiquidBlocks: false,
                        includePassableBlocks: false,
                    });
                    let dir = blockHit.face == "Down"
                        ? VECTOR3_DOWN
                        : blockHit.face == "Up"
                            ? VECTOR3_UP
                            : blockHit.face == "North"
                                ? VECTOR3_SOUTH
                                : blockHit.face == "South"
                                    ? VECTOR3_NORTH
                                    : blockHit.face == "East"
                                        ? VECTOR3_EAST
                                        : VECTOR3_WEST;
                    srun(() => player.teleport(
                        roundVector3ToMiddleOfBlockFloorY(
                            Vector3Utils.add(
                                blockHit.block.location,
                                dir
                            )
                        )
                    )
                    );
                }
                break;
            case !!switchTest.match(/^align$/):
                {
                    eventData.cancel = true;
                    srun(() => player.teleport(
                        roundVector3ToMiddleOfBlockFloorY(player.location)
                    )
                    );
                }
                break;
            case !!switchTest.match(/^aligncenter$/):
                {
                    eventData.cancel = true;
                    srun(() => player.teleport(
                        roundVector3ToMiddleOfBlock(player.location)
                    )
                    );
                }
                break;
            case !!switchTest.match(/^getworldspawnpoint$/) ||
                !!switchTest.match(/^getworldspawn$/) ||
                !!switchTest.match(/^getwsp$/) ||
                !!switchTest.match(/^getws$/) ||
                !!switchTest.match(/^gwsp$/) ||
                !!switchTest.match(/^gws$/):
                {
                    eventData.cancel = true;
                    player.sendMessageB(
                        `World Spawn: ${vTStr(world.getDefaultSpawnLocation())}`
                    );
                }
                break;
            case !!switchTest.match(/^findtransformdvindex$/):
                {
                    eventData.cancel = true;
                    const args = evaluateParameters(switchTestB, [
                        "presetText",
                        "string",
                        "number",
                    ]).args as [string, string, number];
                    !args[1].includes(":")
                        ? (args[1] = "minecraft:" + args[1])
                        : undefined;
                    player.sendMessageB(
                        listoftransformrecipes.findIndex(
                            (v) => v.id == args[1] &&
                                ((!!!v["data"] && !!!args[2]) ||
                                    v["data"] == args[2])
                        ) == -1
                            ? "§cError: Could not find a suitable data value for enchantment transfer smithing template to create the specified item with the specified data value."
                            : `Data value for enchantment transfer smithing template is ${listoftransformrecipes.findIndex(
                                (v) => v.id == args[1] &&
                                    ((!!!v["data"] && !!!args[2]) ||
                                        v["data"] == args[2])
                            )}.`
                    );
                }
                break;
            case !!switchTest.match(/^gettransformst$/):
                {
                    eventData.cancel = true;
                    const args = evaluateParameters(switchTestB, [
                        "presetText",
                        "string",
                        "number",
                    ]).args as [string, string, number];
                    !args[1].includes(":")
                        ? (args[1] = "minecraft:" + args[1])
                        : undefined;
                    player.runCommandAsync(
                        `/give @s andexdb:enchantment_transfer_smithing_template 1 ${listoftransformrecipes.findIndex(
                            (v) => v.id == args[1] &&
                                ((!!!v["data"] && !!!args[2]) ||
                                    v["data"] == args[2])
                        )}`
                    );
                    player.sendMessageB(
                        listoftransformrecipes.findIndex(
                            (v) => v.id == args[1] &&
                                ((!!!v["data"] && !!!args[2]) ||
                                    v["data"] == args[2])
                        ) == -1
                            ? "§cError: Could not find a suitable data value for enchantment transfer smithing template to create the specified item with the specified data value."
                            : `You have been given an enchantment transfer smithing template with the data value ${listoftransformrecipes.findIndex(
                                (v) => v.id == args[1] &&
                                    ((!!!v["data"] && !!!args[2]) ||
                                        v["data"] == args[2])
                            )}.`
                    );
                }
                break;
            case !!switchTest.match(/^transformresultatdvindex$/):
                {
                    eventData.cancel = true;
                    const args = evaluateParameters(switchTestB, [
                        "presetText",
                        "number",
                    ]).args as [string, number];
                    player.sendMessageB(
                        `Enchantment transfer smithing template result at data value ${args[1]} is ${JSON.stringify(
                            listoftransformrecipes[args[1]]
                        )}.`
                    );
                }
                break;
            case !!switchTest.match(/^removeotheritemenchantments$/) ||
                !!switchTest.match(/^remotheritemenchants$/) ||
                !!switchTest.match(/^roie$/):
                {
                    eventData.cancel = true;
                    srun(() => {
                        try {
                            let item = getPlayerHeldItemSlot(player).getItem();
                            const args = evaluateParameters(switchTestB, [
                                "presetText",
                                "json",
                            ]).args;
                            EnchantmentTypes.getAll()
                                .map((v) => v.id)
                                .filter((v) => !args[1].includes(v))
                                .forEach((v) => item
                                    .getComponent("enchantable")
                                    .removeEnchantment(v)
                                );
                            getPlayerHeldItemSlot(player).setItem(item);
                            player.sendMessageB(
                                `Successfully removed all other enchantment types from the item.`
                            );
                        } catch (e) {
                            player.sendMessageB("§c" + e + " " + e.stack);
                        }
                    });
                }
                break;
            case !!switchTest.match(/^ignite$/):
                {
                    eventData.cancel = true;
                    let radius = Number(
                        String(switchTestB.split(" ")[1] ?? "").trim() == ""
                            ? 10
                            : String(switchTestB.split(" ")[1] ?? "").trim()
                    );
                    let froma = Vector3Utils.subtract(player.location, {
                        x: radius,
                        y: radius,
                        z: radius,
                    });
                    let from = { x: froma.x, y: froma.y, z: froma.z };
                    let toa = Vector3Utils.add(player.location, {
                        x: radius,
                        y: radius,
                        z: radius,
                    });
                    let to = { x: toa.x, y: toa.y, z: toa.z };
                    try {
                        system.run(() => {
                            let a = fillBlocksHB(
                                from,
                                to,
                                player.dimension,
                                "fire",
                                undefined,
                                { matchingBlock: "air" }
                            );
                            player.sendMessageB(
                                `${a == 0 ? "§c" : ""}${a} blocks ignited in radius of ${radius}`
                            );
                        });
                    } catch (e) {
                        player.sendError("§c" + e + e.stack, true);
                    }
                }
                break;
            case !!switchTest.match(/^extinguish$/) ||
                !!switchTest.match(/^ext$/) ||
                !!switchTest.match(/^remfire$/) ||
                !!switchTest.match(/^ex$/):
                {
                    eventData.cancel = true;
                    let radius = Number(
                        String(switchTestB.split(" ")[1] ?? "").trim() == ""
                            ? 10
                            : String(switchTestB.split(" ")[1] ?? "").trim()
                    );
                    let froma = Vector3Utils.subtract(player.location, {
                        x: radius,
                        y: radius,
                        z: radius,
                    });
                    let from = { x: froma.x, y: froma.y, z: froma.z };
                    let toa = Vector3Utils.add(player.location, {
                        x: radius,
                        y: radius,
                        z: radius,
                    });
                    let to = { x: toa.x, y: toa.y, z: toa.z };
                    try {
                        system.run(() => {
                            let a = fillBlocksHB(
                                from,
                                to,
                                player.dimension,
                                "air",
                                undefined,
                                { matchingBlock: "fire" }
                            );
                            let b = fillBlocksHB(
                                from,
                                to,
                                player.dimension,
                                "air",
                                undefined,
                                { matchingBlock: "soul_fire" }
                            );
                            player.sendMessageB(
                                `${a + b == 0 ? "§c" : ""}${a + b} blocks extinguished in radius of ${radius}`
                            );
                        });
                    } catch (e) {
                        player.sendError("§c" + e + e.stack, true);
                    }
                }
                break;
            case !!switchTest.match(/^remexp$/):
                {
                    eventData.cancel = true;
                    let radius = Number(
                        String(switchTestB.split(" ")[1] ?? "").trim() == ""
                            ? 10
                            : String(switchTestB.split(" ")[1] ?? "").trim()
                    );
                    let froma = Vector3Utils.subtract(player.location, {
                        x: radius,
                        y: radius,
                        z: radius,
                    });
                    let from = { x: froma.x, y: froma.y, z: froma.z };
                    let toa = Vector3Utils.add(player.location, {
                        x: radius,
                        y: radius,
                        z: radius,
                    });
                    let to = { x: toa.x, y: toa.y, z: toa.z };
                    switch (player.dimension.id) {
                        case "minecraft:overworld":
                            try {
                                system.run(() => {
                                    let a = fillBlocksHB(
                                        from,
                                        to,
                                        player.dimension,
                                        "air",
                                        undefined,
                                        { matchingBlock: "tnt" }
                                    );
                                    let b = fillBlocksHB(
                                        from,
                                        to,
                                        player.dimension,
                                        "air",
                                        undefined,
                                        { matchingBlock: "respawn_anchor" }
                                    );
                                    player.sendMessageB(
                                        `${a + b == 0 ? "§c" : ""}${a + b} explosives removed in radius of ${radius}`
                                    );
                                });
                            } catch (e) {
                                player.sendError("§c" + e + e.stack, true);
                            }
                            break;
                        case "minecraft:nether":
                            try {
                                system.run(() => {
                                    let a = fillBlocksHB(
                                        from,
                                        to,
                                        player.dimension,
                                        "air",
                                        undefined,
                                        { matchingBlock: "tnt" }
                                    );
                                    let b = fillBlocksHB(
                                        from,
                                        to,
                                        player.dimension,
                                        "air",
                                        undefined,
                                        { matchingBlock: "bed" }
                                    );
                                    player.sendMessageB(
                                        `${a + b == 0 ? "§c" : ""}${a + b} explosives removed in radius of ${radius}`
                                    );
                                });
                            } catch (e) {
                                player.sendError("§c" + e + e.stack, true);
                            }
                            break;
                        case "minecraft:the_end":
                            try {
                                system.run(() => {
                                    let a = fillBlocksHB(
                                        from,
                                        to,
                                        player.dimension,
                                        "air",
                                        undefined,
                                        { matchingBlock: "tnt" }
                                    );
                                    let b = fillBlocksHB(
                                        from,
                                        to,
                                        player.dimension,
                                        "air",
                                        undefined,
                                        { matchingBlock: "respawn_anchor" }
                                    );
                                    let c = fillBlocksHB(
                                        from,
                                        to,
                                        player.dimension,
                                        "air",
                                        undefined,
                                        { matchingBlock: "bed" }
                                    );
                                    player.sendMessageB(
                                        `${a + b + c == 0 ? "§c" : ""}${a + b + c} explosives removed in radius of ${radius}`
                                    );
                                });
                            } catch (e) {
                                player.sendError("§c" + e + e.stack, true);
                            }
                            break;
                        default:
                            try {
                                system.run(() => {
                                    let a = fillBlocksHB(
                                        from,
                                        to,
                                        player.dimension,
                                        "air",
                                        undefined,
                                        { matchingBlock: "tnt" }
                                    );
                                    player.sendMessageB(
                                        `${a == 0 ? "§c" : ""}${a} explosives removed in radius of ${radius}`
                                    );
                                });
                            } catch (e) {
                                player.sendError("§c" + e + e.stack, true);
                            }
                    }
                    srun(() => [
                        ...player.dimension.getEntities({
                            location: player.location,
                            type: "minecraft:tnt",
                            maxDistance: radius,
                        }),
                        ...player.dimension.getEntities({
                            location: player.location,
                            type: "minecraft:tnt_minecart",
                            maxDistance: radius,
                        }),
                        ...player.dimension.getEntities({
                            location: player.location,
                            type: "projectile:tnt",
                            maxDistance: radius,
                        }),
                        ...player.dimension.getEntities({
                            location: player.location,
                            type: "andexsa:fire_tnt_arrow",
                            maxDistance: radius,
                        }),
                        ...player.dimension.getEntities({
                            location: player.location,
                            type: "andexsa:normal_fire_tnt_arrow",
                            maxDistance: radius,
                        }),
                        ...player.dimension.getEntities({
                            location: player.location,
                            type: "andexsa:normal_tnt_arrow",
                            maxDistance: radius,
                        }),
                        ...player.dimension.getEntities({
                            location: player.location,
                            type: "andexsa:tnt_arrow",
                            maxDistance: radius,
                        }),
                    ].forEach((v) => v.remove())
                    );
                }
                break;
            case !!switchTest.match(/^remexpne$/):
                {
                    eventData.cancel = true;
                    let radius = Number(
                        String(switchTestB.split(" ")[1] ?? "").trim() == ""
                            ? 10
                            : String(switchTestB.split(" ")[1] ?? "").trim()
                    );
                    let froma = Vector3Utils.subtract(player.location, {
                        x: radius,
                        y: radius,
                        z: radius,
                    });
                    let from = { x: froma.x, y: froma.y, z: froma.z };
                    let toa = Vector3Utils.add(player.location, {
                        x: radius,
                        y: radius,
                        z: radius,
                    });
                    let to = { x: toa.x, y: toa.y, z: toa.z };
                    switch (player.dimension.id) {
                        case "minecraft:overworld":
                            try {
                                system.run(() => {
                                    let a = fillBlocksHB(
                                        from,
                                        to,
                                        player.dimension,
                                        "air",
                                        undefined,
                                        { matchingBlock: "tnt" }
                                    );
                                    let b = fillBlocksHB(
                                        from,
                                        to,
                                        player.dimension,
                                        "air",
                                        undefined,
                                        { matchingBlock: "respawn_anchor" }
                                    );
                                    player.sendMessageB(
                                        `${a + b == 0 ? "§c" : ""}${a + b} explosives removed in radius of ${radius}`
                                    );
                                });
                            } catch (e) {
                                player.sendError("§c" + e + e.stack, true);
                            }
                            break;
                        case "minecraft:nether":
                            try {
                                system.run(() => {
                                    let a = fillBlocksHB(
                                        from,
                                        to,
                                        player.dimension,
                                        "air",
                                        undefined,
                                        { matchingBlock: "tnt" }
                                    );
                                    let b = fillBlocksHB(
                                        from,
                                        to,
                                        player.dimension,
                                        "air",
                                        undefined,
                                        { matchingBlock: "bed" }
                                    );
                                    player.sendMessageB(
                                        `${a + b == 0 ? "§c" : ""}${a + b} explosives removed in radius of ${radius}`
                                    );
                                });
                            } catch (e) {
                                player.sendError("§c" + e + e.stack, true);
                            }
                            break;
                        case "minecraft:the_end":
                            try {
                                system.run(() => {
                                    let a = fillBlocksHB(
                                        from,
                                        to,
                                        player.dimension,
                                        "air",
                                        undefined,
                                        { matchingBlock: "tnt" }
                                    );
                                    let b = fillBlocksHB(
                                        from,
                                        to,
                                        player.dimension,
                                        "air",
                                        undefined,
                                        { matchingBlock: "respawn_anchor" }
                                    );
                                    let c = fillBlocksHB(
                                        from,
                                        to,
                                        player.dimension,
                                        "air",
                                        undefined,
                                        { matchingBlock: "bed" }
                                    );
                                    player.sendMessageB(
                                        `${a + b + c == 0 ? "§c" : ""}${a + b + c} explosives removed in radius of ${radius}`
                                    );
                                });
                            } catch (e) {
                                player.sendError("§c" + e + e.stack, true);
                            }
                            break;
                        default:
                            try {
                                system.run(() => {
                                    let a = fillBlocksHB(
                                        from,
                                        to,
                                        player.dimension,
                                        "air",
                                        undefined,
                                        { matchingBlock: "tnt" }
                                    );
                                    player.sendMessageB(
                                        `${a == 0 ? "§c" : ""}${a} explosives removed in radius of ${radius}`
                                    );
                                });
                            } catch (e) {
                                player.sendError("§c" + e + e.stack, true);
                            }
                    }
                }
                break;
            case !!switchTest.match(/^drain$/):
                {
                    eventData.cancel = true;
                    let radius = Number(
                        String(switchTestB.split(" ")[1] ?? "").trim() == ""
                            ? 10
                            : String(switchTestB.split(" ")[1] ?? "").trim()
                    );
                    let froma = Vector3Utils.subtract(player.location, {
                        x: radius,
                        y: radius,
                        z: radius,
                    });
                    let from = { x: froma.x, y: froma.y, z: froma.z };
                    let toa = Vector3Utils.add(player.location, {
                        x: radius,
                        y: radius,
                        z: radius,
                    });
                    let to = { x: toa.x, y: toa.y, z: toa.z };
                    system.run(() => {
                        let ta: Entity[];
                        try {
                            generateTickingAreaFillCoordinatesC(
                                player.location,
                                (() => {
                                    let a = new CompoundBlockVolume();
                                    a.pushVolume({
                                        volume: new BlockVolume(from, to),
                                    });
                                    return a;
                                })(),
                                player.dimension
                            ).then((tac) => {
                                ta = tac;
                                try {
                                    undoClipboard.save(
                                        player.dimension,
                                        { from: from, to: to },
                                        Date.now(),
                                        {
                                            includeBlocks: true,
                                            includeEntities: false,
                                            saveMode: config.undoClipboardMode,
                                        }
                                    );
                                } catch (e) {
                                    perror(player, e);
                                }
                                try {
                                    fillBlocksHDFGB(
                                        from,
                                        to,
                                        player.dimension,
                                        { minMSBetweenYields: 2500 },
                                        100
                                    ).then(
                                        (a) => {
                                            player.sendMessageB(
                                                `${a.counter == 0 ? "§c" : ""}${a.counter} blocks replaced in ${a.completionData.endTime -
                                                a.completionData.startTime} ms over ${a.completionData.endTick -
                                                a.completionData.startTick} tick${a.completionData.endTick -
                                                    a.completionData
                                                        .startTick ==
                                                    1
                                                    ? ""
                                                    : "s"}${a.completionData
                                                    .containsUnloadedChunks
                                                    ? "; Some blocks were not drained because they were in unloaded chunks. "
                                                    : ""}`
                                            );
                                        },
                                        (e) => {
                                            player.sendError(
                                                "§c" + e + e.stack,
                                                true
                                            );
                                        }
                                    );
                                } catch (e) {
                                    player.sendError("§c" + e + e.stack, true);
                                } finally {
                                    tac.forEach((tab) => tab?.remove());
                                }
                            });
                        } catch (e) {
                            player.sendError("§c" + e + e.stack, true);
                        }
                    });
                    //try{system.run(()=>{let a = fillBlocksHB(from, to, player.dimension, "air", undefined, {matchingBlock: "water"}); let b = fillBlocksHB(from, to, player.dimension, "air", undefined, {matchingBlock: "lava"}); let c = fillBlocksHB(from, to, player.dimension, "air", undefined, {matchingBlock: "flowing_water"}); let d = fillBlocksHB(from, to, player.dimension, "air", undefined, {matchingBlock: "flowing_lava"}); player.sendMessageB(`${a+b+c+d==0?"§c":""}${a+b+c+d} liquids removed in radius of ${radius}`); }); }catch(e){player.sendError("§c" + e + e.stack, true)}
                }
                break;
            case !!switchTest.match(/^attribute$/):
                {
                    eventData.cancel = true;
                    let argsa = evaluateParameters(switchTestB, [
                        "presetText",
                        "targetSelector",
                        "presetText",
                        "presetText",
                    ]);
                    let targets = targetSelectorAllListC(
                        argsa.args[0],
                        "",
                        vTStr(player.location),
                        player
                    );
                    srun(() => {
                        switch (argsa.args[3]) {
                            case "get":
                                {
                                    targets.forEach((target) => {
                                        try {
                                            let directory = {
                                                Components: {},
                                                get ["minecraft:generic.air"]() {
                                                    return target.getComponent(
                                                        "breathable"
                                                    ).airSupply;
                                                },
                                                set ["minecraft:generic.air"](
                                                    airSupply: number
                                                ) {
                                                    target.getComponent(
                                                        "breathable"
                                                    ).airSupply = airSupply;
                                                },
                                                get ["minecraft:generic.is_sneaking"]() {
                                                    return target.isSneaking;
                                                },
                                                set ["minecraft:generic.is_sneaking"](
                                                    isSneaking: boolean
                                                ) {
                                                    target.isSneaking =
                                                        isSneaking;
                                                },
                                                get ["minecraft:generic.max_health"]() {
                                                    return target.getComponent(
                                                        "health"
                                                    ).effectiveMax;
                                                },
                                                get ["minecraft:generic.min_health"]() {
                                                    return target.getComponent(
                                                        "health"
                                                    ).effectiveMin;
                                                },
                                                get ["minecraft:generic.default_health"]() {
                                                    return target.getComponent(
                                                        "health"
                                                    ).defaultValue;
                                                },
                                                get ["minecraft:generic.health"]() {
                                                    return target.getComponent(
                                                        "health"
                                                    ).currentValue;
                                                },
                                                set ["minecraft:generic.health"](
                                                    currentValue: number
                                                ) {
                                                    target
                                                        .getComponent("health")
                                                        .setCurrentValue(
                                                            currentValue
                                                        );
                                                },
                                                get ["minecraft:generic.max_lava_movement_speed"]() {
                                                    return target.getComponent(
                                                        "lava_movement"
                                                    ).effectiveMax;
                                                },
                                                get ["minecraft:generic.min_lava_movement_speed"]() {
                                                    return target.getComponent(
                                                        "lava_movement"
                                                    ).effectiveMin;
                                                },
                                                get ["minecraft:generic.default_lava_movement_speed"]() {
                                                    return target.getComponent(
                                                        "lava_movement"
                                                    ).defaultValue;
                                                },
                                                get ["minecraft:generic.lava_movement_speed"]() {
                                                    return target.getComponent(
                                                        "lava_movement"
                                                    ).currentValue;
                                                },
                                                set ["minecraft:generic.lava_movement_speed"](
                                                    currentValue: number
                                                ) {
                                                    target
                                                        .getComponent(
                                                            "lava_movement"
                                                        )
                                                        .setCurrentValue(
                                                            currentValue
                                                        );
                                                },
                                                get ["minecraft:generic.max_water_movement_speed"]() {
                                                    return target.getComponent(
                                                        "underwater_movement"
                                                    ).effectiveMax;
                                                },
                                                get ["minecraft:generic.min_water_movement_speed"]() {
                                                    return target.getComponent(
                                                        "underwater_movement"
                                                    ).effectiveMin;
                                                },
                                                get ["minecraft:generic.default_water_movement_speed"]() {
                                                    return target.getComponent(
                                                        "underwater_movement"
                                                    ).defaultValue;
                                                },
                                                get ["minecraft:generic.water_movement_speed"]() {
                                                    return target.getComponent(
                                                        "underwater_movement"
                                                    ).currentValue;
                                                },
                                                set ["minecraft:generic.water_movement_speed"](
                                                    currentValue: number
                                                ) {
                                                    target
                                                        .getComponent(
                                                            "underwater_movement"
                                                        )
                                                        .setCurrentValue(
                                                            currentValue
                                                        );
                                                },
                                                get ["minecraft:generic.max_movement_speed"]() {
                                                    return target.getComponent(
                                                        "health"
                                                    ).effectiveMax;
                                                },
                                                get ["minecraft:generic.min_movement_speed"]() {
                                                    return target.getComponent(
                                                        "health"
                                                    ).effectiveMin;
                                                },
                                                get ["minecraft:generic.default_movement_speed"]() {
                                                    return target.getComponent(
                                                        "health"
                                                    ).defaultValue;
                                                },
                                                get ["minecraft:generic.movement_speed"]() {
                                                    return target.getComponent(
                                                        "health"
                                                    ).currentValue;
                                                },
                                                set ["minecraft:generic.movement_speed"](
                                                    currentValue: number
                                                ) {
                                                    target
                                                        .getComponent("health")
                                                        .setCurrentValue(
                                                            currentValue
                                                        );
                                                },
                                                get ["minecraft:generic.flying_speed"]() {
                                                    return target.getComponent(
                                                        "flying_speed"
                                                    ).value;
                                                },
                                                set ["minecraft:generic.flying_speed"](
                                                    value: number
                                                ) {
                                                    target.getComponent(
                                                        "flying_speed"
                                                    ).value = value;
                                                },
                                                get ["minecraft:generic.scale"]() {
                                                    return target.getComponent(
                                                        "scale"
                                                    ).value;
                                                },
                                                set ["minecraft:generic.scale"](
                                                    value: number
                                                ) {
                                                    target.getComponent(
                                                        "scale"
                                                    ).value = value;
                                                },
                                            };
                                            pbsend(
                                                player,
                                                directory[argsa.args[1]]
                                            );
                                        } catch (e) {
                                            player.sendError(e);
                                        }
                                    });
                                }
                                break;
                            default:
                                break;
                        }
                    });
                }
                break;
            case !!switchTest.match(/^data$/):
                {
                    eventData.cancel = true;
                    let argsa = evaluateParameters(switchTestB, [
                        "presetText",
                        "presetText",
                        "presetText",
                    ]);
                    srun(() => {
                        switch (argsa.args[1]) {
                            case "get":
                                switch (argsa.args[2]) {
                                    case "block":
                                        break;
                                    case "entity":
                                        let argsb = evaluateParameters(
                                            argsa.extra,
                                            ["targetSelector"]
                                        );
                                        let targets = targetSelectorAllListC(
                                            argsb.args[0],
                                            "",
                                            vTStr(player.location),
                                            player
                                        );
                                        //([$_\p{Lu}\p{Ll}\p{Lt}\p{Lm}\p{Lo}\p{Nl}][$_\p{Lu}\p{Ll}\p{Lt}\p{Lm}\p{Lo}\p{Nl}\u200C\u200D\p{Mn}\p{Mc}\p{Nd}\p{Pc}]*)
                                        let path = argsb.extra
                                            .trim()
                                            .match(
                                                /(?:\[(\d+)\]|\["((?:[^"]|(?<!(?:(?:[^\\]\\)(?:\\\\)*))")*)"\]|(?<=\.)([$_\p{Lu}\p{Ll}\p{Lt}\p{Lm}\p{Lo}\p{Nl}][$_\p{Lu}\p{Ll}\p{Lt}\p{Lm}\p{Lo}\p{Nl}\u200C\u200D\p{Mn}\p{Mc}\p{Nd}\p{Pc}]*)|^([$_\p{Lu}\p{Ll}\p{Lt}\p{Lm}\p{Lo}\p{Nl}][$_\p{Lu}\p{Ll}\p{Lt}\p{Lm}\p{Lo}\p{Nl}\u200C\u200D\p{Mn}\p{Mc}\p{Nd}\p{Pc}]*))/gu
                                            );
                                        targets.forEach((target) => {
                                            try {
                                                let directory = {
                                                    Components: {},
                                                    get Air() {
                                                        return target.getComponent(
                                                            "breathable"
                                                        ).airSupply;
                                                    },
                                                    set Air(airSupply: number) {
                                                        target.getComponent(
                                                            "breathable"
                                                        ).airSupply = airSupply;
                                                    },
                                                };
                                                Object.keys(
                                                    EntityComponentTypes
                                                ).forEach((v) => Object.assign(
                                                    directory.Components,
                                                    {
                                                        get [v]() {
                                                            return target.getComponent(
                                                                EntityComponentTypes[v]
                                                            );
                                                        },
                                                    }
                                                )
                                                );
                                                path.forEach((v) => {
                                                    directory = directory[v];
                                                });
                                                pbsend(player, directory);
                                            } catch (e) {
                                                player.sendError(e);
                                            }
                                        });
                                        break;
                                    case "storage":
                                        break;
                                    default:
                                        break;
                                }
                                break;
                            case "getdir":
                                switch (argsa.args[2]) {
                                    case "block":
                                        break;
                                    case "entity":
                                        let argsb = evaluateParameters(
                                            argsa.extra,
                                            ["targetSelector"]
                                        );
                                        let targets = targetSelectorAllListC(
                                            argsb.args[0],
                                            "",
                                            vTStr(player.location),
                                            player
                                        );
                                        //([$_\p{Lu}\p{Ll}\p{Lt}\p{Lm}\p{Lo}\p{Nl}][$_\p{Lu}\p{Ll}\p{Lt}\p{Lm}\p{Lo}\p{Nl}\u200C\u200D\p{Mn}\p{Mc}\p{Nd}\p{Pc}]*)
                                        let path = argsb.extra
                                            .trim()
                                            .match(
                                                /(?:\[(\d+)\]|\["((?:[^"]|(?<!(?:(?:[^\\]\\)(?:\\\\)*))")*)"\]|(?<=\.)([$_\p{Lu}\p{Ll}\p{Lt}\p{Lm}\p{Lo}\p{Nl}][$_\p{Lu}\p{Ll}\p{Lt}\p{Lm}\p{Lo}\p{Nl}\u200C\u200D\p{Mn}\p{Mc}\p{Nd}\p{Pc}]*)|^([$_\p{Lu}\p{Ll}\p{Lt}\p{Lm}\p{Lo}\p{Nl}][$_\p{Lu}\p{Ll}\p{Lt}\p{Lm}\p{Lo}\p{Nl}\u200C\u200D\p{Mn}\p{Mc}\p{Nd}\p{Pc}]*))/gu
                                            );
                                        targets.forEach((target) => {
                                            try {
                                                let directory = {
                                                    Components: {},
                                                };
                                                Object.keys(
                                                    EntityComponentTypes
                                                ).forEach((v) => Object.assign(
                                                    directory.Components,
                                                    {
                                                        get [v]() {
                                                            return target.getComponent(
                                                                EntityComponentTypes[v]
                                                            );
                                                        },
                                                    }
                                                )
                                                );
                                                path.forEach((v) => {
                                                    directory = directory[v];
                                                });
                                                pbsend(
                                                    player,
                                                    Object.getOwnPropertyNames(
                                                        directory
                                                    )
                                                );
                                            } catch (e) {
                                                player.sendError(e);
                                            }
                                        });
                                        break;
                                    case "storage":
                                        break;
                                    default:
                                        break;
                                }
                                break;
                            case "getdes":
                                switch (argsa.args[2]) {
                                    case "block":
                                        break;
                                    case "entity":
                                        let argsb = evaluateParameters(
                                            argsa.extra,
                                            ["targetSelector"]
                                        );
                                        let targets = targetSelectorAllListC(
                                            argsb.args[0],
                                            "",
                                            vTStr(player.location),
                                            player
                                        );
                                        //([$_\p{Lu}\p{Ll}\p{Lt}\p{Lm}\p{Lo}\p{Nl}][$_\p{Lu}\p{Ll}\p{Lt}\p{Lm}\p{Lo}\p{Nl}\u200C\u200D\p{Mn}\p{Mc}\p{Nd}\p{Pc}]*)
                                        let path = argsb.extra
                                            .trim()
                                            .match(
                                                /(?:\[(\d+)\]|\["((?:[^"]|(?<!(?:(?:[^\\]\\)(?:\\\\)*))")*)"\]|(?<=\.)([$_\p{Lu}\p{Ll}\p{Lt}\p{Lm}\p{Lo}\p{Nl}][$_\p{Lu}\p{Ll}\p{Lt}\p{Lm}\p{Lo}\p{Nl}\u200C\u200D\p{Mn}\p{Mc}\p{Nd}\p{Pc}]*)|^([$_\p{Lu}\p{Ll}\p{Lt}\p{Lm}\p{Lo}\p{Nl}][$_\p{Lu}\p{Ll}\p{Lt}\p{Lm}\p{Lo}\p{Nl}\u200C\u200D\p{Mn}\p{Mc}\p{Nd}\p{Pc}]*))/gu
                                            );
                                        targets.forEach((target) => {
                                            try {
                                                let directory = {
                                                    Components: {},
                                                };
                                                Object.keys(
                                                    EntityComponentTypes
                                                ).forEach((v) => Object.assign(
                                                    directory.Components,
                                                    {
                                                        get [v]() {
                                                            return target.getComponent(
                                                                EntityComponentTypes[v]
                                                            );
                                                        },
                                                    }
                                                )
                                                );
                                                path.forEach((v) => {
                                                    directory = directory[v];
                                                });
                                                pbsend(
                                                    player,
                                                    Object.getOwnPropertyDescriptors(
                                                        directory
                                                    )
                                                );
                                            } catch (e) {
                                                player.sendError(e);
                                            }
                                        });
                                        break;
                                    case "storage":
                                        break;
                                    default:
                                        break;
                                }
                                break;
                            case "getdirb":
                                switch (argsa.args[2]) {
                                    case "block":
                                        break;
                                    case "entity":
                                        let argsb = evaluateParameters(
                                            argsa.extra,
                                            ["targetSelector"]
                                        );
                                        let targets = targetSelectorAllListC(
                                            argsb.args[0],
                                            "",
                                            vTStr(player.location),
                                            player
                                        );
                                        //([$_\p{Lu}\p{Ll}\p{Lt}\p{Lm}\p{Lo}\p{Nl}][$_\p{Lu}\p{Ll}\p{Lt}\p{Lm}\p{Lo}\p{Nl}\u200C\u200D\p{Mn}\p{Mc}\p{Nd}\p{Pc}]*)
                                        let path = argsb.extra
                                            .trim()
                                            .match(
                                                /(?:\[(\d+)\]|\["((?:[^"]|(?<!(?:(?:[^\\]\\)(?:\\\\)*))")*)"\]|(?<=\.)([$_\p{Lu}\p{Ll}\p{Lt}\p{Lm}\p{Lo}\p{Nl}][$_\p{Lu}\p{Ll}\p{Lt}\p{Lm}\p{Lo}\p{Nl}\u200C\u200D\p{Mn}\p{Mc}\p{Nd}\p{Pc}]*)|^([$_\p{Lu}\p{Ll}\p{Lt}\p{Lm}\p{Lo}\p{Nl}][$_\p{Lu}\p{Ll}\p{Lt}\p{Lm}\p{Lo}\p{Nl}\u200C\u200D\p{Mn}\p{Mc}\p{Nd}\p{Pc}]*))/gu
                                            );
                                        targets.forEach((target) => {
                                            try {
                                                let directory = {
                                                    Components: {},
                                                    get Air() {
                                                        return target.getComponent(
                                                            "breathable"
                                                        ).airSupply;
                                                    },
                                                    set Air(airSupply: number) {
                                                        target.getComponent(
                                                            "breathable"
                                                        ).airSupply = airSupply;
                                                    },
                                                };
                                                Object.keys(
                                                    EntityComponentTypes
                                                ).forEach((v) => Object.assign(
                                                    directory.Components,
                                                    {
                                                        get [v]() {
                                                            return target.getComponent(
                                                                EntityComponentTypes[v]
                                                            );
                                                        },
                                                    }
                                                )
                                                );
                                                path.forEach((v) => {
                                                    directory = directory[v];
                                                });
                                                pbsend(
                                                    player,
                                                    Object.getOwnPropertyNames(
                                                        directory.constructor
                                                            .prototype
                                                    )
                                                );
                                            } catch (e) {
                                                player.sendError(e);
                                            }
                                        });
                                        break;
                                    case "storage":
                                        break;
                                    default:
                                        break;
                                }
                                break;
                            case "getdesb":
                                switch (argsa.args[2]) {
                                    case "block":
                                        break;
                                    case "entity":
                                        let argsb = evaluateParameters(
                                            argsa.extra,
                                            ["targetSelector"]
                                        );
                                        let targets = targetSelectorAllListC(
                                            argsb.args[0],
                                            "",
                                            vTStr(player.location),
                                            player
                                        );
                                        //([$_\p{Lu}\p{Ll}\p{Lt}\p{Lm}\p{Lo}\p{Nl}][$_\p{Lu}\p{Ll}\p{Lt}\p{Lm}\p{Lo}\p{Nl}\u200C\u200D\p{Mn}\p{Mc}\p{Nd}\p{Pc}]*)
                                        let path = argsb.extra
                                            .trim()
                                            .match(
                                                /(?:\[(\d+)\]|\["((?:[^"]|(?<!(?:(?:[^\\]\\)(?:\\\\)*))")*)"\]|(?<=\.)([$_\p{Lu}\p{Ll}\p{Lt}\p{Lm}\p{Lo}\p{Nl}][$_\p{Lu}\p{Ll}\p{Lt}\p{Lm}\p{Lo}\p{Nl}\u200C\u200D\p{Mn}\p{Mc}\p{Nd}\p{Pc}]*)|^([$_\p{Lu}\p{Ll}\p{Lt}\p{Lm}\p{Lo}\p{Nl}][$_\p{Lu}\p{Ll}\p{Lt}\p{Lm}\p{Lo}\p{Nl}\u200C\u200D\p{Mn}\p{Mc}\p{Nd}\p{Pc}]*))/gu
                                            );
                                        targets.forEach((target) => {
                                            try {
                                                let directory = {
                                                    Components: {},
                                                };
                                                Object.keys(
                                                    EntityComponentTypes
                                                ).forEach((v) => Object.assign(
                                                    directory.Components,
                                                    {
                                                        get [v]() {
                                                            return target.getComponent(
                                                                EntityComponentTypes[v]
                                                            );
                                                        },
                                                    }
                                                )
                                                );
                                                path.forEach((v) => {
                                                    directory = directory[v];
                                                });
                                                pbsend(
                                                    player,
                                                    Object.getOwnPropertyDescriptors(
                                                        directory.constructor
                                                            .prototype
                                                    )
                                                );
                                            } catch (e) {
                                                player.sendError(e);
                                            }
                                        });
                                        break;
                                    case "storage":
                                        break;
                                    default:
                                        break;
                                }
                                break;
                            default:
                                break;
                        }
                    });
                }
                break;
            case !!switchTest.match(/^execute$/):
                {
                    eventData.cancel = true;
                    srun(() => {
                        const argsa = evaluateParameters(switchTestB, [
                            "presetText",
                            "f-fsqbc",
                        ]);
                        const keepFeedback = argsa.args[1].f;
                        const surpressFeedback = argsa.args[1].s;
                        const silentCMD = argsa.args[1].q;
                        const builtIn = argsa.args[1].b;
                        const custom = argsa.args[1].c;
                        let sendErrorsTo = undefined;
                        let wl = [
                            new WorldPosition(
                                tryget(
                                    () => player.modifiedlocation ??
                                        player.location
                                ) ?? { x: 0, y: 0, z: 0 },
                                tryget(
                                    () => player.rotation ?? player.getRotation()
                                ) ?? { x: 0, y: 0 },
                                tryget(
                                    () => player.modifieddimension ??
                                        player.dimension
                                ) ?? overworld,
                                player.player,
                                player.block
                            ),
                        ];
                        function evalExecuteCommand(rest: string) {
                            const argsa = evaluateParameters(rest, [
                                "presetText",
                            ]);
                            const mode = argsa.args[0];
                            const resta = argsa.extra;
                            switch ((mode ?? "").toLowerCase()) {
                                case "as":
                                    {
                                        const args = evaluateParameters(resta, [
                                            "targetSelector",
                                        ]);
                                        wl = wl
                                            .map((wl, i) => wl.as(
                                                targetSelectorAllListC(
                                                    args.args[0],
                                                    "",
                                                    vTStr(wl.location),
                                                    wl.entity
                                                )
                                            )
                                            )
                                            .flat();
                                        evalExecuteCommand(args.extra);
                                        return;
                                    }
                                    break;
                                case "at": {
                                    const args = evaluateParameters(resta, [
                                        "targetSelector",
                                    ]);
                                    wl = wl
                                        .map((wl, i) => wl.at(
                                            targetSelectorAllListC(
                                                args.args[0],
                                                "",
                                                vTStr(wl.location),
                                                wl.entity
                                            )
                                        )
                                        )
                                        .flat();
                                    evalExecuteCommand(args.extra);
                                    return;
                                }
                                case "sendfeedbackto":
                                    {
                                        const args = evaluateParameters(resta, [
                                            "targetSelector",
                                        ]);
                                        wl = wl.map((wl, i) => wl.setSendErrorsTo(
                                            targetSelectorAllListC(
                                                args.args[0],
                                                "",
                                                vTStr(wl.location),
                                                wl.entity
                                            )
                                        )
                                        );
                                        evalExecuteCommand(args.extra);
                                        return;
                                    }
                                    break;
                                case "resetfeedbacktarget":
                                    {
                                        wl = wl.map((wl, i) => wl.clearSendErrorsTo()
                                        );
                                        evalExecuteCommand(resta);
                                        return;
                                    }
                                    break;
                                case "asblock":
                                    {
                                        const args = evaluateParameters(resta, [
                                            "Vector",
                                            "Vector",
                                            "Vector",
                                        ]);
                                        wl.forEach((wl) => wl.asblock(
                                            wl.dimension.getBlock(
                                                evaluateCoordinates(
                                                    args.args[0],
                                                    args.args[1],
                                                    args.args[2],
                                                    wl.location,
                                                    wl.rotation
                                                )
                                            )
                                        )
                                        );
                                        evalExecuteCommand(args.extra);
                                        return;
                                    }
                                    break;
                                case "asblockin":
                                    {
                                        const args = evaluateParameters(resta, [
                                            "dimension",
                                            "Vector",
                                            "Vector",
                                            "Vector",
                                        ]);
                                        wl.forEach((wl) => wl.asblock(
                                            args.args[0].getBlock(
                                                evaluateCoordinates(
                                                    args.args[1],
                                                    args.args[2],
                                                    args.args[3],
                                                    wl.location,
                                                    wl.rotation
                                                )
                                            )
                                        )
                                        );
                                        evalExecuteCommand(args.extra);
                                        return;
                                    }
                                    break;
                                case "facingblock":
                                    {
                                        const args = evaluateParameters(resta, [
                                            "Vector",
                                            "Vector",
                                            "Vector",
                                        ]);
                                        wl.forEach((wl) => wl.facing(
                                            evaluateCoordinates(
                                                args.args[0],
                                                args.args[1],
                                                args.args[2],
                                                wl.location,
                                                wl.rotation
                                            )
                                        )
                                        );
                                        evalExecuteCommand(args.extra);
                                        return;
                                    }
                                    break;
                                case "facing":
                                    {
                                        const args = evaluateParameters(resta, [
                                            "targetSelector",
                                        ]);
                                        wl = wl
                                            .map((wl, i) => wl.facingEntity(
                                                targetSelectorAllListC(
                                                    args.args[0],
                                                    "",
                                                    vTStr(wl.location),
                                                    wl.entity
                                                )
                                            )
                                            )
                                            .flat();
                                        evalExecuteCommand(args.extra);
                                        return;
                                    }
                                    break;
                                case "facingentity":
                                    {
                                        const args = evaluateParameters(resta, [
                                            "targetSelector",
                                        ]);
                                        wl = wl
                                            .map((wl, i) => wl.facingEntity(
                                                targetSelectorAllListC(
                                                    args.args[0],
                                                    "",
                                                    vTStr(wl.location),
                                                    wl.entity
                                                )
                                            )
                                            )
                                            .flat();
                                        evalExecuteCommand(args.extra);
                                        return;
                                    }
                                    break;
                                case "positioned":
                                    {
                                        const args = evaluateParameters(resta, [
                                            "Vector",
                                            "Vector",
                                            "Vector",
                                        ]);
                                        wl.forEach((wl) => wl.positioned(
                                            vTStr(
                                                evaluateCoordinates(
                                                    args.args[0],
                                                    args.args[1],
                                                    args.args[2],
                                                    wl.location,
                                                    wl.rotation
                                                )
                                            )
                                        )
                                        );
                                        evalExecuteCommand(args.extra);
                                        return;
                                    }
                                    break;
                                case "offset":
                                    {
                                        const args = evaluateParameters(resta, [
                                            "number",
                                            "number",
                                            "number",
                                        ]);
                                        wl.forEach((wl) => wl.offset({
                                            x: args.args[0],
                                            y: args.args[1],
                                            z: args.args[2],
                                        })
                                        );
                                        evalExecuteCommand(args.extra);
                                        return;
                                    }
                                    break;
                                case "rotated":
                                    {
                                        const args = evaluateParameters(resta, [
                                            "Vector",
                                            "Vector",
                                        ]);
                                        wl.forEach((wl) => wl.rotated(
                                            args.args[1],
                                            args.args[0]
                                        )
                                        );
                                        evalExecuteCommand(args.extra);
                                        return;
                                    }
                                    break;
                                case "resetrotation":
                                    {
                                        wl.forEach((wl) => wl.resetRotation());
                                        evalExecuteCommand(resta);
                                        return;
                                    }
                                    break;
                                case "matchlocation":
                                    {
                                        const args = evaluateParameters(resta, [
                                            "targetSelector",
                                        ]);
                                        wl = wl
                                            .map((wl, i) => wl.matchlocation(
                                                targetSelectorAllListC(
                                                    args.args[0],
                                                    "",
                                                    vTStr(wl.location),
                                                    wl.entity
                                                )
                                            )
                                            )
                                            .flat();
                                        evalExecuteCommand(args.extra);
                                        return;
                                    }
                                    break;
                                case "matchrotation":
                                    {
                                        const args = evaluateParameters(resta, [
                                            "targetSelector",
                                        ]);
                                        wl = wl
                                            .map((wl, i) => wl.matchrotation(
                                                targetSelectorAllListC(
                                                    args.args[0],
                                                    "",
                                                    vTStr(wl.location),
                                                    wl.entity
                                                )
                                            )
                                            )
                                            .flat();
                                        evalExecuteCommand(args.extra);
                                        return;
                                    }
                                    break;
                                case "matchdimension":
                                    {
                                        const args = evaluateParameters(resta, [
                                            "targetSelector",
                                        ]);
                                        wl = wl
                                            .map((wl, i) => wl.matchdimension(
                                                targetSelectorAllListC(
                                                    args.args[0],
                                                    "",
                                                    vTStr(wl.location),
                                                    wl.entity
                                                )
                                            )
                                            )
                                            .flat();
                                        evalExecuteCommand(args.extra);
                                        return;
                                    }
                                    break;
                                case "in":
                                    {
                                        const args = evaluateParameters(resta, [
                                            "presetText",
                                        ]);
                                        wl.forEach((wl) => wl.in(args.args[0]));
                                        evalExecuteCommand(args.extra);
                                        return;
                                    }
                                    break;
                                case "align":
                                    {
                                        const args = evaluateParameters(resta, [
                                            "presetText",
                                        ]);
                                        wl.forEach((wl) => wl.align(args.args[0])
                                        );
                                        evalExecuteCommand(args.extra);
                                        return;
                                    }
                                    break;
                                case "anchored":
                                    {
                                        const args = evaluateParameters(resta, [
                                            "presetText",
                                        ]);
                                        wl.forEach((wl) => wl.anchored(args.args[0])
                                        );
                                        evalExecuteCommand(args.extra);
                                        return;
                                    }
                                    break;
                                case "if":
                                    {
                                        const args = evaluateParameters(resta, [
                                            "presetText",
                                        ]);
                                        switch (args.args[0]) {
                                            case "block":
                                                {
                                                    const argsb = evaluateParameters(
                                                        args.extra,
                                                        [
                                                            "Vector",
                                                            "Vector",
                                                            "Vector",
                                                            "block",
                                                        ]
                                                    );
                                                    wl = wl.filter(
                                                        (wl) => !!tryget(() => !!argsb.args[3]
                                                            .states
                                                            ? testBlockForMatch(
                                                                wl.dimension.getBlock(
                                                                    evaluateCoordinates(
                                                                        argsb
                                                                            .args[0],
                                                                        argsb
                                                                            .args[1],
                                                                        argsb
                                                                            .args[2],
                                                                        wl.location,
                                                                        wl.rotation
                                                                    )
                                                                ),
                                                                argsb
                                                                    .args[3] as any
                                                            )
                                                            : wl.dimension.getBlock(
                                                                evaluateCoordinates(
                                                                    argsb
                                                                        .args[0],
                                                                    argsb
                                                                        .args[1],
                                                                    argsb
                                                                        .args[2],
                                                                    wl.location,
                                                                    wl.rotation
                                                                )
                                                            )
                                                                .typeId ==
                                                            argsb
                                                                .args[3]
                                                                .id
                                                        )
                                                    );
                                                    evalExecuteCommand(
                                                        argsb.extra
                                                    );
                                                    return;
                                                }
                                                break;
                                            case "blocks":
                                                break;
                                            case "entity":
                                                {
                                                    const argsb = evaluateParameters(
                                                        args.extra,
                                                        ["targetSelector"]
                                                    );
                                                    wl = wl.filter(
                                                        (wl) => !!targetSelectorAllListC(
                                                            argsb.args[0],
                                                            "",
                                                            vTStr(
                                                                wl.location
                                                            ),
                                                            wl.entity
                                                        )
                                                    );
                                                    evalExecuteCommand(
                                                        argsb.extra
                                                    );
                                                    return;
                                                }
                                                break;
                                            case "score":
                                                break;
                                            default:
                                                break;
                                        }
                                        wl.forEach((wl) => wl.in(args.args[0]));
                                        evalExecuteCommand(args.extra);
                                        return;
                                    }
                                    break;
                                case "run":
                                    {
                                        wl.forEach((wl) => chatCommands({
                                            player: new executeCommandPlayerW(
                                                wl,
                                                surpressFeedback
                                                    ? null
                                                    : keepFeedback
                                                        ? player.player
                                                        : wl.sendErrorsTo
                                            ),
                                            silentCMD: silentCMD,
                                            isBultIn: builtIn,
                                            isCustom: custom,
                                            newMessage: resta
                                                .trimStart()
                                                .startsWith("\\")
                                                ? resta.trimStart()
                                                : "\\" + resta.trimStart(),
                                            returnBeforeChatSend: false,
                                            event: {
                                                sender: wl.entity as Player,
                                                message: resta
                                                    .trimStart()
                                                    .startsWith("\\")
                                                    ? resta.trimStart()
                                                    : "\\" +
                                                    resta.trimStart(),
                                                cancel: false,
                                            },
                                            eventData: {
                                                sender: wl.entity as Player,
                                                message: resta
                                                    .trimStart()
                                                    .startsWith("\\")
                                                    ? resta.trimStart()
                                                    : "\\" +
                                                    resta.trimStart(),
                                                cancel: false,
                                            },
                                            fromExecute: true,
                                        })
                                        );
                                        return;
                                    }
                                    break;
                                default:
                                    player.sendMessageB(
                                        `§cSyntax error: Unexpected "${mode}": at "${switchTestB.slice(
                                            -10 - rest.length,
                                            -rest.length
                                        )}>>${rest}<<"`
                                    );
                                    return;
                                    break;
                            }
                        }
                        evalExecuteCommand(argsa.extra);
                    });
                }
                break;
            case !!switchTest.match(/^viewplayershops$/):
                {
                    eventData.cancel = true;
                    if (config.shopSystem.player.enabled) {
                        srun(() => PlayerShop.openPublicShopsSelector(player.player)
                        );
                    } else {
                        player.sendError(
                            "§cSystemNotEnabledError: You cannot use this command because the server shop system is not enabled.",
                            true
                        );
                    }
                }
                break;
            case !!switchTest.match(/^viewservershops$/):
                {
                    eventData.cancel = true;
                    if (config.shopSystem.server.enabled) {
                        srun(() => ServerShop.openPublicShopsSelector(player.player)
                        );
                    } else {
                        player.sendError(
                            "§cSystemNotEnabledError: You cannot use this command because the server shop system is not enabled.",
                            true
                        );
                    }
                }
                break;
            default:
            //if(){}
        }
    } else {
        if (commanda?.type == "custom") {
            eventData.cancel = true;
            if ((commanda as command).customCommandType == "commands") {
                system.run(() => (commanda as command).run(
                    newMessage.slice(
                        (commanda as command).customCommandPrefix.length
                    ),
                    player,
                    player,
                    event
                )
                );
            } else {
                (commanda as command).run(
                    newMessage.slice(
                        (commanda as command).customCommandPrefix.length
                    ),
                    player,
                    player,
                    event
                );
            }
        } else {
        }
    }
}
